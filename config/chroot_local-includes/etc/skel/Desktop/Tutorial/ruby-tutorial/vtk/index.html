<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"> 
<HTML lang="ja">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=iso2022-jp">
<META name="author" content="whitecat">
<LINK REL="CONTENTS" href="./index.html">
<link rel="stylesheet" href="dennou-ruby.css" type="text/css">
<TITLE>Ruby-VTK Tutorial</TITLE>
</HEAD>
<BODY>

<H1>Ruby-VTK Tutorial</H1>
<HR/>

<H2>VTKのインストール</H2>
<P>
まずはVTKをインストールします。
</P>
<UL>
 <LI>CMakeをインストールする</LI>
      <P>
      <A HREF="http://www.cmake.org/HTML/Index.html">CMake本家HP</A>
      の "Download" のページからソースまたはコンパイル済バイナリを
      ダウンロードしましょう<BR>
      ソースをダウンロードした方は展開してコンパイル、インストールしましょ
      う
      </P>
 <LI>VTKをインストールする</LI>
      <P>
      <A HREF="http://public.kitware.com/VTK/">VTK本家HP</A>
      の "Get The Software" のページで
      "Download the official release (4.2)" をクリックし、
      <UL>
       <LI>VTK-4.2-LatestRelease.tar.gz</LI>
       <LI>VTKData-4.2.tar.gz</LI>
      </UL>
      をダウンロードしましょう。<BR>
      </P>
      <P>
      両方展開した後、VTKディレクトリに入りましょう。
      以下のコマンドを実行します。
      </P>
<PRE CLASS="source">
%cmake .
</PRE>
      <P>
      エラーが無いことを確認し、以下を実行します。
      </P>
<PRE CLASS="source">
%ccmake .
</PRE>
      <P>
      矢印の↑/↓ボタンで各項目に移動し、Enter を押して変更します。
      <UL>
       <LI>BUILD_SHARED_LIBS</LI>
	    "ON" に変更します。
       <LI>CMAKE_INSTALL_PREFIX</LI>
	    お好みのパスに変更します。
	    たいていは "/usr/local" でいいと思います。
       <LI>VTK_DATA_ROOT</LI>
	    先ほど "VTKData-4.2.tar.gz" を展開した先を指定します。<BR>
	    例) "/home/hoge/src" で展開していれば
	    "/home/hoge/src/VTKData-release-4-2" です。
       <LI>VTK_USE_HYBRID, VTK_USE_PATENTED, VTK_USE_RENDERING</LI>
	    "ON" に変更します。
       <LI>VTK_USE_PARALLEL</LI>
	    CPUが2つ以上ある環境であれば "ON" にするといいと思います。
       <LI>VTK_WRAP_JAVA, VTK_WRAP_PYTHON, VTK_WRAP_TCL</LI>
	    それぞれ使いたければ "ON" にしてください。<BR>
	    使わなくてもサンプルを実行することができるので
	    Rubyを書く際にも役に立ちます。
	    それぞれ Java, Python, Tcl がインストールされている必要があります。
      </UL>
      各項目を変更したらキーボードの "c" を押しましょう。
      下のメニューに "Press [g] to generate and exit" の項目がある方は
      "g" を押しましょう。設定完了です<BR>
      Java, Python, Tcl を "ON" にした方はおそらくいくつか
      追加設定する必要があります。
      "*"印がついているところを新たに環境に合わせて設定しましょう。
      "PYTHON_LIBRARY" は "/usr/lib/python2.3/config/libpython2.3.a"
      みたいなところにあると思います。
      設定できたら "c" を押しましょう。
      下のメニューに "Press [g] to generate and exit"
      の項目が追加されたと思います。"g" を押しましょう。
      </P>
      <P>
      あとはコンパイルします。
      以下を実行して終わるまでコーヒーでも飲んで待ちましょう。
      </P>
<PRE CLASS="source">
%make
</PRE>
      <P>
      無事終わればあとはインストールです。
      もしエラーが出てコンパイルに失敗した人は
      エラーメッセージを見て頑張って修正しましょう。
      </P>
<PRE CLASS="source">
%su -
#make install
</PRE>
      <P>
      無事インストール完了です。
</UL>
<P>
サンプルを動かして遊びましょう("Example" ディレクトリにあります)。
<UL>
 <LI>Cxx</LI>
      サンプルを動かすには
<PRE CLASS="source">
%cmake .
%make
</PRE>
      で実行ファイルができるので、それを実行してください。
 <LI>Python</LI>
      以下のように実行します。
<PRE CLASS="source">
%vtkpython hoge.py
</PRE>
 <LI>Tcl</LI>
      以下のように実行します。
<PRE CLASS="source">
%vtk hoge.tcl
</PRE>
</UL>

<P>
VTK については以下が役に立つと思います。
<UL>
 <LI><A HREF="http://public.kitware.com/VTK/doc/release/4.0/html/">
      VTK 4.0.2 Documentation</A></LI>
 <LI><A HREF="http://donguri.sakura.ne.jp/~shock8/3d/vtk_index.html">
      尺八郎の3Dで始めるプログラミング(Visualization ToolKit)</A></LI>
</UL>
</P>
      



<H2>Ruby-VTKのインストール</H2>
<P>
次にRuby-VTKをインストールします。
</P>
<P>
現在 cygwin にはインストールできません。<BR>
VTK が "g++" の "-m win32" オプション付でコンパイルされるのに対し、
cygwin official の ruby がおそらく 上記オプションなしでコンパイルされて
いることが原因と考えられます。
</P>
<P>
<A HREF="http://www.gfd-dennou.org/arch/ruby/products/ruby-vtk/index-j.html">
Ruby-VTK HP</A>
から "ruby-vtk-{version}.tar.gz" をダウンロードします。<BR>
展開後、 "ruby-vtk-{version}" ディレクトリに入ります。<BR>
以下を実行してください。
</P>
<PRE CLASS="source">
%ruby extconf.rb
%make
%su -
#make install
</PRE>
<P>
エラー無く終われば無事インストール完了です。<BR>
エラーがでた場合は、
あなたの環境(OS, C++コンパイラ, rubyバージョン)と
エラーメッセージを作者に報告してください。
</P>
<P>
サンプルを試しましょう。
"sample" ディレクトリにいくつかサンプルがあります。



<H2>Ruby-VTKをつかう</H2>

<H3>Ruby-VTKの使い方</H3>
<P>
では実際に Ruby-VTK を使ってみましょう。
使用するためには
</P>
<PRE CLASS="source">
require "vtk"
</PRE>
<P>
とします。
ロード時間が気になる方は必要なコンポーネントだけロードすることもできます
(vtk/Common, vtk/Filtering, vtk/Graphics, vtk/IO, vtk/Imaging,
vtk/Rendering, vtk/Patented, vtk/Parallel, vtk/Hybrid)。
</P>
<P>
とりあえず VTK の バージョンでも調べてみましょう
</P>
<PRE CLASS="source">
%irb -r vtk
irb(main):001:0> Vtk::VTK_VERSION
=> "4.2.6"
</PRE>
<P>
あなたがインストールした VTK のバージョンが表示されたはずです。
</P>

<H3>クラスの名前</H3>
<P>
VTK のクラスの名前は "vtkObject" のように 小文字の vtk が先頭についています。
Ruby-VTK ではすべてのクラスが Vtkモジュールの下に定義されています。
それぞれのクラスは "Vtk::Object" のように
VTK のクラス名の先頭の vtk を除いた名前となります。<BR>
いくつか例外があります。
VTK には、
"vtk3DS vtk3DSImporter, vtk3DWidget"
といったクラスがあります。
Ruby のクラス名(定数) は一文字目に数字をとることができませんので
"Vtk::3DS" といった名前にはできません。
したがってこれらは
"Vtk::H3DS, Vtk::H3DSImporter, VTK::H3DWidget"
というようになります。
ちなみに、"H" はこれらが所属する "Hybrid" の "H" です。
</P>



<H3>クラス作成とメモリ解放</H3>
<P>
VTK では、クラス作成に "New()" 関数を呼びます。
Ruby-Vtk では、他のクラスと同様に "new" クラスメソッドを呼びます。
</P>
<PRE CLASS="source">
ren = Vtk::Renderer.new
</PRE>
<P>
VTK では、使い終わったら "Delete()" メソッドを呼んであげる必要があります。
Ruby-Vtk では、GCが面倒を見てくれるのでそのような操作は必要ありません。
</P>


<H3>メソッド名</H3>
<P>
メソッド名は VTKのメソッドの名前そのままです。<BR>
例えば、VTK で
</P>
<PRE CLASS="source">
vtkPoints *points vtkPoints::New();
points->InsertNextPoint(1,2,3);
</PRE>
<P>
は、Ruby-VTK では
</P>
<PRE CLASS="source">
points = Vtk::Points.new
points.InsertNextPoint(1,2,3)
</PRE>
<P>
となります。
</P>


<H3>Ruby-VTK オリジナル機能</H3>
<P>
Ruby-VTK オリジナルの機能が "vtk/Misc" です。
現在 "NArray" から "vtkArray" への変換が用意されています。
</P>
<PRE CLASS="source">
nary = NArray.byte(100).indgen
vary = nary.to_va # => Vtk::CharArray

nary = NArray.sint(100).indgen
vary = nary.to_va # => Vtk::ShortArray

nary = NArray.int(100).indgen
vary = nary.to_va # => Vtk::IntArray or Vtk::LongArray

nary = NArray.sfloat(100).indgen
vary = nary.to_va # => Vtk::FloatArray

nary = NArray.float(100).indgen
vary = nary.to_va # => Vtk::DoubleArray
</PRE>

<H3>使用例</H3>
<P>
では実際にNetCDFファイルデータを使って、
等値面を描く例を見てみましょう。<BR>
使用する ソースコード および データファイル はこちらです。
<A HREF="water.rb">water.rb</A>,<A HREF="water.nc">water.nc</A>
</P>

<P>
ソースコードを順番に見ていきましょう。
</P>
<PRE CLASS="source">
require "numru/gphys"
require "vtk"
include Vtk
include NumRu

p "open"
fname = "water.nc"
vname = "Cloud_water_content"
  
gphys = GPhys::IO.open(fname,vname)
shape = gphys.shape
val = gphys.val

x = gphys.coord(0).val
y = gphys.coord(1).val
yfact = (x.max-x.min)/(y.max-y.min)
z = gphys.coord(2).val
zfact = (x.max-x.min)/(z.max-z.min)
x = x.to_va
y = y.to_va
z = z.to_va
f = val.reshape!(shape[0]*shape[1]*shape[2]).to_va
</PRE>
<P>
まずは "GPhys" を用いて "NetCDF" ファイルからデータを読み出し、
"NArray" にし、
その後 "Vtk::Array" に変換しています。
</P>

<PRE CLASS="source">
data = RectilinearGrid.new
data.SetDimensions(*shape)
data.SetXCoordinates(x)
data.SetYCoordinates(y)
data.SetZCoordinates(z)
data.GetPointData.SetScalars(f)
</PRE>
<P>
ここから VTK の本番です。
"Vtk::RectilinearGrid" という格子点データ(不等間隔も許す)を作って、
先ほどのデータを入れています。
</P>

<PRE CLASS="source">
surface = ContourFilter.new
surface.SetInput(data)
surface.SetValue(0,0.0007)
</PRE>
<P>
0.0007の値の等値面を作ります。
データを変換する際はこのように "Filter" を利用します。
</P>

<PRE CLASS="source">
mapper = PolyDataMapper.new
mapper.SetInput(surface.GetOutput)
mapper.SetScalarModeToUsePointFieldData

actor = Actor.new
actor.SetMapper(mapper)
actor.GetProperty.SetOpacity(0.5)
actor.SetScale(1,yfact,zfact)
</PRE>
<P>
"Mapper", "Actor" は "Filter" を実際に表示するためのデータに変換します。
"SetOpacity" は透明度を設定しています。
"SetScale" は軸のスケールの設定です。
</P>


<PRE CLASS="source">
outline = RectilinearGridOutlineFilter.new
outline.SetInput(data)
mapper_ol = PolyDataMapper.new
mapper_ol.SetInput(outline.GetOutput)
actor_ol = Actor.new
actor_ol.SetMapper(mapper_ol)
actor_ol.SetScale(1,yfact,zfact)
</PRE>
<P>
アウトラインを作っています。
</P>


<PRE CLASS="source">
#axes
bounds = data.GetBounds
length = data.GetLength
axes = Axes.new
axes.SetOrigin(bounds[0],bounds[2],bounds[4])
axes.SetScaleFactor(length*0.8)
tube_ax = TubeFilter.new
tube_ax.SetInput(axes.GetOutput)
tube_ax.SetRadius(length/50)
tube_ax.SetNumberOfSides(6)
mapper_ax = PolyDataMapper.new
mapper_ax.SetInput(tube_ax.GetOutput)
actor_ax = Actor.new
actor_ax.SetMapper(mapper_ax)
</PRE>
<P>
軸を作っています。
</P>


<PRE CLASS="source">
# graphics stuff
renderer = Renderer.new
renWin = RenderWindow.new
renWin.AddRenderer(renderer)
iren = RenderWindowInteractor.new
iren.SetRenderWindow(renWin)

# read data  //set up renderer
renderer.AddActor(actor_ax)
renderer.AddActor(actor_ol)
renderer.AddActor(actor)
renderer.SetBackground(1,1,1)
renWin.SetSize(500,500)
renderer.SetBackground(0.1, 0.2, 0.4)

# interact with data
iren.Initialize

renWin.Render
iren.Start
</PRE>
<P>
実際に描画するウィンドウや、
マウスやキーボードの操作(おまかせ)を設定しています。
</P>

<P>
実際に実行してみましょう。
このデータは赤道域の雲水量のデータです。
なんだか雲らしいものが見えますね。
</P>
<P>
マウスの左ボタンでカメラの回転、
中ボタンでカメラの平行移動、
右ボタンでズームです。
キーボードの "q" で終了します。
</P>

スクリーンショット<BR>
<IMG SRC="water.png">



<H3>使用例 その2 (GTKとの組み合わせ)</H3>
<P>
先ほどの例で異なる値の等値面を見たい場合は、
ソースコードを書き換える必要があります。
なにかマウスでボタンをスライドさせて
インターラクティブにその値を自由に変えてみたい、
なんて欲がでてきます。
</P>
<P>
VTKは比較的簡単に他のGUIツールと組み合わせることができます。
GTKを使う場合、
いくつかインストールする必要があります。
<P>
<UL>
 <LI><A HREF="http://www2.giganet.net/~yoshi/">rbogl</A>
 <LI><A HREF="http://ruby-gnome2.sourceforge.jp/ja/index.html">
      ruby-gnome2-all (ruby-gtkglext)</A></LI>
</UL>

<P>
では次の rubyコードを実行してみましょう。<BR>
<A HREF="surface.rb">surface.rb</A>
</P>
<PRE CLASS="source">
%ruby surface.rb water.nc Cloud_water_content
</PRE>
<P>
下にスライドがありますね。
動かしてみましょう。
等値面が変わるのが分かります。
</P>

スクリーンショット<BR>
<IMG SRC="surface.png">

<P>
同様に X,Y,Z面で切った断面をインターラクティブに動かす例です。<BR>
<A HREF="plane.rb">plane.rb</A>
</P>
<PRE CLASS="source">
%ruby plane.rb water.nc Cloud_water_content
</PRE>

スクリーンショット<BR>
<IMG SRC="plane.png">



</BODY>
</HTML>
