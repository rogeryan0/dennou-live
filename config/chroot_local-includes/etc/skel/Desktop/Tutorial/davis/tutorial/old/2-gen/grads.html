<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="ja">
<head>
<title>GrADS</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp" />
<link rel="stylesheet" type="text/css" href="rubydcl.css"/>
</head>

<body>
<h1><a name="title" id="title">チュートリアル</a></h1>
<hr/>
<h2><a name="grads" id="grads">べた書きGrADSデータの読み出し</a></h2>
<p>
<a href="http://grads.iges.org/grads/index.html">
GrADS</a> のファイルを読み込む例を示して
<ul>
 <li><a href="#file">ファイルアクセス</a></li>
 <li><a href="#string">文字列操作</a></li>
 <li><a href="#binary">バイナリデータの扱い</a></li>
</ul>
を見ていきたいと思います。
</p>

<h3><a name="file" id="file">ファイルアクセス</a></h3>
<p>
ファイルのオープンとクローズは
<a href="http://www.ruby-lang.org/ja/man-1.6/?cmd=view;name=File">
File クラス</a>または
<a href="http://www.ruby-lang.org/ja/man-1.6/?cmd=view;name=%C1%C8%B9%FE%A4%DF%B4%D8%BF%F4">
組み込み関数</a> open を使用して
<table width="80%"><tr><td><pre class="source">
file = File.open(filename [,mode])  or  file = open(filename [,mode])
   :
file.close
</pre></td></tr></table>
または、ブロックを使用して
<table width="80%"><tr><td><pre class="source">
File.open(filename [,mode]){|file|
   :
}
</pre></td></tr></table>
とします。
</p>
<p>
読み込みには
<table width="80%"><tr><td><pre class="source">
line = file.gets            # 1行読み込む
str = file.read(n)          # nバイト読み込む
file.each_byte{|ch| hoge}   # 1バイトづつ読み込んでブロックを実行する
file.each_line{|line| hoge} # 1行づつ読み込んでブロックを実行する
</pre></td></tr></table>
をつかいます。
このイタレーターとファイルのオープンクローズを合わせたものが
<table width="80%"><tr><td><pre class="source">
File.foreach(filename){|line| hoge}  # File.open{|file|file.each_line{|line|hoge}}とほぼ同じ
lines = file.readlines               # linesは各行の配列
</pre></td></tr></table>
です。
</p>
<p>
書き込みは
<table width="80%"><tr><td><pre class="source">
file.puts(strings)
file.print(strings)
</pre></td></tr></table>
です。C++のように
<table width="80%"><tr><td><pre class="source">
file << str1 << str2
</pre></td></tr></table>
なんてこともできます。
</p>

<p>
では GrADS のコントロールファイルをよんでいきましょう
<br/><a href="./grads.ctl">grads.ctl</a><br/>
<textarea cols="80" rows="10" class="source">
DSET    ^./data
TITLE test data
UNDEF -9.99E33
XDEF  128 LINEAR 0.0 2.8125
YDEF    64 LEVELS
      -87.864  -85.097  -82.313  -79.526  -76.737  -73.948  -71.158  -68.368
      -65.578  -62.787  -59.997  -57.207  -54.416  -51.626  -48.835  -46.045
      -43.254  -40.464  -37.673  -34.883  -32.092  -29.301  -26.511  -23.720
      -20.930  -18.139  -15.348  -12.558   -9.767   -6.977   -4.186   -1.395
        1.395    4.186    6.977    9.767   12.558   15.348   18.139   20.930
       23.720   26.511   29.301   32.092   34.883   37.673   40.464   43.254
       46.045   48.835   51.626   54.416   57.207   59.997   62.787   65.578
       68.368   71.158   73.948   76.737   79.526   82.313   85.097   87.864
ZDEF   10 LEVELS
        1000 925 850 700 600 500 400 300 250 200
TDEF   12 LINEAR JAN2000 1MO
VARS   2
U         21  99 ZONAL VELOCITY                [M/S          ]
V         21  99 MERIDIONAL VELOCITY           [M/S          ]
ENDVARS
</textarea><br/>

<h3><a name="string" id="string">文字列操作</a></h3>
<p>
ruby がもっとも得意とするのがこの文字列操作です。
<a href="http://www.ruby-lang.org/ja/man-1.6/?cmd=view;name=String">
String クラス</a>
には様々なメソッドが用意させており、
また強力な
<a href="http://www.ruby-lang.org/ja/man-1.6/?cmd=view;name=%C0%B5%B5%AC%C9%BD%B8%BD">
正規表現</a>
も使うことができます。
</p>
<p>
コントロールファイルの各行はスペースで区切られた要素から成り立っています。
この要素からなる
<a href="http://www.ruby-lang.org/ja/man-1.6/?cmd=view;name=Array">
Array クラス</a> を作ってみましょう。
<table width="80%"><tr><td><pre class="source">
open('grads.ctl','r'){|file|
  ary = file.gets.split     # ary = ["DSET","^./data"]
}
</pre></td></tr></table>
簡単ですね。
String#split(pattern) は
pattern で指定された区切り文字 or 正規表現で文字列を分割し、
それらの部分文字列の配列を返します。
pattern が省略されると $;の値(nilの場合' ')が使われます。<br/>
これらのデータの
<a href="http://www.ruby-lang.org/ja/man-1.6/?cmd=view;name=Hash">
Hash クラス</a>
を作ります。
<table width="80%"><tr><td><pre class="source">
data = Hash.new
open('grads.ctl','r'){|file|
  while line = file.gets do
    ary = line.split
    data[ary[0]] = ary[1..-1]
  end
}
</pre></td></tr></table>
先頭がスペースの行は前行からの続きです。
<table width="80%"><tr><td><pre class="source">
if line =~ /^\s/ then
  data[last] = data[last]+ary
else
  last = ary[0]
  data[last] = ary[1..-1]
end
</pre></td></tr></table>
とします。
</p>
<p>
変数は別の Hash に入れたいと思います。
<table width="80%"><tr><td><pre class="source">
longname = Hash.new
unit = Hash.new
var = false
if line =~ /^VARS/ then
  nvar = line.split[1]
  var = true
elsif line =~ /^ENDVARS/ then
  var = false
elsif var then
  ary = line.split
  name = ary[0]
  str = ary[3..-1].join(' ')
  longname[name] = str[0..str.index('[')-2]
  unit[name] = str[str.index('[')+1..-3]
end
</pre></td></tr></table>
</p>
<p>
軸は少し工夫が必要です。
<table width="80%"><tr><td><pre class="source">
dims = Hash.new
data.each_key{|key|
  if key =~ /^.DEF$/
    ary = data[key]
    name = key[0].downcase
    if ary[1] == 'LINEAR'
      dims[name] = NArray.sfloat(ary[0].to_i).indgen!(ary[2].to_f,ary[3].to_f)
    elsif ary[1] == 'LEVELS'
      dims[name] = NArray.to_na( ary[2..-1].collect{|str| str.to_f} )
    end
    data.delete(key)
}
</pre></td></tr></table>
</p>
<p>
あとは個別の処理
<table width="80%"><tr><td><pre class="source">
data.each_key{|key|
  if key == 'TITLE' then
    data[key] = data[key].join(' ')
  elsif key == 'UNDEF'
    data[key] = data[key][0].to_f
  end
}
</pre></td></tr></table>
Array#join(str) は 配列の各要素を str を区切り文字とする文字列に変換します。
</p>
<p>
以上まとめると
<br/><a href="./grads1.rb">grads1.rb</a><br/>
<textarea cols="80" rows="10" class="source">
require "numru/netcdf"

include NumRu

data = Hash.new
dims = Hash.new
longname = Hash.new
unit = Hash.new

open('grads.ctl','r'){|file|
  var = false
  last = nil
  while line = file.gets do

    ary = line.split
    if line =~ /^\s/ then
      data[last] = data[last]+ary
    elsif line =~ /^VARS/ then
      var = true
    elsif line =~ /^ENDVARS/ then
      var = false
    elsif var then
      ary = line.split
      name = ary[0]
      str = ary[3..-1].join(' ')
      longname[name] = str[0..str.index('[')-2]
      unit[name] = str[str.index('[')+1..-3]
    else
      last = ary[0]
      data[last] = ary[1..-1]
    end

  end

}

data.each_key{|key|
  if key =~ /^.DEF$/
    ary = data[key]
    name = key[0..0].downcase
    if ary[1] == 'LINEAR'
      dims[name] = NArray.sfloat(ary[0].to_i).indgen!(ary[2].to_f,ary[3].to_f)
    elsif ary[1] == 'LEVELS'
      dims[name] = NArray.to_na( ary[2..-1].collect{|str| str.to_f} )
    end
    data.delete(key)
  elsif key == 'TITLE' then
    data[key] = data[key].join(' ')
  elsif key == 'UNDEF'
    data[key] = data[key][0].to_f
  end
}

p data
p dims
p longname
p unit
</textarea><br/>
となり各データがそろったことになります。
</p>

<h3><a name="binary" id="binary">バイナリデータの扱い</a></h3>
<p>
ではコントロールファイルが読めたところで
今度はバイナリファイルを読みたいと思います。<br/>
<a href="./grads1.data">grads1.data</a><br/>
128(x) x 64(y) x 10(z) x 2(var) x 12(month) x 4(sfloat)<br/>
というようにデータが入っています。
<table width="80%"><tr><td><pre class="source">
NArray.to_na(str,"sfloat",dim0,dim1,..)
</pre></td></tr></table>
を使うと簡単です。
<table width="80%"><tr><td><pre class="source">
idim = x.length
jdim = y.length
kdim = z.length
tdim = t.length
u = NArray.sfloat(idim,jdim,kdim,tdim)
v = NArray.sfloat(idim,jdim,kdim,tdim)
file = open('grads.data','r')
for m in 0..tdim-1
  str = file.read(4*idim*jdim*kdim)
  u[true,true,true,m] = NArray.to_na(str,"sfloat",idim,jdim,kdim)
  str = file.read(4*idim*jdim*kdim)
  v[true,true,true,m] = NArray.to_na(str,"sfloat",idim,jdim,kdim)
end
file.close
</pre></td></tr></table>
もし NArray が無い場合は
<table width="80%"><tr><td><pre class="source">
ary = str.unpack('f*')
</pre></td></tr></table>
で Array が取り出せます。
</p>
<p>
もしこのデータのエンディアンが異なる場合
<a href="./grads2.data">grads2.data</a><br/>
<table width="80%"><tr><td><pre class="source">
NArray.to_na(str,.....).swap_byte
str.unpack('e*') (リトルエンディアン)  or  str.unpack('g*') (ビッグエンディアン)
</pre></td></tr></table>
を使います。
</p>
<p>
あとはこのデータを煮ても焼いてもあなた次第です。
</p>


<hr/>
<a href="./index.html">return</a>

</body>
</html>