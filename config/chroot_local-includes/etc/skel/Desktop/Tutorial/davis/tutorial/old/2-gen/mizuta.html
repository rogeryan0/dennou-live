<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head>

<title>Dennou-Ruby Tutorial</title><link rel="stylesheet" type="text/css" href="Dennou-Ruby%20Tutorial_files/rubydcl.css"></head>


<body>
<h1><a name="label:0" id="label:0">Dennou-Rubyチュートリアルページ</a></h1>
<h2><a name="label:1" id="label:1">Rubyの基本的な使い方</a></h2>

<p>Rubyはスクリプト言語です。スクリプトを記述したファイルをつくりRubyを呼ぶと、
中身が実行されます。
<table width="80%"><tbody><tr><td class="source"><pre>% cat test1.rb
print("Hello, World\n")

% ruby test1.rb
Hello, World
</pre></td></tr></tbody></table>
日本語も使えます。
先頭に #! /usr/lib/ruby と書いて chmod +x しておけば % ./test.rb ですみます。
<table width="80%"><tbody><tr><td class="source"><pre>% cat test2.rb
#! /usr/lib/ruby
print("こんにちわ、世界\n")

% ./test2.rb
こんにちわ、世界
</pre></td></tr></tbody></table>
インラインで実行することも可能です。
<table width="80%"><tbody><tr><td class="source"><pre>% ruby -e 'print("Hello, World\n")'
Hello, World
</pre></td></tr></tbody></table>
また、対話型のrubyも用意されています。
<table width="80%"><tbody><tr><td class="source"><pre>% irb
irb(main):001:0&gt; print("Hello, World\n")
Hello, World
nil




</pre></td></tr></tbody></table>
</p><p>% irb -r ???.rb としておけばスクリプトを読んでからirb</p>

<p>Rubyには型宣言は不要です。
<table width="80%"><tbody><tr><td class="source"><pre>a = 2       # 整数
b = 3.5     # 実数
c = "apple" # 文字列
</pre></td></tr></tbody></table>

これらは、2 という整数オブジェクト、 3,5という実数オブジェクト、"apple" という文字列オブジェクトに
a, b, c という名札をつけたことに相当します。

<table width="80%"><tbody><tr><td class="source"><pre>a           # オブジェクトの内容を表示
b.type      # オブジェクトの型を表示
c.size      # オブジェクトの大きさを表示
3.5.type    # b.type と同じ
</pre></td></tr></tbody></table>

演算も当然できます。
<table width="80%"><tbody><tr><td class="source"><pre>d = a * ( b**2 + 3.0e2 )
</pre></td></tr></tbody></table>
複数の変数をいっぺんに操作することもできます。
<table width="80%"><tbody><tr><td class="source"><pre>e,f = a*b, c+"A"
</pre></td></tr></tbody></table>
オブジェクトを順番に並べたものが配列です。
配列の中は同じ型である必要はありません。
<table width="80%"><tbody><tr><td class="source"><pre>array1 = [ 3, b, d-3.0, "orange"]
array1[0]            # Cと同じで最初の要素が0番
array1[1..3]         # 1番から3番まで
array1[-1]           # 負の数はうしろから数える
array2 = [a, array1] # 配列の中に配列があっても大丈夫。
array2[1][3]         # array2[1]の3番の要素
</pre></td></tr></tbody></table>

大文字ではじめると定数になります。
<table width="80%"><tbody><tr><td class="source"><pre>A = 3.1415927
A = 1.7320508 # エラー？
</pre></td></tr></tbody></table>


for, if, while, caseなどが使えます。
<table width="80%"><tbody><tr><td class="source"><pre>for i in 1..5
 if i==2 then
  print "Hello, World !\n"
 else
  print i, "\n"
 end
end
</pre></td></tr></tbody></table>

数学関数は、Mathモジュールを使います。
<table width="80%"><tbody><tr><td class="source"><pre>a = Math::cos(0) # Mathというモジュールのcosという関数を呼ぶ
p = Math::PI
</pre></td></tr></tbody></table>
include文を使うと、以降は"Math::"の部分が不要になります。
<table width="80%"><tbody><tr><td class="source"><pre>include Math
a = cos(PI)
</pre></td></tr></tbody></table>


メソッド定義

<table width="80%"><tbody><tr><td class="source"><pre>def wa(a,b,c)
 d = a+b+c
 return d
end
wa(3,4,6)
</pre></td></tr></tbody></table>


クラス
</p>



<h2><a name="label:4" id="label:4">NArrayを使って計算</a></h2>
<p>Rubyに標準装備されている配列(Array)は、
オブジェクトを順番に並べたものであり、これもまた1つのオブジェクトです。
配列の要素は任意のオブジェクトを格納できるので、
<table width="80%"><tbody><tr><td class="source"><pre>array1 = [ 4, 3.1415, "apple", [2,3,4], file ]
</pre></td></tr></tbody></table>
となんでも一緒くたの配列を作ることもできます。
ただしその分計算速度が犠牲になっています。
そこでわれわれが数値計算をするときには
NArray という(クラス)パッケージを用いることにします。
</p>
<p>NArrayのメソッドについてはここ(SPEC.jp)に書いてあります。
</p>
<p>新たに配列を生成するには
NArray.型(大きさ,大きさ,...)
とします。たとえば3x4の単精度実数配列 hoge を作るには
<table width="80%"><tbody><tr><td class="source"><pre>hoge = NArray.sfloat(3,4)
</pre></td></tr></tbody></table>
です。
<table width="80%"><tbody><tr><td class="source"><pre>NArray.to_na(array1)
hoge = NArray.sfloat(6).fill(3.0)!  # 長さ6の配列で、中身はすべて3.0
p hoge                              # 変数のチェックには p 変数 を使う。
hoge = NArray.sfloat(6).indgen!     # 1ずつ増やした値をセット。
p hoge
</pre></td></tr></tbody></table>
インデックスはCと同じで、最初の要素番号は0、最後の要素番号は要素数-1
(これはArrayと同じ)


<table width="80%"><tbody><tr><td class="source"><pre>hoge = NArray.sfloat(6).indgen!(1.0,2.0) # 1から2ずつ増やした値をセット。
p hoge
p hoge[0]  # 最初の要素
p hoge[5]  # 最後の要素
p hoge[-1] # インデックスに負の数を与えるとうしろから数えます
</pre></td></tr></tbody></table>
多次元のインデックスの順序はFortran型

<table width="80%"><tbody><tr><td class="source"><pre>hoge = NArray.sfloat(2,3).indgen! 
p hoge
</pre></td></tr></tbody></table>

</p>

<h3><a name="label:5" id="label:5">オブジェクト指向的に使う</a></h3>
<p>.sort</p>


<h3>演習問題</h3>




<h2><a name="label:6" id="label:6">Ruby-DCLで絵を描く</a></h2>

<h3><a name="label:7" id="label:7">折れ線図</a></h3>

<p>Ruby-DCLを使って図を描いてみましょう。
必要なことは、先頭に require "numru/dcl" を加えることだけです。
DCLのサブルーチンを DCL::gropn(1) などのように書いてやれば
FortranのDCLと同じように動作します。
</p>
<p>例: hop.rb
</p>

<textarea cols="72" rows="10" class="source ">require "narray"
require "numru/dcl" 
include NumRu
include NMath 

nmax = 400
dt = 2*PI/(nmax-1)
t = NArray.sfloat(nmax).indgen! * dt
x = 1e2*sin(4*t)
y = 1e-3*cos(5*t)+6 

DCL::gropn(1)
DCL::grfrm 
DCL::ussttl('X-TITLE', 'x-unit', 'Y-TITLE', 'y-unit')
DCL::usgrph(x, y) 
DCL::grcls 
</textarea>

<table width="80%">
<tbody><tr><td class="results">
<img src="Dennou-Ruby%20Tutorial_files/hop.png" width="456" height="341"><br><br>
</td></tr></tbody></table>

<p>配列の長さを渡す引数は与える必要がなくなっています。
(例: CALL USGRPH(N,X,Y)  -&gt; DCL::usgrph(x,y) )
</p>
<p>先頭に include DCL と書いておけば、以降 DCL:: の部分を省略することもできます。
</p>
<h3><a name="label:8" id="label:8">等高線・ぬりわけ図
</a></h3>

<textarea cols="72" rows="10" class="source ">require "narray"
require "numru/dcl"

include NumRu
include NMath

nt = 51
nz = 21
tmin = 0.0
tmax = 5.0
zmin = 20.0
zmax = 50.0
dt = (tmax-tmin)/(nt-1)
dz = (zmax-zmin)/(nz-1)

u = NArray.sfloat(nt, nz)

zj = NArray.sfloat(nz).indgen! * dz
uz = exp(-0.2*zj)*(zj**0.5)
tz = -2.0*exp(-0.1*zj)
for i in 0..nt-1

u[i,true] = uz*sin(3.0*(tz+i*dt))

end

iws = (ARGV[0] || (puts ' WORKSTATION ID (I)  ? ;'; DCL::sgpwsn; gets)).to_i
DCL::gropn iws
DCL::grfrm

DCL::grswnd(tmin, tmax, zmin, zmax)
DCL::uspfit
DCL::grstrf

DCL::ussttl('TIME', 'YEAR', 'HEIGHT', 'km')
DCL::usdaxs

DCL::udcntr(u)

DCL::grcls
</textarea>

<table width="80%">
<tbody><tr><td class="results">
<img src="Dennou-Ruby%20Tutorial_files/contour.png" width="456" height="341"><br><br>
</td></tr></tbody></table>

<h3>演習問題</h3>


<h2><a name="label:9" id="label:9">Ruby-NetCDFでデータの読み書き
</a></h2><!-- RDLabel: "Ruby-NetCDFでデータの読み書き
" -->
<h3><a name="label:10" id="label:10">NetCDFデータを読んで図を描く
</a></h3><!-- RDLabel: "NetCDFデータを読んで図を描く
" -->
<!--<p>model.ncはおかしいので使わないか、つくりなおす。</p>-->

<textarea cols="72" rows="10" class="source ">require "numru/netcdf"
require "numru/dcl"

include NumRu


def write_file

  require "date"

  ary2d = NArray.sfloat(10,20).indgen!
  ary = NArray.sfloat(3,1).indgen!

  file = NetCDF.create("hogehoge.nc")

  xdim = file.def_dim("x",10)
  ydim = file.def_dim("y",20)
  var = file.def_var("var1","sfloat",[xdim,ydim])
  file.put_att("history","created by #{$0}  #{Date.today}")

  file.enddef

  var.put( ary2d )
  var.put( ary, "start"=&gt;[5,5], "end"=&gt;[7,5] )

  var.put( 9.0, "index"=&gt;[3,3] )    # "index" specifies a scalar

  file.close
end

def read_file

  file = NetCDF.open("model.nc")

  vz = file.var("z")
  z = vz.get

  file.close

  p z

  DCL.glrset('rmiss',1.0e+20)
  DCL.gllset('lmiss',true)

  DCL.gropn(1)
  DCL.grfrm

  DCL.grsvpt(0.1,0.9,0.3,0.8)

  DCL.grswnd(-180.0,180.0,-90.0,90.0)
  DCL.grstrf
  DCL.usdaxs
  DCL.udcntz(z[true,true,3,0])
  DCL.umpmap('coast_world')
  DCL.grcls

end




read_file
</textarea>


<table width="80%">
<tbody><tr><td class="results">
<img src="Dennou-Ruby%20Tutorial_files/contour.png" width="456" height="341"><br><br>
</td></tr></tbody></table>


<h3><a name="label:11" id="label:11">データを処理してNetCDFで書き出す
</a></h3><!-- RDLabel: "データを処理してNetCDFで書き出す
" -->
<!--<p>平均でもとる？u**2 + v**2 とか</p>-->

<textarea cols="72" rows="10" class="source ">
</textarea>


<table width="80%">
<tbody><tr><td class="results">
<img src="Dennou-Ruby%20Tutorial_files/contour.png" width="456" height="341"><br><br>
</td></tr></tbody></table>


<h3>演習問題</h3>

<h2><a name="label:12" id="label:12">データ解析・数値計算
</a></h2><!-- RDLabel: "データ解析・数値計算
" -->
<h3><a name="label:13" id="label:13">データ解析はGphysで。
</a></h3><!-- RDLabel: "データ解析はGphysで。
" -->
<h3><a name="label:14" id="label:14">Kdv方程式でソリトン
</a></h3><!-- RDLabel: "Kdv方程式でソリトン
" -->
<p>kdv2.rb
</p>

<textarea cols="72" rows="10" class="source ">require 'narray'
require "numru/dcl"

include NumRu::DCL
include NMath

jmax = 100
xmin = 0.0
xmax = PI
nmax = 50000

Dx = (xmax-xmin)/jmax
Dt = 0.0002
Nu = 0.005

def cshift(x,n) # Fortran90のcshiftの代用品
#  if(n &gt; x.size) ...
  y = x.dup
  y[n..-1] = x[0..-1-n]
  y[0..n-1] = x[-n..-1]
  return y
end

def vel(y) # KdV方程式
  u = - y*( cshift(y,1)-cshift(y,-1) )/(2*Dx) \
      - Nu*( cshift(y,2)-2*cshift(y,1)+2*cshift(y,-1)-cshift(y,-2) )/(2*Dx**3)
end

def rungekutta(y) # Runge-Kuttaによる積分
  u1 = vel(y)
  u2 = vel(y+u1*Dt/2)
  u3 = vel(y+u2*Dt/2)
  u4 = vel(y+u3*Dt)
  y_next = y + (u1+u2*2+u3*2+u4)/6 * Dt
end


# x座標の設定
x = NArray.sfloat(jmax+1).indgen!*Dx + xmin

# 初期波形の設定
y1 = 4.0
d1 = sqrt(12.0*Nu/y1)
y2 = 1.0
d2 = sqrt(12.0*Nu/y2)
y = y1/( cosh( (x-PI/2)/d1 ) )**2 + y2/( cosh( (x-PI/4)/d2 ) )**2

swlset('lalt',true)
swlset('lwait',false)
gropn(1)

for n in 0..nmax
  y[1..jmax] = rungekutta( y[1..jmax] )
  y[0] = y[jmax]
  if n%50==0 then
    grfrm
    grswnd(xmin,xmax,0.0,5.0)
    usgrph(x,y)
  end
end

grcls
</textarea>

<table width="80%">
<tbody><tr><td class="results">
<img src="Dennou-Ruby%20Tutorial_files/kdv.png" width="456" height="341"><br><br>
</td></tr></tbody></table>


<h3><a name="label:15" id="label:15">ベナール対流でchaotic mixing</a></h3>

<p>Benard2.rb
</p>

<textarea cols="72" rows="10" class="source ">require 'narray'
require "numru/dcl"

include NumRu::DCL
include NMath

n = 100
x = NArray.float(n).random!(0.1) + 0.02
y = NArray.float(n).random!(0.02) + 0.9
#    NArray.float(size,...)   double precision float
#    self.random!(max)   0&lt;=x&lt;max の一様なランダム値を生成。

def uv(x,y,t)
  a = 1.0
  k = 2.0
  e = 0.2
  omega = PI*2
  u =  a*cos(PI*y)*sin(k*x) - e*cos(PI*y)*cos(k*x)*cos(omega*t)
  v = -a*sin(PI*y)*cos(k*x) + e*sin(PI*y)*sin(k*x)*cos(omega*t)
  return u,v
end

def advect(x,y,t,dt)
  u1,v1 = uv(x, y, t)
  u2,v2 = uv(x+u1*dt/2.0, y+v1*dt/2.0, t+dt/2.0)
  u3,v3 = uv(x+u2*dt/2.0, y+v2*dt/2.0, t+dt/2.0)
  u4,v4 = uv(x+u3*dt, y+v3*dt, t+dt)

  x = x + (u1+u2*2+u3*2+u4)/6 * dt
  y = y + (v1+v2*2+v3*2+v4)/6 * dt
  t = t + dt

  return x,y,t
end

swiset('iwidth',512)
swiset('iheight',512)
swlset('lwait',false)
swlset('lalt',true)
gropn(1)

t = 0.0
dt = 0.05
for i in 1..1000
  x,y,t = advect(x,y,t,dt)

  x[ x &lt; 0.0 ] = x[ x &lt; 0.0 ] + PI  # Cyclic
  x[ x &gt; PI ]  = x[ x &gt; PI ]  - PI

  grfrm
  grswnd( 0.0, PI, 0.0, 1.0 )
  grsvpt( 0.1, 0.9, 0.2, 0.7 )
  grstrf
  usdaxs

  sgspmi(22)
  sgpmu( x, y )
end

grcls
</textarea>



<table width="80%">
<tbody><tr><td class="results">
<img src="Dennou-Ruby%20Tutorial_files/Benard.png" width="393" height="407"><br><br>
</td></tr></tbody></table>



<h3>演習問題</h3>

<h2><a name="label:16" id="label:16">クラスを使う</a></h2>

</body></html>