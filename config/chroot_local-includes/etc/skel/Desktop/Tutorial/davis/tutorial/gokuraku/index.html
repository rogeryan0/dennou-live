<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-type" content="text/html; charset=euc-jp">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" href="dennou-ruby.css" type="text/css">
<title>Dennou-Ruby Tutorial</title>
</head>
<body>



<a href="../../../../">地球流体電脳倶楽部</a> / 
<a href="../../index-j.htm">電脳Ruby</a> / 
<a href="../">チュートリアル</a> / 
基礎編

<hr>

<h1>Dennou-Rubyチュートリアルページ(基礎編)</h1>


<p>
ここでは、まずRubyのスクリプト言語としての基本的な使い方を紹介します。
そのあと数値計算・配列演算に必要なパッケージの紹介、
地球科学のデータを読み書きしたり可視化したりする方法の紹介へと
続きます。最後のほうでは流体数値計算もやっています。

</p>

<p>
<a href="#h2-1">1. Rubyの基本的な使い方</a><br>
<a href="#h2-2">2. NArrayを使って配列演算</a><br>
<a href="#h2-3">3. ファイルの読み書き</a><br>
<a href="#h2-4">4. Ruby-DCLで絵を描く</a><br>
<a href="#h2-5">5. Ruby-NetCDFでデータの読み書き</a><br>
<a href="#h2-6">6. 流体数値計算も</a><br>
</p>


<a name="h2-1"></a>
<h2>1. Rubyの基本的な使い方</h2>

<h3>まずは動かしてみる</h3>

<p>
RubyはPerlやシェルスクリプトと同じようなスクリプト言語です。
スクリプトを記述したファイルをつくりRubyを呼ぶと、中身が実行されます。
まずエディタ (あるいはメモ帳) で中身が
</p><pre class="source">
 print("Hello, World\n")
</pre><p>
と書かれたファイルをつくり、test1.rb という名前で保存します。
そして
</p><pre class="source">
 % <span class="command">ruby test1.rb</span>
</pre><p>
とコマンドを実行すると(%はプロンプト、青太字が実際に入力する文字です)、
</p><pre class="source">
 Hello, World
</pre><p>
と表示されます。
Windows版をインストールした場合は「電脳rubyコマンドプロンプト」で
コマンドを実行します。

スクリプトは「""でくくられた部分(=文字列)を表示せよ」というものですね。
「\n」は改行を表します。
</p>

<p>
日本語も使えます。また
先頭に #! /usr/bin/env ruby と書いておき、chmod +x で実行可能にしておけば、
 % ./〜.rb ですみます。以下のような test2.rb を作成して、
</p><pre class="source">
 #! /usr/bin/env ruby
 print("こんにちわ、世界\n")  # ここはコメント
</pre><p>
これを実行してみましょう。
</p><pre class="source">
 % <span class="command">chmod +x test2.rb</span>
 % <span class="command">./test2.rb</span>
 こんにちわ、世界
</pre><p>
#から行末まではコメントで、実行時には無視されます。
</p>
<p>
エディタでファイルを編集しなくても、インラインで実行することも可能です。
-e オプションを使います。
</p><pre class="source">
 % <span class="command">ruby -e 'print("Hello, World\n")'</span>
 Hello, World
</pre><p>
また、irbという対話型のrubyも用意されています。
irb(main):001:0> などというプロンプトが現れるので、
そこにスクリプトを記述すると即座に結果が表示されます。
</p><pre class="source">
 % <span class="command">irb</span>
 irb(main):001:0&gt; <span class="command">print("Hello, World\n")</span>
 Hello, World                              ←標準出力
 => nil                                    ←irbでは戻り値も表示
</pre><p>
2行目は'print("Hello, World\n")'というコマンドの実行に対する戻り値を表しています。
さしあたっては気にしなくていいでしょう。
irbを終了するには exit です。
</p><pre class="source">
 irb(main):002:0&gt; <span class="command">exit</span>
 % 
</pre><p>

</p><div class="note"><p>
emacs 上の実行環境として irbsh というものもあります
(別途インストールが必要、<a href=http://www.rubyist.net/~rubikitch/computer/irbsh/>http://www.rubyist.net/~rubikitch/computer/irbsh/</a> あたりを参照のこと)。
</p>
<!--
<pre class="source">
irbsh[16:19](main):001:0&gt; print("Hello, World\n") 行頭から始めると irb
Hello, World                              ←標準出力
nil                                       ←irbsh でも戻り値を表示
[pwd:~]
irbsh[16:19](main):002:0&gt;
irbsh[16:20](*SHELL*):003:0&gt;  ls       ←行頭に空白を入れると SHELL
~ $ ls
Choices  Desktop  Mail	      bin     doc      lib	    rpm  tmp
DATA	 GNUstep  Xrootenv.0  dennou  install  public_html  src  work
</pre><p>

</p>
-->
</div><p>

以下では irb を使ってrubyの基本的な使い方を見ていくことにします。
</p>

<h3>型宣言は不要</h3>


<p>
Rubyには型宣言は不要です。
</p><pre class="source">
 % <span class="command">irb</span>
 irb(main):001:0&gt; <span class="command">a = 2</span>       # 整数
 => 2
 irb(main):002:0&gt; <span class="command">b = 3.5</span>     # 実数
 => 3.5
 irb(main):003:0&gt; <span class="command">c = "apple"</span> # 文字列
 => "apple"
</pre><p>

"="の両側の空白は入れても入れなくてもかまいません。
これらは、a, b, c という変数に 2 という整数、3.5という実数、
"apple" という文字列を代入したと考えることもできますが、
実際には 2 という整数オブジェクト、 3.5という実数オブジェクト、
"apple" という文字列オブジェクトに
a, b, c という名札をつけたということに相当しています。

</p><p>
オブジェクトはその値だけでなく型や大きさなど諸々の情報も自分で持っています。

</p><pre class="source">
 irb(main):004:0&gt; <span class="command">a</span>          # オブジェクトの値
 => 2
 irb(main):005:0&gt; <span class="command">b.class</span>    # オブジェクトの型
 => Float
 irb(main):006:0&gt; <span class="command">c.size</span>     # オブジェクトの大きさ
 => 5
 irb(main):007:0&gt; <span class="command">3.5.class</span>  # b.class と同じ
 => Float
</pre><p>

上の class や size はメソッドと呼ばれます。
オブジェクトに対して「型を述べよ」「大きさを答えよ」などとメッセージを送っていることになります。オブジェクトはそれに対して「実数だ」「5だ」などと答えてくれます。
</p>

<h3>演算</h3>

<p>
演算も当然できます。いろいろやってみてください。
</p><pre class="source">
 irb(main):008:0&gt; <span class="command">d = a * ( b**2 + 3.0e2 )</span>
 => 624.5
 irb(main):009:0&gt; <span class="command">e = c + "orange"</span>
 => "appleorange"             # 文字列の足し算は単に順に並べるだけ。
</pre><p>

</p><div class="note"><p>
ちなみに複数の変数をいっぺんに操作することもできます。
</p><pre class="source">
 irb(main):010:0&gt; <span class="command">e,f = a*b, e+"lemon"</span>
 => [7.0, "appleorangelemon"]
</pre><p>

大文字ではじめると定数になります。
定数を書きかえようとすると警告が出ます。
</p><pre class="source">
 irb(main):011:0&gt; <span class="command">A = 3.1415927</span>
 => 3.1415927
 irb(main):012:0&gt; <span class="command">A = 1.7320508</span>
 (irb):22: warning: already initialized constant A
 => 1.7320508
</pre><p>

'〜'でくくった部分も文字列になりますが、こちらは制御文字もそのまま
文字として扱います。
</p><pre class="source">
 irb(main):013:0&gt; <span class="command">print 'apple\n'</span>
 apple\n=> nil                      # 改行されずに\nが表示される
</pre></div>

<h3>型変換</h3>


<p>
型変換は to_s, to_i, to_f といったメソッドを使います。

</p><pre class="source">
irb(main):101:0> <span class="command">g = b.to_s</span>
     => "3.5"                       # to_s 文字列に変換
irb(main):102:0> <span class="command">h = b.to_i</span>
     => 3                           # to_i 整数に変換
irb(main):103:0> <span class="command">a.to_f/3 - a/3</span>
     => 0.666666666666667           # to_f 実数に変換
</pre>
整数を整数で割っても整数しか返さないので、どちらかを実数に変換しておく必要が
あります。

<h3>配列</h3>

<p>

オブジェクトを順番に並べて [ ] でくくったものが配列です。
配列の中は同じ型である必要はありません。
</p><pre class="source">
irb(main):113:0> <span class="command">ary1 = [ 3, b, d-3.0, "orange"]</span>
     => [3, 3.5, 621.5, "orange"]
irb(main):114:0> <span class="command">ary1[0]</span>
     => 3                           # Cと同じで最初の要素が0番
irb(main):115:0> <span class="command">ary1[1..3]</span>
     => [3.5, 621.5, "orange"]      # 1番から3番まで
irb(main):116:0> <span class="command">ary1[-1]</span>
     => "orange"                    # 負の数はうしろから数える
irb(main):117:0> <span class="command">ary2 = [a, ary1]</span>
     => [2, [3, 3.5, 621.5, "orange"]]   # 配列の中に配列があっても大丈夫。
irb(main):118:0> <span class="command">ary2[1][3]</span>
     => "orange"                    # ary2[1]の3番の要素
</pre>

<h3>流れの制御</h3>

<p>
プログラムの流れの制御には、for, while (繰り返し), if, case (条件分岐)などが使えます。
もちろんirbの中でも使えます。
</p><pre class="source">
irb(main):121:0> <span class="command">for i in 1..5</span>
irb(main):122:1>  <span class="command">print(i,"\n")</span>
irb(main):123:1> <span class="command">end</span>
</pre><p>

いずれも終わりを表すのは end です。
プロンプトの">"の左の数字はネストの深さを表していて、
ネストがなくなる3行目まではなにもおこなわれません。

</p><pre class="source">
irb(main):131:0> <span class="command">if( a==3 ) then</span>    # thenはなくてもよい
irb(main):132:1*  <span class="command">print "Hello\n"</span>   # 曖昧でない場合は括弧を省略可能
irb(main):133:1> <span class="command">else</span>
irb(main):134:1*  <span class="command">print a,"\n" if a != 4</span>   # if文は後付けも可能
irb(main):135:1> <span class="command">end</span>
</pre><p>

配列の各要素に対して順に処理をおこなうイテレータというものもあります。
</p><pre class="source">
["dog","cat","bird"].each {|i|
 printf("a %s\n", i)
}
</pre><p>
each は {...} (または do ... end) を引数にとるメソッドです。
配列の各要素を | | の中の変数(ここでは i )に格納し、
その i に対する操作を記述します。つまり
</p><pre class="source">
for i in ["dog","cat","bird"]
 printf("a %s\n", i)
end
</pre><p>
と同じです。これだけだとあまりありがたみが感じられないかもしれませんが、
イテレータにはいろいろなものがあり、
より直接的にループを記述することができます。
for を使うより便利なことが多いです。
</p><pre class="source">
(1..10).each &#123;|i|
  printf( "%02d\n", i )
&#125;

10.times do                      # 10回繰り返し
 print "hoge"
end

loop do                          # 無限ループ
 break if STDIN.gets=="\n"       # 空行を入力すればループを抜ける
end

loop do
 break if /^$/ =~ gets           # 上と同じ(/.../は正規表現、=~は正規表現とマッチしているかどうか、getsはSTDIN.gets
end

</pre><p>

</p><div class="note"><p>
注：イテレータ(ブロック)は、変数のスコープ(有効範囲)を作ります。次のよ
うなスクリプトはエラーになります。
</p><pre class="source">
(1..10).each &#123;|i|
  b = i
&#125;

b   # {…}の外では b が存在しないのでエラーになる
</pre><p>
エラーを避けるには
</p><pre class="source">
b = 0
(1..10).each &#123;|i|
  b = i
&#125;
b   # 10
</pre><p>
のようにします。
</p></div>


<h3>手続き定義</h3>

<p>def を使ってメソッドを定義することにより、他の言語と同じような形で
手続きを定義できます。
</p><pre class="source">
def wa(a,b,c)
 d = a+b+c
 return d        # 戻り値の指定。なければ最後の文の戻り値が返される。
end
e = wa(3,4,6)    # 定義前に実行することはできない。
</pre>


<h3>メソッド・クラス・モジュール</h3>

<p>
すべてのオブジェクトはなんらかのクラスに属しています。<br>
クラスとはオブジェクトの種類を表すもので、
クラス毎にオブジェクトに対する手続き(メソッド)が定義されています。
例えば「3.5」はFloatというクラスのオブジェクトであり、
Floatクラスでは +, -, *, / (四則演算)や abs, floor, to_i, to_s 
といったメソッドが定義されています。
また、モジュールとはメソッドや定数などの機能をまとめた集まりで、
必要に応じてインクルードして使います。
</p>

<h3>数学関数 (モジュールの例)</h3>

<p>
数学関数は、Mathモジュールを使います。
Mathモジュールの中に、三角関数などのメソッドや円周率などの定数が定義されています。
</p><pre class="source">
a = Math::cos(0) # Mathというモジュールのcosという関数を呼ぶ
p = Math::PI
</pre><p>
include文を使うと、それ以降は"Math::"の部分が不要になります。
</p><pre class="source">
include Math
a = cos(PI)
</pre>



<h3>日付と時刻 (クラスの例)</h3>

<p>
日付や時刻を扱うには、DateTimeクラスを使うと便利です。
DateTimeクラスの定義は起動時に読み込まれていないので、まず
</p><pre class="source">
require "date"
</pre><p>
とします。これで定義が読み込まれます。
DateTimeクラスのオブジェクトを作るには
</p><pre class="source">
sakki = DateTime.new(2010,3,8,9,30)   # 2010年3月8日9時30分
</pre><p>
とします。およそどのクラスでも一般に new というのが新しいオブジェクトを作る
メソッドです。他に
</p><pre class="source">
ima = DateTime.now                    # 現在
itsuka = DateTime.parse("2003-04-05") # 文字列を解釈して作成
</pre><p>
といったやり方もあります。

DateTimeクラスには足し算引き算他さまざまなメソッドが定義されています。
</p><pre class="source">
sakki.year        # => 2010
(sakki + 40).day  # => 17                     # 40日後は何日か。
sakki - itsuka    # => Rational(121411, 48)   # 差の日数(Rationalは分数、121411/48日。)
(sakki >> 1).to_s # => "2010-04-08T09:30:00Z" # 1ヶ月後を文字列にする
sakki.strftime("%H:%M (%y/%m/%d)")
                  # => "09:30 (10/03/08)"     # 好きなフォーマットの文字列にする
</pre>


<h3>拡張</h3>

<p>
ここから先では、NArrayクラス、DCLモジュール、NetCDFクラスといったものを
用いて機能を拡張していきます。
自分でクラスを作る方法はそのあとに紹介します。
</p>



<a name="h2-2"></a>
<h2>2. NArrayを使って配列演算</h2>

<p>Rubyに標準装備されている配列(Array)は、
オブジェクトを順番に並べたものであり、これもまた1つのオブジェクトです。
上の例にあったように、配列の要素は同じ型である必要はなく
任意のオブジェクトを格納できるという柔軟なものなので、
その分計算速度は犠牲になっています。
そこでわれわれが数値計算をするときには
NArray というクラスパッケージを用いることにします。
</p>
<p>NArrayのメソッドについては <a href="http://www.ir.isas.ac.jp/%7Emasa/ruby/na/SPEC.ja">NArray メソッド一覧</a> に書いてありますので適宜参照してください。
</p>

<h3>つくりかた</h3>

<p>NArrayクラスを用いるには、まず
</p><pre class="source">
require "narray"
</pre><p>
とします。これでNArrayクラスの定義が読み込まれます。
新たに配列を生成する(つまりNArrayクラスのオブジェクトを新たに生成する)には、
NArray.new("型",大きさ,大きさ,...) とします。
が通常はそれより簡単な NArray.型(大きさ,大きさ,...) 
を用います。たとえば3x4の単精度実数配列 ary1 を作るには
</p><pre class="source">
ary1 = NArray.sfloat(3,4)
</pre><p>
です。これだけでは中身の値はすべて0です。
次にこの配列オブジェクトに中身をセットするメソッドを作用させます。
</p><pre class="source">
ary2 = NArray.sfloat(6).fill(3.0)   # 長さ6の配列で、中身はすべて3.0
ary3 = NArray.sfloat(10).indgen     # 1ずつ増やした値をセット。
</pre><p>
また、通常の配列(Array)とNArrayの間で型変換するには
</p><pre class="source">
ary4 = [ 2, 3, 4.5, 8 ]             # 通常の配列
ary5 = NArray.to_na(ary4)           # ary4 を NArray に変換
ary6 = ary5.to_a                    # ary5 を Array に変換
</pre><p>
とします。NArrayでは、例えば中に1つでも実数が含まれていれば実数の配列となり、
要素はすべて実数になります。
</p>

<h3>要素番号</h3>

<p>
インデックスはArrayやC言語と同じで、
最初の要素番号は0、最後の要素番号は要素数-1です。
多次元のインデックスの順序はFortranと同じで、前の要素から数字を増やします。

</p><pre class="source">
ary6 = NArray.sfloat(4,3).indgen!(1.0,2.0) # 1から2ずつ増やした値をセット。
ary6[0,0]        # 最初の要素
ary6[1,0]        # 次の要素
ary6[1..2,0..-1] # 範囲取り出し
ary6[true,1]     # trueは0..-1と同じ
ary6[0..1,0] = 999 # 値の代入
ary6
</pre><p>

</p>

<h3>演算</h3>

<p>
演算は要素ごとにやってくれます。

</p><pre class="source">
ary7 = NArray.sfloat(4,3).fill!(3.0)
ary6 + ary7
ary6 * ary7
ary6 % ary7
ary7 - 1.5
ary6 ** 2
</pre><p>

</p>

<h3>演習問題</h3>

<p>
笑介くんのクラス20人のテストの点数は、
理科が<br>
65 80 67 35 58 60 72 75 68 92 36 50 2 58.5 46 42 78 62 84 70<br>
英語が<br>
44 87 100 63 52 60 58 73 55 86 29 56 89 23 65 84 64 27 86 84<br>
でした。
平均点、標準偏差、偏差値を教科別、および合計について求め、
点数の高い順に並べかえなさい。
</p>


<a name="h2-3"></a>
<h2>3. ファイルの読み書き</h2>


<h3>テキストデータの書き出し</h3>

<p>
ファイルの入出力には File クラスを用います。
</p><pre class="source">
file1 = File.open("test.txt","w")    # "w"を付けると書き込み可能で開く。
file1.print("Hello, World\n")
for i in 1..10
  file1.printf( "%02d %02d\n", i, i*2 )
end
file1.puts("Hello, Hello, World")    # 改行付きで出力される
file1.close
</pre><p>
file1がファイル"test.txt"に対応するFileクラスのオブジェクトになります。
これに print printf puts などのメソッドを作用させるとファイルに書き出されます。
puts は引数を1行分として書き出すので最後に必ず改行が入るようになっています。
print や printf では改行も自分で制御します。
実際に書き出されているか確かめてみましょう。
</p>

<h3>テキストデータの読み込み</h3>

<p>
読み出すには gets getc read などのメソッドがあります。
</p><pre class="source">
file2 = File.open("test.txt","r")    # "r"を付けるとread onlyで開く。
a = file2.gets                       # 1行(つまり"\n"まで)読み込む
for i in 1..10
  print file2.gets
end
file2.rewind                         # ファイル先頭に戻る
file2.read(20)                       # 指定したバイト数読み込む
file2.close
</pre>


<div class="note"><p>
NArrayの配列をバイナリデータとして読み書きすることもできます。
</p><pre class="source">
ary1 = NArray.sfloat(10,3).indgen!(1.0,2.0)
file3 = File.open("test.dat","wb")   # "b"はバイナリモード
file3.print(ary1.to_s)               # 「文字列」に変換してから書き出す
file3.close

file4 = File.open("test.dat","rb")
data = file4.read(4*10*3)            # 4バイトx配列の大きさ
ary2 = NArray.to_na(data, "sfloat", 10, 3)  # 読んだデータをNArrayに変換
</pre>
<p>
このやり方だとFortranの4バイトダイレクトアクセスと同じ形式の
ファイルになるので、バイナリファイルを通したデータのやりとりも可能です。
</p>
</div>




<a name="h2-4"></a>
<h2>4. Ruby-DCLで図を描く</h2>

<p>
この節はDCL(Fortran版)を使ったことがあることを前提にしています。
使ったことがない場合は、
可視化に関してはGPhysを使った可視化(GGraph、またはGAVE)から習得したほうが
理解しやすいかもしれません。
GPhysはNetCDF,GrADS,grib等のデータ形式で扱われる格子点データを
取り扱うクラスで、ここまでの知識があれば
<a href="../../products/gphys/tutorial/">GPhys チュートリアル</a>
に進んでいけば、そのような形式のデータの解析や可視化をおこなうことができます。
ただしGGraphもGAVEも内部でRuby-DCLを使っていて、
細かな設定をしようと思うと依然Ruby-DCLの知識が必要になります。
Ruby-DCLについて一から習得するには、
<a href="../../products/ruby-dcl/ruby-dcl-doc/gokuraku/index.htm">ごくらくDCL</a>を読んで下さい。
</p>

<p>まずはRuby-DCLを使って図を描いてみましょう。
</p><pre class="source">
require "numru/dcl"
</pre><p>
を加えると、以降DCLモジュールを使うことができます。
DCLのサブルーチンを
</p><pre class="source">
NumRu::DCL::gropn(1)
</pre><p>
などのように書いてやれば
Fortran版のDCLと同じように動作します。
ただしこれでは長いので通常はNumRuはincludeしておきます。
</p><pre class="source">
require "numru/dcl"
include NumRu
DCL::gropn(1)                        # ウィンドウをオープン
DCL::grfrm                           # ウィンドウ内に(正方形の)描画領域を設定
DCL::sgtxr(0.6,0.3,"abc")            # 描画領域の[60%,30%]のところに文字列を描く

a = NArray.sfloat(30).indgen
b = a * 13 % 5
DCL::usgrph(a,b)                     # x座標がa、y座標がbの折れ線を描く

DCL::grcls                           # マウスクリック後ウィンドウをクローズ
</pre><p>
なお DCL.gropn(1) といった書き方も可能です。
以降はスクリプトを書いてrubyコマンドを使うことにします。
配列には単精度実数(sfloat)のNArrayを与えます。
</p>

<p>Fortran77版のDCLと比べると、
配列の長さを渡す引数は与える必要がなくなっています。
(例: CALL USGRPH(N,X,Y)  -&gt; DCL::usgrph(x,y) )
</p><pre class="source">
include DCL
</pre><p>
と書いておけば、以降 DCL:: の部分も省略することもできます。
</p>





<h3>等高線・ぬりわけ図</h3>

<p>
RubyとRuby-DCLの機能をいろいろ使用して図を作る例です。
</p>


<p>例: <a href="contour.rb">contour.rb</a></p>

<textarea cols="80" rows="20" wrap="hard" class="source ">
require "numru/dcl"

include NumRu
include NMath                        # NArrayのMathモジュール

nt = 50
nz = 50
tmin, tmax = 0.0, 5.0
zmin, zmax = 20.0,50.0

t = NArray.sfloat(nt+1,   1).indgen! * (tmax-tmin)/nt # 横軸 (nt+1,1)配列
z = NArray.sfloat(   1,nz+1).indgen! * (zmax-zmin)/nz # 縦軸 (1,nz+1)配列

uz = exp(-0.2*z)*(z**0.5)
tz = -2.0*exp(-0.1*z)
u = uz*sin(3.0*(tz+t))               # (nt+1,nz+1)の配列になる。

p "umin,umax="
p u.min, u.max

=begin
コマンドラインオプションに-psが含まれていればPSファイルを作る(gropn(2))、
なければウィンドウを開く(gropn(1))
=end
if ARGV.index("-ps")
  DCL::gropn(2)     
else
  DCL::gropn(1)     
end

DCL::grfrm
DCL::grswnd(tmin, tmax, zmin, zmax)         # 左・右・下・上の座標値
DCL::uspfit                                 # あとはおまかせ
DCL::grstrf                                 # 座標の確定

DCL::sglset('lfprop',true)                  # プロポーショナルフォント
DCL::ussttl('TIME', 'YEAR', 'HEIGHT', 'km') # タイトルの設定
if ARGV.index("-color")
  DCL::uelset("ltone",true)                 # 色つき
  DCL::uetone(u)                            # ぬりわけ
end
DCL::usdaxs                                 # 座標軸を描く
DCL::udcntr(u)                              # 等値線をひく

DCL::sgstxs(0.02)                           # 文字の大きさの設定
DCL::sgtxr(0.7,0.9, "umin="+u.min.to_s+" umax="+u.max.to_s)
                                            # to_s 文字列に変換
require "date"                              # requireは途中にあっても可
DCL::sgtxr(0.75,0.85, "created by #{$0} #{DateTime.now}")

DCL::grcls

</textarea>

<p>
上のファイルをダウンロードして、

</p><pre class="source">
 % <span class="command">ruby contour.rb</span>
</pre><p>
とすると図が描画されます。
</p>

<p>
スクリプトの途中で変数にどのような値が入っているかを知るには、
p というコマンド(オブジェクトの内容を人間に読みやすい形で出力)を利用します。
スクリプトのいろいろな場所に挿入して書き出してみて下さい。
</p>

<p>
"#"以降の他、
行頭の"=begin"から"=end"までの部分もコメントになります。
"ARGV.index"のところでは、コマンドラインオプションを調べています。
ARGVはコマンドラインオプションの配列です。
</p><pre class="source">
 % ruby contour.rb -color
</pre><p>
とすれば、下のような色つきの図ができます。
また、スクリプトの最後の方では数値をto_sで文字列に変換して画面に出力しています。
"" の中で #{...} を使うと、その中の結果を文字列に変換したものになります。
</p>

<p class="results">
<img src="contour.png" width="456" height="341">
</p>



<h3>テキストデータを読んで図を描く</h3>


<p>
RubyはPerlを意識したスクリプト言語であることもあって、
文字列操作の機能は強力です。
それを利用して、テキストファイルに書かれたデータの読み書きをしてみましょう。
</p>

<p>
テキスト処理についてはたくさんのメソッドが用意されており、
連結(+)・分割(split)・比較(&lt;=&gt;,&lt,&lt;=,&gt;,=&gt;,==)・置換(sub,gsub)・
一部取り出し([ ])・大文字小文字変換(upcase,downcase)
などなど充実していますので、
これらを用いればさまざまな処理が自在にできます。詳しくは
<a href="http://www.ruby-lang.org/ja/man/index.cgi?cmd=view;name=String;em=String">マニュアル</a>などを参照すればよいでしょう。


<p>
例として、NOAAにあるラジオゾンデアーカイブ
<a href="http://www.ncdc.noaa.gov/oa/cab/igra/">
http://www.ncdc.noaa.gov/oa/cab/igra/</a>
から地点を1つ選びラジオゾンデ観測データを取得します。
"ASCII Files" のリンクをたどっていくとテキストファイル(をzipで固めたもの)
が取得できます。
館野(=つくば)の最近のデータを一時的に
<a href="./47646.y2d">ここ</a>においておきます。
</p>

<p>
まずテキストファイルの中身を見てみると、
</p><pre class="source">
 % <span class="command">more 47646.y2d</span>
#4764620040101002330  67
21101100B   31    58B   59  250   10
10100000   123B   66B   90    0    0
20 98600 -9999    64B  100-9999-9999
30 95200 -9999 -9999 -9999  120   30
10 92500   759B   24B   80  210   20
30 91300 -9999 -9999 -9999  250   20
30 90000 -9999 -9999 -9999  260   51
30 87500 -9999 -9999 -9999  285  108
10 85000  1435B  -25B   80  280  118

  :

20   770 -9999  -437A-9999-9999-9999
#4764620040101069999  25
31101100B   31 -9999 -9999  140   15
30 93200 -9999 -9999 -9999  135   20

  :

</pre><p>
となっています。
<a href="http://www1.ncdc.noaa.gov/pub/data/igra/readme.txt">readme.txt</a>
を見ると、行頭に"#"が付いている行がヘッダー、
それ以外の行に風や温度などのデータが入っているようです。
そこで読み込んだ行がヘッダーなら日付を読んで改ページし、
データなら高度と温度をプロットするようにしてみます。
</p>

<p>例: <a href="rsread.rb">rsread.rb</a></p>

<textarea cols="80" rows="20" wrap="hard" class="source ">
require "numru/dcl"
include NumRu

file1 = File.open("./47646.y2d","r")

DCL::gropn(1)

while( line = file1.gets ) # ファイル末尾までループ

  # ヘッダーの場合

  if( line =~ /^#(\d{5})(\d{4})(\d{2})(\d{2})(\d{2})(\d{4})([\d ]{4})$/ )

    station, year, mon, day, hour, rtime, levels = $1, $2, $3, $4, $5, $6, $7

    DCL::grfrm
    DCL::grsvpt(0.1,0.9,0.1,0.9)
    DCL::grswnd(-70,30,0,35)
    DCL::grstrf
    DCL::usdaxs

    DCL::uxsttl("t","##{station} #{year}-#{mon}-#{day} #{hour}UTC",-1)
    DCL::uxsttl("b","Temperature [degC]",0)
    DCL::uysttl("l","Geopotential Height [km]",0)


  # データの場合

  elsif( line =~ /^(\d)(\d)([\d ]{6})([AB ])([\d -]{5})([AB ])([\d -]{5})([AB ])([\d -]{5})([\d -]{5})([\d -]{5})$/ )

    mjtype, mntype, pres, presf, gph, gphf, temp, tempf, dpd, winddir, wind = 
      $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11

    DCL::sgpmzu([temp.to_f/10.0], [gph.to_f/1000.0], 5, 3, 0.02)

  else
    raise "invalid line: #{line}"  # どちらでもなければエラーを吐いて終了
#    p line
  end

end

DCL::grcls

file1.close

</textarea>


<p>

正規表現については
<a href="http://www.ruby-lang.org/ja/20020314.html">こちら</a>や
<a href="http://www.ruby-lang.org/ja/man/?cmd=view;name=%C0%B5%B5%AC%C9%BD%B8%BD">こちら</a>を見てください。
最初はややこしそうで面食らいますが、
覚えたものからだんだんに使っていけばよいでしょう。
"\d"が数字、{5}は「5回繰り返し」です。
( )でくくった部分にマッチしたものが前から順番に $1 $2 ... に入るので、
直後の行でそれを変数に代入することができます。
</p>

<p class="results">
<img src="rsread.png" width="456" height="341">
</p>







<h3>演習問題</h3>

<p>
笑介くんのクラスのテスト結果について、点数の頻度分布をグラフにしなさい。
</p>
<p>
手持ちのDCLお絵かきFortranプログラムをRubyに書き直しなさい
(なければサンプルを書き直す)。
</p>


<a name="h2-5"></a>
<h2>5. Ruby-NetCDFでデータの読み書き</h2>

<p>
netcdfライブラリを用いると、NetCDFファイルを読み書きすることができます。
手始めにirbでNetCDFファイルを読んでみましょう。
サンプルのNetCDFファイルは
<a href="T.jan.nc">ここ</a>
にあります(1月平均の気温の分布)。
</p><pre class="source">
require "numru/netcdf"
include NumRu
file1 = NetCDF.open("T.jan.nc")        # NetCDFファイルオブジェクトをつくる
var_temp = file1.var("T")              # 変数をオープン
temp = var_temp.get                    # 変数の値を取り出す
p temp                                 # 中身を表示
p temp[0..4,10,true]                   # 配列の一部を表示
</pre><p>

file1は1つのNetCDFファイルに対応するオブジェクト、
var_temp は file の中の1つの変数に対応するオブジェクトです。
getメソッドを用いて、var_tempから値を取り出しています。
(file1, var_temp, temp はただの名前ですから好きな名前を使ってかまいません。)
最低限これだけの手順で読み込むことができます。
中身を表示させるとNArrayとして読み込まれていることがわかります。

</p>

<h3>NetCDFデータを読んで図を描く</h3>

<p>
上の手順でNArrayとして読み込まれたので、
これをRuby-DCLを使って描画することができます。
</p>

<p>例: <a href="ncread.rb">ncread.rb</a></p>

<textarea cols="80" rows="20" wrap="hard" class="source ">
require "numru/netcdf"
require "numru/dcl"
include NumRu

file1 = NetCDF.open("T.jan.nc")        # NetCDFファイルオブジェクト

var_temp = file1.var("T")              # 変数をオープン
temp = var_temp.get                    # 変数の値を取り出す

var_level = file1.var("level")
level = var_level.get

file1.close

p temp

DCL::gropn(1)

for k in 0..level.shape[0]-1           # 鉛直層数だけ繰り返し
  DCL::grfrm
  DCL::grstrn(10)                      # 正距円筒図法
  DCL::grswnd(0.0,360.0,-90.0,90.0)    # 描画する緯度経度の指定
#  DCL::grsvpt(0.2,0.8,0.25,0.7)        # ウィンドウ内の描画領域の指定
  DCL::umpfit                          # あとはおまかせ
  DCL::grstrf                          # 確定

  DCL::uelset("ltone",true)            # 色を付ける
  DCL::uetone(temp[true,-1..0,k])      # k層目の気温を描く
                                       # データは北から入っているので
                                       # -1..0 として順番をひっくり返す

  DCL::umpglb                          # 縁と緯度経度線をかく
  DCL::umpmap("coast_world")           # 地図を描く

  DCL::uxsttl("t","Temperature at #{level[k]}hPa",0.0)

end

DCL::grcls


</textarea>

<p>
この例では、平面図を下から1層ずつ描いています。

この例は簡単のため特定のNetCDFファイルの構造に依存した書き方に
なっていますが、必要な事柄をオブジェクトに問い合わせる形にしてゆけば、
別のファイルにも対応できるよう拡張していくことが比較的かんたんにできます。
NetCDFファイル(等)の1つの変数とそれに付随する変数名や軸情報をまとめて
1個のオブジェクトとして取り扱うのが
<a href="http://www.gfd-dennou.org/arch/ruby/products/gphys/">GPhys</a>です。


</p>


<p class="results">
<img src="ncread.png" width="456" height="341">
</p>


<h3>演習問題</h3>

<p>どの高度をとるかを実行時選べるようにする。</p>
<p>月平均の東西平均東西風について、緯度・高度断面を作る。</p>
<p>年月を変えられるようにし、ファイルがなければftpでとってくるようにする。</p>


<h3>NetCDFファイルを新たに作る</h3>

<p>
次はNetCDFファイルを作成してみます。
まず必要なことは次元の定義(def_dim)と変数の定義(def_var)です。
この後にenddefとするとNetCDFファイルの先頭部分が作成されます。
それからputメソッドを用いて値を書き込んでいきます。
変数の一部にだけ書き込みたい場合などには、
"start"や"end"といったオプショナルな引数をつけます(これは
「ハッシュ」を用いて実現されています)。
</p>

<p>例: <a href="nccreate.rb">nccreate.rb</a></p>

<textarea cols="80" rows="20" wrap="hard" class="source ">
require "numru/netcdf"
include NumRu

file = NetCDF.create("test.nc")      # 新規作成
nx, ny = 10, 5
file.def_dim("x",nx)                 # 次元の定義
file.def_dim("y",ny)
file.def_dim("t",0)                  # tはUNLIMITED
require "date"
file.put_att("history","created by #{$0}  #{Date.today}")
                                     # グローバル属性の設定
x = file.def_var("x","sfloat",["x"]) # 変数の定義
y = file.def_var("y","sfloat",["y"])
t = file.def_var("t","sfloat",["t"])
v1 = file.def_var("v1","sfloat",["x","y"])
v1.put_att("long_name","test 1")     # 属性の設定
v1.put_att("units","1")
v2 = file.def_var("v2","sfloat",["x","y","t"])
v2.put_att("long_name","test 2")
v2.put_att("units","1")
file.enddef                          # defineモード終わり


x.put( NArray.float(nx).indgen! )    # 値を入れる
y.put( NArray.float(ny).indgen! )

z = NArray.float(nx,ny).indgen!*0.1
v1.put(z)
v1.put( NArray.float(nx).fill!(20), "start"=>[0,2],"end"=>[-1,2])
                                     # startからendまで値を入れる
v2.put(z, "start"=>[0,0,0],"end"=>[-1,-1,0])
t.put( 0, "index"=>[0])              # indexの場所に値を入れる
v2.put(-z, "start"=>[0,0,1],"end"=>[-1,-1,1])
t.put( 1, "index"=>[1])

file.close
print `ncdump test.nc`               # できたファイルを見る

</textarea>


<h3>演習問題</h3>

<p>笑介くんのクラスのテスト結果をNetCDFにしなさい。</p>
<p></p>
<p>月平均の東西平均東西風を、NetCDFファイルにする。</p>


<!--<h2>クラスを作ってみる</h2>-->

<h3>NetCDFを読んでNetCDFで書き出す</h3>

<p>
上の演習問題のような、
NetCDFを読みこみ何らかの解析処理を施してNetCDFで書き出す、
といったことをおこなうために、
NetCDFクラスを自分用に拡張していきます。
まずはNetCDFファイルを読み込み、
それをそのままNetCDFファイルに書き出してみます。
</p>


<p>例: <a href="nccopy.rb">nccopy.rb</a></p>

<textarea cols="80" rows="20" wrap="hard" class="source ">
# /usr/bin/env ruby

require "numru/netcdf"
include NumRu

module NumRu
 class NetCDF
  def copy(outfilename)
    outfile = NetCDF.create(outfilename)

    self.each_dim{ |d|
    #  outfile.def_dim(d.name, d.length_ul0)
      outfile.def_dim(d.name, d.length)    # 次元の定義
    }

    vlist = []                             # 変数リスト
    self.each_var{ |v|
    #  vdims = v.dim_names.collect{ |nm| outfile.dim(nm) }
    #  vout = outfile.def_var(v.name, v.vartype, vdims ) 
                                           # 変数の定義
      vout = outfile.def_var(v.name, v.vartype, outfile.dims(v.dim_names) )
      v.each_att{ |a| a.copy(vout) }       # 属性のコピー
      vlist.push(vout)                     # 変数リストの最後に加える
    }
    
    self.each_att{ |a| a.copy(outfile) } # グローバル属性のコピー

    outfile.enddef

    self.each_var{ |v|
      vout = vlist.shift                   # 変数リストの先頭を取り出し
      vout.put(v.get)                      # 変数のコピー
      p vout.name
    }

    outfile.close
  end
 end 
end

file = NetCDF.open("T.jan.nc") # 入力ファイル
file.copy("nccopy.nc")                 # 出力ファイル
file.close

#print `diff T.jan.nc nccopy.nc`

</textarea>

<p>
each_dim, each_var, each_att といったイテレータを用いています。
イテレータに慣れていないとちょっとややこしいですが、
汎用性が高くなっています。
</p>


<h3>演習問題</h3>

<p>指定した変数を除いて全部コピーするというメソッドに変える。</p>
<p>これを利用して、月平均の東西平均東西風をNetCDFファイルにする。</p>



<h3>データ解析は応用編で。</h3>

<p>
このようなスクリプトをどんどん増やしていけば、
データ解析がかんたんにできるようになります。
欠損値を扱ったりgradsファイルを読み込んだりする
<a href="../rakuraku/">ちょっとすすんだ使い方編</a>や、
座標を持つ、格子状に離散化された物理量のクラス"GPhys"を扱ったりする
<a href="../../products/gphys/tutorial/">GPhys チュートリアル</a>
に進んでいけば、より高度な使い方ができるようになるでしょう。
</p>

<a name="h2-6"></a>
<h2>6. 流体数値計算も</h2>

<h3>Fortran(or C)ライクに数値計算</h3>

<p>
Fortranでやっていたような数値計算も、
Rubyでより簡単に書くことができます。
以下の例は、
ベナール対流でchaotic advectionが起こる様子を計算したものです。
ごく単純な周期変動をする流れ場で、流体が複雑な動きをします。
</p>

<p>例: <a href="benard.rb">benard.rb</a></p>

<textarea cols="80" rows="20" wrap="hard" class="source ">
#! /usr/bin/env ruby

require 'narray'
require "numru/dcl"

include NumRu
include NMath

n = 100
x = NArray.float(n).random!(0.1) + 0.02
y = NArray.float(n).random!(0.02) + 0.9
               # self.random!(max)  0≦x＜max の一様なランダム値を生成

def uv(x,y,t)  # (x,y,t)における速度を求める
  a = 1.0      # 定常波の振幅
  k = 2.0      # 擾乱の波数
  e = 0.2      # 擾乱の振幅
  omega = PI*2
  u =  a*cos(PI*y)*sin(k*x) - e*cos(PI*y)*cos(k*x)*cos(omega*t)
  v = -a*sin(PI*y)*cos(k*x) + e*sin(PI*y)*sin(k*x)*cos(omega*t)
  return u,v
end

def advect(x,y,t,dt) # Runge-Kutta
  u1,v1 = uv(x, y, t)
  u2,v2 = uv(x+u1*dt/2.0, y+v1*dt/2.0, t+dt/2.0)
  u3,v3 = uv(x+u2*dt/2.0, y+v2*dt/2.0, t+dt/2.0)
  u4,v4 = uv(x+u3*dt, y+v3*dt, t+dt)

  x = x + (u1+u2*2+u3*2+u4)/6 * dt
  y = y + (v1+v2*2+v3*2+v4)/6 * dt
  t = t + dt

  return x,y,t
end

DCL::swiset('iwidth',512)      # ウィンドウ枠の大きさ設定
DCL::swiset('iheight',512)
if ARGV.index("-anim") then    # アニメーションする場合の設定
  DCL::swlset('lwait',false)
  DCL::swlset('lalt',true)
end
DCL::gropn(1)

t = 0.0
dt = 0.05
for i in 1..1000
  x,y,t = advect(x,y,t,dt)

  x[ x < 0.0 ] = x[ x < 0.0 ] + PI       # Cyclicの処理
  x[ x > PI ]  = x[ x > PI ]  - PI

  if ( ARGV.index("-anim") || i%5 == 0 )
    DCL::grfrm
    DCL::grswnd( 0.0, PI, 0.0, 1.0 )
    DCL::grsvpt( 0.1, 0.9, 0.2, 0.7 )
    DCL::grstrf
    DCL::usdaxs

    DCL::sgspmi(22)                      # 点の色・太さの設定
    DCL::sgpmu( x, y )                   # 座標(x,y)に点を打つ
  end
end

DCL::grcls


</textarea>

<p class="results">
<img src="Benard.png" width="262" height="272">
</p>




<h3>クラスを作って数値計算</h3>

<p>
上の例はFortranで書かれたアルゴリズムをそのまま用いて
Rubyに書き直したものですが、
今度はクラスを作って似たようなことをしてみましょう。
次の例はソリトンの数値計算実験です。
クラスを新たにつくり、Fieldと名前を付けます。
initializeで座標系を定義し、初期値を設定、
空間微分の定義、KdV方程式、時間積分などのメソッドを作ります。
</p>

<p>例: <a href="kdv.rb">kdv.rb</a></p>

<textarea cols="80" rows="20" wrap="hard" class="source ">
#! /usr/bin/env ruby
#
# KdV 方程式を解く＋解の図示(アニメ)
#
# ●configuration 
#    方程式 ; ∂u/∂t + u ∂u / ∂ x + ν ∂^3 u / ∂ x^3  = 0 
#    領域   ; x = [0, π]  t = [0, TN] 
#    b.c.   ; periodic i.e. u(xmin,t) = u(xmax,t) 
#    i.c.   ; u(x,0) = cos x etc. 
# 
# ●差分
#    時間は RKG (4次) 
#    空間は中央 => 三階微分のところは一意
# 
# ●実験
#   ν, TN を固定し, 初期値をかえたとき, 解の時間発展を見る.
#   sin 型, ソリトン など. 
#
# ●推奨パラメータ
#   e.g. JMAX=100, nu=0.01, DT=1e-4  => 適宜調整する必要がある
# 
# 00/01/17 Taguchi 
#          赤堀さんソースをもとに改変
# 00/11/14 f90化
# 03/02/23 ruby化
#----------------------------------------------------------------------#
require 'narray'
require "numru/dcl"

include NumRu
include NMath

class NArray # NArrayクラスにメソッドを追加
  def cshift(n) # Fortran90のcshiftの代用品
    #if(n > x.size) ...
    y = self.dup
    y[n..-1] = self[0..-1-n]
    y[0..n-1] = self[-n..-1]
    return y
  end
end

class Field
  def initialize(x,u,nu)
    @x = x
    @u = u
    @nu = nu
    @dx = @x[1]-@x[0]
  end

  def d_dx(u) # 微分(中央差分)
    (u.cshift(1)-u.cshift(-1))/(2*@dx)
  end

  def d3_dx3(u) # 3階微分
    (u.cshift(2)-2*u.cshift(1)+2*u.cshift(-1)-u.cshift(-2))/(2*@dx**3)
  end

  def kdv(u) # KdV方程式
    -u * d_dx(u) - @nu * d3_dx3(u)
  end

  def integ(dt) # dtだけ時間積分(4次Runge-Kutta)
    du1 = kdv(@u)
    du2 = kdv(@u+du1*dt/2)
    du3 = kdv(@u+du2*dt/2)
    du4 = kdv(@u+du3*dt)
    @u = @u + (du1+du2*2+du3*2+du4)/6 * dt
  end

  def x
    return @x
  end

  def u
    return @u
  end
end


if ARGV.index("-anim") then
  DCL::swlset('lwait',false)
  DCL::swlset('lalt',true)
end

# 初期値の設定

jmax = 100
xmin = 0.0
xmax = PI
dt = 0.0002

dx = (xmax-xmin)/jmax
x = NArray.sfloat(jmax).indgen!*dx + xmin

nu = 0.005
u1 = 4.0
d1 = sqrt(12.0*nu/u1)
u2 = 1.0
d2 = sqrt(12.0*nu/u2)
u = u1/( cosh( (x-PI/2)/d1 ) )**2 + u2/( cosh( (x-PI/4)/d2 ) )**2

a = Field.new(x,u,nu)

DCL::gropn(1)
loop do
  DCL::grfrm
  DCL::grswnd(xmin,xmax,0.0,5.0)
  DCL::usgrph(a.x,a.u)
  50.times do a.integ(dt) end
end
DCL::grcls


</textarea>

<p class="results">
<img src="kdv.png" width="456" height="341">
</p>



<h3>演習問題</h3>

<p>
初期波形をいろいろ変えて実験。
Fieldクラスの中に波形を与えるメソッドを新たに定義し、
外から変えられるようにする。
</p>

<hr>


<a href="../../../../">地球流体電脳倶楽部</a> / 
<a href="../../index-j.htm">電脳Ruby</a> / 
<a href="../">チュートリアル</a> / 
基礎編


<hr>
<p><img src="../../../mizuta/meladd.gif"></p>
<p>Copyright (C) 2003-2006 GFD Dennou Club. All Rights Reserved.</p><p>

<!--<p>% irb -r ???.rb としておけばスクリプトを読んでからirb</p>-->
</p></body></html>
