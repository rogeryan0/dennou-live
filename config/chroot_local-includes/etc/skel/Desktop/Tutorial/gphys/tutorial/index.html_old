<html>
<head>
<title>Dennou-Ruby Tutorial</title>
<link rel="stylesheet" href="dennou-ruby.css" type="text/css">
</head>
<body>

<h1>GPhys チュートリアルページ</h1>

<p><h4>2003年8月　堀之内 武</h4>
<hr>

<ul>
 <li>
  <a href="http://www.gfd-dennou.org/arch/ruby/doc-link-j.htm">
  ドキュメンテーションリンク集
  </a>： 様々な資源のマニュアル等
  <li> <a href="http://ruby.gfd-dennou.org/products/gphys/">
     GPhys ホーム</a>
  <li> <a href="http://ruby.gfd-dennou.org/products/gphys/doc/">
     GPhys レファレンスマニュアル</a> (工事中)
 </li>
</ul>

<hr>

<p><h2>はじめに</h2>

<p>GPhysとは、物理量のデータを扱うためのクラスである。ここで想定してい
るのは、格子状に離散化された連続体の物理量で、格子点に関する諸情報と各
点における物理量の値、さらにその物理量に関する付加的な情報からなる。
詳細は追い追い説明するとして、GPhys はこんな時に便利である。

<ul>
  <li> NetCDFファイルに入ったデータを解析・可視化したい。
  <li> 流体などのシミュレーションコードを手軽に開発したい。
</ul>

<p>GPhys が扱えるファイル形式は今のところ NetCDF だけであるが、将来的
にはHDF や GrADS, grib などもサポートしたい。
GPhysを用いると、遠隔ホストに存在するデータも可視化できるようになる。
GPhys 配布パッケージには dRuby によるサーバー＆クライアントの
簡単なサンプルプログラムが含まれている。

<p> 本チュートリアルでは、2番目のシミュレーションには触れず、
既にファイルになっているデータの扱いに集中することにする。
また、今のところ遠隔データの扱いに関しては書いていない。
興味があればサンプルプログラムを参照のこと（配布パッケージの sample
サブディレクトリーに含まれる）。

<p><h2>レファレンスマニュアル</h2>

<p>GPhys のレファレンスマニュアルはここにある：

<ul>
  <li> <a href="http://ruby.gfd-dennou.org/products/gphys/doc/">
     GPhys レファレンスマニュアル</a>
</ul>

<p>現在のところ部分的にしか作成されていないが、後述する描画ライブラリー
GGraph のマニュアルは整備されている。

<p><h2>インストール</h2>

<p>以下、GPhys のバージョンは 0.0.6 を用いることにする。
GPhys は Ruby だけで書かれているので、インストールは適当なパスにコ
ピーするだけである。以下はそれを行う：

<table width=80%><tr><td><pre class="source">
% tar xvzf gphys-0.0.6.tar.gz 
% cd gphys-0.0.6
% ruby install.rb
</pre></td></tr></table>


ただし、その前にいろいろインストールしなければならないものがある。
詳しくは <a href="http://www.gfd-dennou.org/arch/ruby/products/gphys">
GPhysホームページ</a>を参照されたい。必要なのは NArray, NArrayMiss,
RubyNetCDF, RubyDCL である。可視化しないなら RubyDCL はなくてもよい。
また、今のところ RubyDCL は NArrayMiss に対応していないので、欠
損のあるデータの扱いには注意を要する。

<a name="toriaezu"></a>
<p><h2>とりあえずライブラリー付属のテストプログラムを使って
NetCDF ファイル中のデータを見てみよう</h2>

<p> 
GPhys の配布パッケージにはテスト用に、<tt>T.jan.nc</tt>という
NetCDFファイルが含まれているので、それを使う。
中身は NCEP 再解析による、全球の気温の1月の気候値である。
まずは以下を実行してみよう。
データのパスの都合上、以下のように <tt>ggraph.rb</tt>
の存在するディレクトリーにて実行する必要がある。
<table width=80%><tr><td><pre class="source">
% cd gphys-0.0.6/lib/numru
% ruby ggraph.rb
</pre></td></tr></table>

<p>ここで ggraph.rb は、GPhys の可視化ライブラリーのソースコード
である。このライブラリーは
GGraph というモジュールを定義し、描画命令はそのモジュール関数と
なっている。例えばコンター図を書くメソッド(モジュール関数)は
<tt>GGraph::contour</tt> である。

<p> ggraph.rb の末尾には GGraph モジュールのテスト／デモプログラムが付属し
ており、このファイル自身を ruby コマンドに与えることで実行される
ようになっている。上記のように本プログラムを実行すると
(<tt>% ruby ggraph.rb</tt>)、ウィンドーが立ち上がり図が表示される。
１ページ目が表示されたら、それをクリックすると２ページ目が表示される
という具合いで、４枚の図が表示される。それぞれ４つの図を含むので
図は計16枚である。
<br>
<a href='ggraph_001.jpg'><img src='ggraph_001s.jpg'>１ページ目</a>
<a href='ggraph_002.jpg'><img src='ggraph_002s.jpg'>２ページ目</a><br>
<a href='ggraph_003.jpg'><img src='ggraph_003s.jpg'>３ページ目</a>
<a href='ggraph_004.jpg'><img src='ggraph_004s.jpg'>４ページ目</a><br>

<p>ggraph.rbの末尾にあるテストプログラム部分を独立させると下のようにな
る。GPhys 0.0.6よりも後のものをインストールしている場合は、これをダウ
ンロードロードして実行すると良い。
ここではファイルのパスを書き換え、データが現在のディレクトリー
にあることにしているので、
<a href="T.jan.nc">このデータ</a> (GPhys配布パッケージにも含まれている)
を置いたディレクトリーで実行すること。
なお、独立にともない、第一行目に
<tt>require "numru/ggraph"</tt> を加え、
インストール済のライブラリーが読み込まれるようにしてある。

テストプログラムの前半は、様々な描画メソッドの
オプションのデフォルト値を標準出力に表示する(後述)。
実際の描画にかかわるのは後半部分である(<tt>file='T.jan.nc'</tt>
の行以降)。

<p><a href="ggraph_testbody.rb">ggraph_testbody.rb</a>
<table width=80%><tr><td><pre class="source">
  require "numru/ggraph"
  include NumRu

  # < read command line option if any >

  if ARGV.length == 1
    iws = ARGV[0].to_i
  else
    iws = 1
  end

  # < show default parameters >
  xdummy = ydummy = nil
  begin
    print "** GGraph::fig options **\n"
    GGraph.fig(xdummy, ydummy, 'help'=>true)
  rescue
  end
  begin
    print "** GGraph::axes options **\n"
    GGraph.axes(xdummy, ydummy, 'help'=>true)
  rescue
  end
  gp_dummy = nil
  begin
    print "** GGraph::line options **\n"
    GGraph.line(gp_dummy,true,'help'=>true)
  rescue
  end
  begin
    print "** GGraph::mark options **\n"
    GGraph.mark(gp_dummy,true,'help'=>true)
  rescue
  end
  begin
    print "** GGraph::contour options **\n"
    GGraph.contour(gp_dummy,true,'help'=>true)
  rescue
  end
  begin
    print "** GGraph::tone options **\n"
    GGraph.tone(gp_dummy,true,'help'=>true)
  rescue
  end

  #< graphic test / demonstration >
  file = 'T.jan.nc'
  gphys = GPhys::NetCDF_IO.open(file, 'T')
  DCL.gropn(iws)
  DCL.sldiv('y',2,2)
  DCL.sgpset('lcntl', false)
  DCL.sgpset('lfull',true)
  DCL.sgpset('lfprop',true)
  DCL.uzfact(0.7)
  #/ graph 1 /
  GGraph.set_fig('viewport'=>[0.25,0.75,0.12,0.62])
  GGraph.line(gphys.cut(true,35,true).mean(0), true)
  #/ graph 2 /
  GGraph.next_fig('itr'=>2)
  GGraph.next_axes('yunits'=>'','xunits'=>'')
  GGraph.line(gphys.cut(true,35,true).mean(0), true, 
	      'exchange'=>true, 'index'=>3, 'title'=>'TEMERATURE', 'annotate'=>false)
  GGraph.mark(gphys.cut(true,35,true).mean(0), false, 
	      'exchange'=>true, 'type'=>3)
  #/ graph 3 /
  GGraph.contour(gphys)
  #/ graph 4 /
  GGraph.next_fig('itr'=>2)
  GGraph.contour(gphys.cut(135,true,true))
  #/ graph 5 /
  GGraph.set_axes('xunits'=>'', 'yunits'=>'')
  GGraph.contour(gphys,true, 'min'=>0, 'coloring'=>true)
  #/ graph 6 /
  GGraph.set_fig('viewport'=>[0.2,0.8,0.15,0.55])
  GGraph.contour(gphys,true, 'nozero'=>true)
  #/ graph 7 /
  GGraph.contour(gphys,true, 'min'=>10, 'int'=>3)
  DCL.udpset('lmsg',false)
  GGraph.contour(gphys,false, 'max'=>-10, 'int'=>3)
  DCL.udpset('lmsg',true)
  #/ graph 8 /
  GGraph.set_contour_levels('levels'=>[-10,-5,0,5,10],'index'=>[3,1,3,1,3],
			'line_type'=>2)
  GGraph.contour(gphys)
  GGraph.clear_contour_levels
  #/ graph 9 /
  GGraph.contour(gphys, true, 'levels'=>[0,10,20], 'index'=>3)
  #/ graph 10 /
  GGraph.set_linear_contour_options('nlev'=>24)
  GGraph.next_linear_contour_options('coloring'=>true)
  GGraph.contour(gphys)
  #/ graph 11 /
  GGraph.tone(gphys, true, 'min'=>0)
  #/ graph 12 /
  GGraph.tone(gphys, true, 'ltone'=>false)
  GGraph.contour(gphys, false)
  #/ graph 13 /
  GGraph.next_fig('itr'=>3)
  GGraph.contour(gphys[1..-1,true,true])
  #/ graph 14 /
  GGraph.tone(gphys, true, 'levels'=>[-10,10],'patterns'=>[20999,50999,80999])
  #/ graph 15 /
  GGraph.tone(gphys, true, 'levels'=>[-10,10],'patterns'=>[50999,80999])
  #/ graph 16 /
  GGraph.tone(gphys, true, 'levels'=>[-10,10],'patterns'=>[50999])
  DCL.grcls
</pre></td></tr></table>

<p> 上記ソース中で、描画をおこなっているメソッドは、
<ul>
  <li> １次元描画： <tt>GGraph::line</tt>, <tt>GGraph::mark</tt>
  <li> ２次元描画： <tt>GGraph::conout</tt>, <tt>GGraph::tone</tt>
</ul>
<p>である。これらは数多くのオプションにより描画スタイルが変えられる。
デフォルトでは、改ページと図の初期化、軸描画も行うが、これらを抑止しし
て、前に書いた図に重ね書きすることもできる。
オプションのデフォルト値は変更でき、さらに、次回の描画のみに
影響を与えるような設定を行うメソッドもある。

<p> 以下に、このプログラム
の標準出力への出力を引用する。ソース前半で、各メソッドを
help オプション付で呼んでいるため、オプションのデフォルト値が表示
されている。helpオプションを付けると描画は行われないのでデータは
ダミー(nil)でよい。各メソッドのデフォルト値は
<a href="http://ruby.gfd-dennou.org/products/gphys/doc/ggraph.html">
GGraphのレファレンスマニュアル</a>
にも載っているが、特に irb
を用いて対話的に描画している場合は、help 機能は便利だろう。
なお、help が呼ばれると例外を上げて実行を中断するようになっているので、
テストプログラムでは
begin 〜 rescue  〜 end で囲って保護してある。対話的に利用する場合は、
例外が出ても制御がユーザーに戻ってくるだけなので、保護は必要ない。

<table width=80%><tr><td><pre class="source">
** GGraph::fig options **
<< Description of options >>
  option name   default value   # description:
  "new_frame"   true    # whether to define a new frame by DCL.grfrm
                        # (otherwise, DCL.grfig is called)
  "window"      nil     # [uxmin, uxmax, uymin, uymax]
  "viewport"    [0.2, 0.8, 0.2, 0.8]    # [vxmin, vxmax, vymin, vymax]
  "itr" 1       # coordinate transformation number
  "xreverse"    "positive:down,units:hPa"       # Assign max value to
                        # UXMIN and min value to UXMAX if condition is
                        # satisfied (nil:never, true:always, String: when
                        # an attibute has the value specified
                        # ("key:value,key:value,..")
  "yreverse"    "positive:down,units:hPa"       # Assign max value to
                        # UYMIN and min value to UYMAX if condition is
                        # satisfied (nil:never, true:always, String: when
                        # an attibute has the value specified
                        # ("key:value,key:value,..")
  "help"        false   # show help message if true
 Current values={"help"=>false, "window"=>nil, "new_frame"=>true, "itr"=>1, "yreverse"=>"positive:down,units:hPa", "viewport"=>[0.2, 0.8, 0.2, 0.8], "xreverse"=>"positive:down,units:hPa"}
** GGraph::axes options **
<< Description of options >>
  option name   default value   # description:
  "xside"       "tb"    # Where to draw xaxes (combination of t, b and u)
  "yside"       "lr"    # Where to draw yaxes (combination of l, r and u)
  "xtitle"      nil     # Title of x axis (if nil, internally determined)
  "ytitle"      nil     # Title of y axis (if nil, internally determined)
  "xunits"      nil     # Units of x axis (if nil, internally determined)
  "yunits"      nil     # Units of y axis (if nil, internally determined)
  "help"        false   # show help message if true
 Current values={"xtitle"=>nil, "help"=>false, "ytitle"=>nil, "yunits"=>nil, "yside"=>"lr", "xunits"=>nil, "xside"=>"tb"}
** GGraph::line options **
<< Description of options >>
  option name   default value   # description:
  "title"       nil     # Title of the figure(if nil, internally
                        # determined)
  "annotate"    true    # if false, do not put texts on the right
                        # margin even when newframe==true
  "exchange"    false   # whether to exchange x and y axes
  "index"       1       # line/mark index
  "type"        1       # line type
  "help"        false   # show help message if true
 Current values={"annotate"=>true, "help"=>false, "title"=>nil, "type"=>1, "exchange"=>false, "index"=>1}
** GGraph::mark options **
<< Description of options >>
  option name   default value   # description:
  "title"       nil     # Title of the figure(if nil, internally
                        # determined)
  "annotate"    true    # if false, do not put texts on the right
                        # margin even when newframe==true
  "exchange"    false   # whether to exchange x and y axes
  "index"       1       # mark index
  "type"        2       # mark type
  "size"        0.01    # marks size
  "help"        false   # show help message if true
 Current values={"annotate"=>true, "size"=>0.01, "help"=>false, "title"=>nil, "type"=>2, "exchange"=>false, "index"=>1}
** GGraph::contour options **
<< Description of options >>
  option name   default value   # description:
  "title"       nil     # Title of the figure(if nil, internally
                        # determined)
  "annotate"    true    # if false, do not put texts on the right
                        # margin even when newframe==true
  "min" nil     # minimum contour value
  "max" nil     # maximum contour value
  "nlev"        nil     # number of levels
  "interval"    nil     # contour interval
  "nozero"      nil     # delete zero contour
  "coloring"    false   # set color contours with ud_coloring
  "clr_min"     13      # (if coloring) minimum color id
  "clr_max"     100     # (if coloring) maximum color id
  "help"        false   # show help message if true
  "levels"      nil     # contour levels (Array/NArray of Numeric)
  "index"       nil     # (if levels) line index(es) (Array/NArray of
                        # integers, Integer, or nil)
  "line_type"   nil     # (if levels) line type(s) (Array/NArray of
                        # integers, Integer, or nil)
  "label"       nil     # (if levels) contour label(s) (Array/NArray of
                        # String, String, true, false, nil). nil is
                        # recommended.
  "label_height"        nil     # (if levels) label height(s) (Array/NArray
                        # of Numeric, Numeric, or nil). nil is recommended.
 Current values={"label_height"=>nil, "annotate"=>true, "help"=>false, "title"=>nil, "coloring"=>false, "max"=>nil, "nlev"=>nil, "line_type"=>nil, "min"=>nil, "clr_max"=>100, "index"=>nil, "levels"=>nil, "interval"=>nil, "nozero"=>nil, "label"=>nil, "clr_min"=>13}
** GGraph::tone options **
<< Description of options >>
  option name   default value   # description:
  "title"       nil     # Title of the figure(if nil, internally
                        # determined)
  "annotate"    true    # if false, do not put texts on the right
                        # margin even when newframe==true
  "ltone"       true    # Same as udpack parameter ltone
  "min" nil     # minimum contour value
  "max" nil     # maximum contour value
  "nlev"        nil     # number of levels
  "interval"    nil     # contour interval
  "help"        false   # show help message if true
  "levels"      nil     # tone levels  (Array/NArray of Numeric). Works
                        # together with patterns
  "patterns"    nil     # tone patters (Array/NArray of Numeric). Works
                        # together with levels
 Current values={"annotate"=>true, "ltone"=>true, "help"=>false, "title"=>nil, "max"=>nil, "nlev"=>nil, "min"=>nil, "patterns"=>nil, "levels"=>nil, "interval"=>nil}
 *** MESSAGE (SWDOPN) ***  GRPH1 : STARTED / IWS =  1.                         
 *** MESSAGE (SWPCLS) ***  GRPH1 : PAGE =   1 COMPLETED.                       
 *** MESSAGE (SWPCLS) ***  GRPH1 : PAGE =   2 COMPLETED.                       
 *** MESSAGE (SWPCLS) ***  GRPH1 : PAGE =   3 COMPLETED.                       
 *** MESSAGE (SWPCLS) ***  GRPH1 : PAGE =   4 COMPLETED.                       
 *** MESSAGE (SWDCLS) ***  GRPH1 : TERMINATED.                                 
</pre></td></tr></table>

<p><h2>GGraph を使いこなそう</h2>

<h3>用いるデータ</h3>

<p>以下では、<a href="T.jan.nc">GPhys配布パッケージに含まれる気温データ</a>
が実行時のカレントディレクトリーにあるものとする。

<p> まずは、このファイルの概要を見よう。NetCDF付属のコマンド
ncdump を用いる。

<table width=80%><tr><td><pre class="source">
% ncdump -c T.jan.nc 
netcdf T.jan {
dimensions:
        lon = 36 ;
        lat = 19 ;
        level = 9 ;
variables:
        float lon(lon) ;
                lon:units = "degrees_east" ;
                lon:long_name = "Longitude" ;
                lon:actual_range = 0.f, 357.5f ;
        float lat(lat) ;
                lat:units = "degrees_north" ;
                lat:actual_range = 90.f, -90.f ;
                lat:long_name = "Latitude" ;
        float level(level) ;
                level:units = "millibar" ;
                level:long_name = "Level" ;
                level:positive = "down" ;
                level:GRIB_id = 100s ;
                level:GRIB_name = "hPa" ;
                level:actual_range = 10.f, 1000.f ;
        float T(level, lat, lon) ;
                T:long_name = "Monthly Mean Air temperature" ;
                T:actual_range = -72.66724f, -24.35f ;
                T:units = "degC" ;
                T:add_offset = 0.f ;
                T:scale_factor = 1.f ;
                T:missing_value = -9.96921e+36f ;
..中略..

data:

 lon = 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 
    160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 
    300, 310, 320, 330, 340, 350 ;

 lat = 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, -10, -20, -30, -40, -50, -60, 
    -70, -80, -90 ;

 level = 1000, 850, 600, 400, 250, 150, 70, 30, 10 ;
}
</pre></td></tr></table>

<p>これは、NCEP再解析データによる、1月の全球の気温の気候値である。
元の分解能よりは粗くしてデータサイズを押えてある。
気温 <tt>T</tt> は経度、緯度、圧力の３次元データで、もっとも「速くまわる」のは
経度軸である。ncdump の次元の表示は C 言語のスタイルであるので、
<tt>T(level, lat, lon)</tt> であるが、Ruby の多次元データでは
その逆に <tt>lon, lat, level</tt> の順番で次元を並べる
（これは NArray のスタイルであり、RubyNetCDF や GPhys
等、全ての多次元データライブラリーが従っている。Fortranと同じ --
ただし配列添字はゼロから始まる）。

<h3>最速描画(コンター)</h3>

<p> GGraphにおける２次元描画メソッド(<tt>contour</tt>, <tt>tone</tt>)
では、与えられたデータが３次元以上なら、3,4,..次元目については
最初の格子点を自動的に選ぶようになっている。従って、
以下のプログラムは、3次元目の最初の格子点＝最下層(1000hPa)の気温を表示する
(行番号は説明の便のため。実際には含まれない)。

<p><a href="contour1000mb_1.rb">contour1000mb_1.rb</a>
<table width=80%><tr><td><pre class="source">
1: require "numru/ggraph"
2: include NumRu
3: gphys = GPhys::NetCDF_IO.open('T.jan.nc', 'T')
4: DCL.gropn(1)
5: DCL.sgpset('lcntl', false) ; DCL.uzfact(0.7)
6: GGraph.contour( gphys )
7: DCL.grcls
</pre></td></tr></table>

<p> 以下のように実行する。

<table width=80%><tr><td><pre class="source">
% ruby contour1000mb_1.rb
</pre></td></tr></table>

<p> すると、次の図が画面に表示される。<br>

<a href='contour1000mb_1.jpg'>
<img src='contour1000mb_1s.jpg'>contour1000mb_1.rb実行結果</a><br>

<p>上記プログラムの第1, 2行目は毎回呼ぶおまじないである。
<tt>require "numru/ggraph"</tt> は必要なライブラリーを
全てロードする。<tt>include NumRu</tt> はしなくてもよいが、
その場合 <tt>GGraph</tt>や <tt>DCL</tt> はすべてフルネーム、つまり
<tt>NumRu::GGraph</tt> や <tt>NumRu::DCL</tt> で呼ばねばならない。

<p>第3行目では、ファイル <tt>T.jan.nc</tt> 中の変数
<tt>T</tt> に対し、GPhys オブジェクトを構成する。
モジュール <tt>GPhys::NetCDF_IO</tt> は NetCDF
ファイル解釈を司る。ユーザーが特に指定しない限り、
NetCDFユーザーズガイドに従った解釈が行われる。
ルールに則って座標変数も解釈され、gphys 内に参照が保持される。

<p> 第4行目は、DCL のグラフィック装置初期化である。引数＝１の場合、
端末画面に表示される。第5行目は通常必要ないが、ここでは制御文字の
解釈を抑制し(<tt>DCL.sgpset('lcntl', false)</tt> アンダースコアー
等が特殊文字として解釈されないようにする)、座標軸につける文字の大きさを
0.7 倍にしている (<tt>DCL.uzfact(0.7)</tt>)。

<p> 第6行目でいよいよ描画である。<tt>GGraph.contour(gphys)</tt>
は、引数に与えられた GPhys オブジェクトのデータを等高線表示する。
前述のように、３次元目以降に関しては自動的に最初の点が選ばれるので、
1000 mb における水平分布のプロットとなる。1000 mb が選ばれたことは、
図の右上の枠外に表示された <tt>level=1000 milibar</tt>の表示からわかる。
なお、この図では表示すべき文字列が長いので 'm' 以降が表示されていない。
これを回避する方法は後述する。
図からわかるように、<tt>GGraph.contour</tt>
は自動的に座標軸等の解釈を行う（x軸、y軸が正しく書かれていることに注意）。
実は、第5行目で制御文字解釈を抑制したのは、表示される x, y 軸の単位に
アンダースコアーが含まれているからである。

<p> 第7行目は DCL の終了処理である。

<p> 以上、必ずしも必要ない第5行目を除けば、全部で6行でファイルのオー
プンから可視化、終了処理までが行える。図をカスタマイズする方法は後で述べる。
その際、プログラムが急に長くなったりしないのがポイントである。

<h3>最速描画(折れ線)</h3>

<p>同じ要領で折れ線を描いてみよう。上のプログラムで 6 行目の
<tt>GGraph.contour(gphys)</tt> を <tt>GGraph.line(gphys)</tt>
に変えればよい。但しそれだと２次元目(緯度)に関し、最初の格子点
（つまり北極）が選ばれてしまい面白くない。そこで、日本付近の
鉛直プロファイルを描いてみよう。GPhysのメソッド <tt>cut</tt>
は実空間での切り出しを行う。これは次元を順番に指定する方法と、
次元を名前で指定する方法の２通りの使い方ができる。
以下の2行は全く同じ結果となる。

<table width=80%><tr><td><pre class="source">
gp_jpn = gphys.cut(135,35,true)
gp_jpn = gphys.cut('lon'=>135,'lat'=>35)
</pre></td></tr></table>

<p>最初の場合の引数の指定方法は NArray の [] メソッドと同様である。
従って名前で指定した場合と同様、２次元以上任意の次元数(rank)のデータ
に対応するには、true でなく false による「ラバー次元」を使えば良い。
ラバー次元は任意個の true (全範囲の指定) に相当する。

<table width=80%><tr><td><pre class="source">
gp_jpn = gphys.cut(135,35,false)
</pre></td></tr></table>

<p>（余談だが yorick という言語ではラバー次元は .. と表せる。
つまり (135,35,..) など。この方が見た目わかりやすいが、Ruby では
.. を独立させることはできないので使えない。）

<p>では、図を描いてみよう。

<p><a href="line_1.rb">line_1.rb</a>
<table width=80%><tr><td><pre class="source">
1: require "numru/ggraph"
2: include NumRu
3: gphys = GPhys::NetCDF_IO.open('T.jan.nc', 'T')
4: DCL.gropn(1)
5: DCL.sgpset('lcntl', false) ; DCL.uzfact(0.7)
6: GGraph.line( gphys.cut(135,35,false) )
7: DCL.grcls
</pre></td></tr></table>

<p>結果はこうなる：<br>

<a href='line_1.jpg'><img src='line_1s.jpg'>line_1.rb実行結果</a><br>

右上枠外には、"lon=130.0 degrees_east", "lat=40.0 degress_north" と表
示される。cut は一番近い格子点を選ぶようになっており、たまたまど真ん中
を指定した場合はより格子点番号の小さい方が選ばれる。経度は東→西、
緯度は北→南に格納されているので、このような緯度・経度が選ばれるのである。

<p>さて、鉛直座標である圧力が横軸に来ると、
どうも鉛直プロファイルであるような気がしない。
そこで、縦軸と横軸を入れ替え、圧力軸は対数スケールで表示してみよう。
ついでに、枠外右上の情報が切れないよう全画面表示にしよう
(<tt>DCL.sgpset('lfull',true)</tt>)。

<p><a href="line_2.rb">line_2.rb</a>
<table width=80%><tr><td><pre class="source">
1: require "numru/ggraph"
2: include NumRu
3: gphys = GPhys::NetCDF_IO.open('T.jan.nc', 'T')
4: DCL.gropn(1)
5: DCL.sgpset('lcntl', false) ; DCL.sgpset('lfull',true) ; DCL.uzfact(0.6)
6: GGraph.set_fig( 'itr'=> 2, 'viewport'=>[0.25,0.7,0.15,0.6] )
7: GGraph.line( gphys.cut(135,35,false), true, 'exchange'=>true )
8: DCL.grcls
</pre></td></tr></table>

<p><a href='line_2.jpg'><img src='line_2s.jpg'>line_2.rb実行結果</a><br>

<p> 上のプログラムでは、縦軸を対数スケーリングにするため、第6行目で
GGraph.fig のオプション <tt>itr</tt> を設定している
(<a href="http://ruby.gfd-dennou.org/products/gphys/doc/ggraph.html">GGraphマニュアル</a>参照)。
さらに、全画面表示に呼応して、viewport を変えている（デフォルト値は
[0.2,0.8,0.2,0.8]）。
GGraph.fig は新しい図の枠を定義するメソッドであり、
GGraph.line の第２引数が true のとき呼ばれる。第２引数は省略可能で
true はデフォルト値である。
第7行目は GGraph.line を呼んでいるが、GGraph.line のオプションは第３引
数(以降)であるので、第2引数の true を陽に設定している（間違えやすいの
で第2引数が true/false 以外なら例外によりユーザーに通知する）。
そして、オプションとして <tt>'exchange'=>true</tt> を指定している。
これにより、デフォルトと逆に、座標を縦軸、データを横軸に書くようになる。

<p> 右上枠外のメッセージ（"lon=130.0 degrees_east" 等） を表示しないよ
うにしてみよう。そうすれば表示する文字にアンダースコアーが含まれなくなるので、
制御文字解釈を抑制しなくても良い：

<p><a href="line_3.rb">line_3.rb</a>
<table width=80%><tr><td><pre class="source">
1: require "numru/ggraph"
2: include NumRu
3: gphys = GPhys::NetCDF_IO.open('T.jan.nc', 'T')
4: DCL.gropn(1)
5: DCL.uzfact(0.7)
6: GGraph.set_fig( 'itr'=> 2 )
7: GGraph.line( gphys.cut(135,35,false), true, 'exchange'=>true, 'annot'=>false )
8: DCL.grcls
</pre></td></tr></table>

<p> ここではオプション 'annotate' を false にした。オプション名は、前方一致で後
ろを省略できる(勿論2つ以上のオプション名にマッチするような省略はできない)。

<p><a href='line_3.jpg'><img src='line_3s.jpg'>line_3.rb実行結果</a><br>

<h3>平均操作などなど</h3>

<p>GPhys データは切り出して表示するだけでなく、平均を取ったり
数学演算や統計操作を行うことができる。
切り出しまではデータに関する演算が不要であるので、
GPhysオブジェクトは NetCDF ファイル中の変数 (NetCDFVarオブジェクト)
への参照を保持しているだけだったが、
平均をとるとなると実際のデータの読み出しと演算が必要である。
しかし、GPhys そんなことは気にしないでいいようにできている。

<p>下のプログラムは、全球平均気温の鉛直プロファイルを表示する。
ソースは <tt>line_2.rb</tt> とほとんど変らないことに注意せよ。

<p><a href="line_4.rb">line_4.rb</a>
<table width=80%><tr><td><pre class="source">
1: require "numru/ggraph"
2: include NumRu
3: gphys = GPhys::NetCDF_IO.open('T.jan.nc', 'T')
4: DCL.gropn(1)
5: DCL.sgpset('lcntl', false) ; DCL.sgpset('lfull',true) ; DCL.uzfact(0.6)
6: GGraph.set_fig( 'itr'=> 2, 'viewport'=>[0.25,0.7,0.15,0.6] )
7: GGraph.line( gphys.mean(1).mean(0), true, 'exchange'=>true )
8: DCL.grcls
</pre></td></tr></table>

<p>mean(1)で第2次元目、mean(0)で第1次元目の平均を取っている
（配列要素同様、次元も 0 から数える。なお将来的には mean(0,1)と一回で済
むようにする予定）。
この結果のデータはもはやファイル中にはなく、メモリー上に NArray として
保持される。しかし、GPhysは、配下のデータが NetCDFVar 中にあるのか
NArray 中にあるかによって振る舞いは変らない。従って今まで全く同じよう
に可視化できるのである。
結果の図は下。枠外右上の情報が平均を表すものに変っていることに注意。

<p><a href='line_4.jpg'><img src='line_4s.jpg'>line_2.rb実行結果</a><br>

<p> なお、クラス GPhys は、データが NetCDFVar 
中にあるのか NArray 中にあるのかを、直接には全く知らない。
この２つの違いは、GPhys 配下の VArray (= Virtual Array)が吸収する。
GPhys の構成については、
<a href="http://ruby.gfd-dennou.org/workshop200303/horinout/">
こちらを参照</a>のこと。なお、このドキュメントは GPhys 0.0.1 に
基づいて書いてあるため、現在は既に実装してある機能を未実装と
してあったりする（例えば、VArray の「タイリング」は実装済。
但しそれを活かした GPhys::NetCDF_IO.open の拡張は
0.0.6 ではまだ）。また、最後の方に登場する GGraph は旧版であり、
現在の GGraph とは全く異なる。

<h3>多彩なコンター、トーン描画</h3>

すみません、まだ書いてません。
とりあえず<a href="#toriaezu">最初の例</a>を見てください。

<hr>

<p>Copyright (C) 2003 GFD Dennou Club. All Rights Reserved.<p>

</body>
</html>
<