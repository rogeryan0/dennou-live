<?xml version="1.0" encoding="euc-jp"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: aq_module</title>
  <meta http-equiv="Content-Type" content="text/html; charset=euc-jp" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">aq_module</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../files/src/aq_module_f90.html">

                src/aq_module.f90

                </a>


        <br />
            </td>
        </tr>


        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">


  <div id="contextContent">



    <div id="description">
      <h1><a href="aq_module.html">aq_module</a></h1>
<table>
<tr><td valign="top">Authors:</td><td>Shin-ichi Takehiro, Youhei SASAKI

</td></tr>
<tr><td valign="top">Version:</td><td>$Id: <a href="../files/src/aq_module_f90.html">aq_module.f90</a>,v 1.10
2009-02-28 21:33:45 uwabami Exp $

</td></tr>
<tr><td valign="top">Copyright&amp;License:</td><td>See <a href="../../COPYRIGHT">COPYRIGHT</a>

</td></tr>
</table>
<h2>概要</h2>
<p>
spml/aq_module モジュールは 1 次元有限領域の下での流体運動を Matsushima and
Marcus (1994) で提唱された多項式を用いたスペクトル法によって
数値計算するための Fortran90 関数を提供する.
</p>
<p>
このルーチンは離散化にチェビシェフ&#8212;ガウス&#8212;ラダウ格子点を適用して
おり, 主に 2 次元極座標, 円筒座標, 球座標の原点の特異性を回避しな
がらスペクトル計算を行うために用いることを念頭においている.
</p>
<p>
2 次元データの 1 次元に関して同時にスペクトル計算を実行するための
関数も提供しており, 2, 3 次元領域での計算のベースも提供する.
</p>
<p>
Matsushima and Marcus (1994) の多項式に関する説明は
動径座標のスペクトル法(<a
href=".././spectral_radial.pdf">spectral_radial.pdf</a>) を参照のこと.
</p>
<h2>関数・変数の名前と型について</h2>
<h3>命名法</h3>
<ul>
<li>関数名の先頭 (u_, g_, aq_, ag_) は, 返す値の形を示している. 複数並んだ 2
次元データの第 1 次元の大きさは <a
href="aq_module.html#M001983">aq_Initial</a> で 設定する重みの指数の配列 nd
の大きさと同じでなければならない.

<table>
<tr><td valign="top">q_  :</td><td>スペクトルデータ

</td></tr>
<tr><td valign="top">g_  :</td><td>1 次元格子点データ

</td></tr>
<tr><td valign="top">aq_ :</td><td>1 次元スペクトルデータが複数並んだ 2 次元データ

</td></tr>
<tr><td valign="top">ag_ :</td><td>1 次元格子点データが複数並んだ 2 次元データ.

</td></tr>
</table>
</li>
<li>関数名の間の文字列(Dr)は, その関数の作用を表している.

</li>
<li>関数名の最後 (_e, _aq, _g, _ag) は, 入力変数の形がスペクトルデータ
および格子点データであることを示している.

<table>
<tr><td valign="top">_q  :</td><td>スペクトルデータ

</td></tr>
<tr><td valign="top">_g  :</td><td>1 次元格子点データ

</td></tr>
<tr><td valign="top">_aq :</td><td>1 次元スペクトルデータが複数並んだ 2 次元データ

</td></tr>
<tr><td valign="top">_ag :</td><td>1 次元格子点データが複数並んだ 2 次元データ

</td></tr>
</table>
</li>
</ul>
<h3>各データの種類の説明</h3>
<ul>
<li>g : 1 次元格子点データ.

<ul>
<li>変数の種類と次元は real(8), dimension(im).

</li>
<li>im は R 座標の格子点数であり, サブルーチン <a
href="aq_module.html#M001983">aq_Initial</a> にて あらかじめ設定しておく.

</li>
</ul>
</li>
<li>q : スペクトルデータ.

<ul>
<li>変数の種類と次元は real(8), dimension(0:km).

</li>
<li>km は R 方向の最大波数であり, サブルーチン <a
href="aq_module.html#M001983">aq_Initial</a> にて あらかじめ設定しておく.
スペクトルデータの格納のされ方については&#8230;

</li>
</ul>
</li>
<li>ag : 1 次元(R)格子点データの並んだ 2 次元データ.

<ul>
<li>変数の種類と次元は real(8), dimension(size(nd),im). 第 2 次元が R
方向を表す.

</li>
</ul>
</li>
<li>aq : 1 次元スペクトルデータの並んだ 2 次元データ.

<ul>
<li>変数の種類と次元は real(8), dimension(size(nd),0:km). 第 2
次元がスペクトルを表す.

</li>
</ul>
</li>
<li>g_ で始まる関数が返す値は 1 次元格子点データに同じ.

</li>
<li>q_ で始まる関数が返す値はスペクトルデータに同じ.

</li>
<li>ag_ で始まる関数が返す値は 1 次元格子点データの並んだ 2 次元データに同じ.

</li>
<li>aq_ で始まる関数が返す値は 1 次元スペクトルデータの並んだ 2
次元データに同じ.

</li>
<li>スペクトルデータに対する微分等の作用とは, 対応する格子点データに
微分などを作用させたデータをスペクトル変換したもののことである.

</li>
</ul>
<h2>変数・手続き群の要約</h2>
<h4>初期化</h4>
<table>
<tr><td valign="top"><a href="aq_module.html#M001983">aq_Initial</a>  :</td><td>スペクトル変換の格子点数, 波数, 領域の大きさの設定

</td></tr>
</table>
<h4>座標変数</h4>
<table>
<tr><td valign="top"><a href="aq_module.html#M001981">g_R</a>        :</td><td>格子点座標(R)を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="aq_module.html#M001982">g_R_Weight</a> :</td><td>重み座標を格納した 1 次元配列

</td></tr>
</table>
<h4>基本変換</h4>
<table>
<tr><td valign="top"><a href="aq_module.html#M001985">g_q</a>, <a href="aq_module.html#M001984">ag_aq</a> :</td><td>スペクトルデータから格子データへの変換

</td></tr>
<tr><td valign="top"><a href="aq_module.html#M001987">q_g</a>, <a href="aq_module.html#M001986">aq_ag</a> :</td><td>格子データからスペクトルデータへの変換

</td></tr>
</table>
<h4>微分</h4>
<table>
<tr><td valign="top"><a href="aq_module.html#M001989">q_rDr_q</a>, <a href="aq_module.html#M001988">aq_rDr_aq</a> :</td><td>スペクトルデータに r(d/dR) 微分を作用させる

</td></tr>
</table>
<h4>積</h4>
<table>
<tr><td valign="top"><a href="aq_module.html#M001991">q_r2_q</a>,    <a href="aq_module.html#M001990">aq_r2_aq</a>    :</td><td>スペクトルデータに r^2 をかける

</td></tr>
<tr><td valign="top"><a href="aq_module.html#M001993">q_r2Inv_q</a>, <a href="aq_module.html#M001992">aq_r2Inv_aq</a> :</td><td>スペクトルデータに r^-2 をかける

</td></tr>
</table>
<h4>積分・平均</h4>
<table>
<tr><td valign="top"><a href="aq_module.html#M001994">a_Int_ag</a>, <a href="aq_module.html#M001996">a_Avr_ag</a> :</td><td>1 次元格子点データの並んだ 2 次元配列の積分および平均

</td></tr>
<tr><td valign="top"><a href="aq_module.html#M001995">Int_g</a>, <a href="aq_module.html#M001997">Avr_g</a>       :</td><td>1 次元格子点データの積分および平均

</td></tr>
</table>
<h4>境界値問題</h4>
<table>
<tr><td valign="top"><a href="aq_module.html#M001998">aq_Boundary_D</a>, <a href="aq_module.html#M002000">aq_Boundary_N</a>         :</td><td>外側ディリクレ条件, ノイマン条件

</td></tr>
<tr><td valign="top"><a href="aq_module.html#M002002">aq_BoundaryTau_D</a>, <a href="aq_module.html#M002004">aq_BoundaryTau_N</a>   :</td><td>外側ディリクレ条件, ノイマン条件(タウ法)

</td></tr>
<tr><td valign="top"><a href="aq_module.html#M002006">ag_BoundaryGrid_D</a>, <a href="aq_module.html#M002008">ag_BoundaryGrid_N</a> :</td><td>外側ディリクレ条件, ノイマン条件(選点法)

</td></tr>
</table>

    </div>





   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M001997">Avr_g</a>&nbsp;&nbsp;

        <a href="#M001995">Int_g</a>&nbsp;&nbsp;

        <a href="#M001996">a_Avr_ag</a>&nbsp;&nbsp;

        <a href="#M001994">a_Int_ag</a>&nbsp;&nbsp;

        <a href="#M002007">ag_BoundaryGrid_D</a>&nbsp;&nbsp;

        <a href="#M002006">ag_BoundaryGrid_D</a>&nbsp;&nbsp;

        <a href="#M002009">ag_BoundaryGrid_N</a>&nbsp;&nbsp;

        <a href="#M002008">ag_BoundaryGrid_N</a>&nbsp;&nbsp;

        <a href="#M001984">ag_aq</a>&nbsp;&nbsp;

        <a href="#M002003">aq_BoundaryTau_D</a>&nbsp;&nbsp;

        <a href="#M002002">aq_BoundaryTau_D</a>&nbsp;&nbsp;

        <a href="#M002005">aq_BoundaryTau_N</a>&nbsp;&nbsp;

        <a href="#M002004">aq_BoundaryTau_N</a>&nbsp;&nbsp;

        <a href="#M001999">aq_Boundary_D</a>&nbsp;&nbsp;

        <a href="#M001998">aq_Boundary_D</a>&nbsp;&nbsp;

        <a href="#M002001">aq_Boundary_N</a>&nbsp;&nbsp;

        <a href="#M002000">aq_Boundary_N</a>&nbsp;&nbsp;

        <a href="#M001983">aq_Initial</a>&nbsp;&nbsp;

        <a href="#M001986">aq_ag</a>&nbsp;&nbsp;

        <a href="#M001992">aq_r2Inv_aq</a>&nbsp;&nbsp;

        <a href="#M001990">aq_r2_aq</a>&nbsp;&nbsp;

        <a href="#M001988">aq_rDr_aq</a>&nbsp;&nbsp;

        <a href="#M001981">g_R</a>&nbsp;&nbsp;

        <a href="#M001982">g_R_Weight</a>&nbsp;&nbsp;

        <a href="#M001985">g_q</a>&nbsp;&nbsp;

        <a href="#M001987">q_g</a>&nbsp;&nbsp;

        <a href="#M001993">q_r2Inv_q</a>&nbsp;&nbsp;

        <a href="#M001991">q_r2_q</a>&nbsp;&nbsp;

        <a href="#M001989">q_rDr_q</a>&nbsp;&nbsp;
      </div>
    </div>


  </div>


    <!-- if includes -->

    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">

        <span class="include-name">dc_message</span>

        <span class="include-name"><a href="lumatrix.html">lumatrix</a></span>
      </div>
    </div>



    <div id="section">










      


    <!-- if method_list -->

    <div id="methods">


      <h3 class="section-bar">Public Instance methods</h3>


      <div id="method-M001997" class="method-detail">
        <a name="M001997"></a>

        <div class="method-heading">


          <a href="#M001997" class="method-signature">



          <span class="method-name">Avr_g</span><span class="method-args">( g ) result(Avr_g)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001997">Avr_g</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>g  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(im), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元格子点データの平均
</p>
<pre>
     \int_0^a f(R) W(R) dR/\int_0^a W(R) dR,
         W(R) = R^beta/(a^2-R^2)^(1-alpha)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001997-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001997-source">
<pre>
  function Avr_g(g)
    !
    ! 1 次元格子点データの平均
    !
    !      \int_0^a f(R) W(R) dR/\int_0^a W(R) dR, 
    !          W(R) = R^beta/(a^2-R^2)^(1-alpha)
    !
    ! を計算する. 
    !
    real(8), dimension(im), intent(in)   :: g
    !(in) 格子点データ

    real(8)                              :: Avr_g
    !(out) 積分値

    Avr_g = Int_g(g)/sum(g_R_Weight)
  end function Avr_g
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001995" class="method-detail">
        <a name="M001995"></a>

        <div class="method-heading">


          <a href="#M001995" class="method-signature">



          <span class="method-name">Int_g</span><span class="method-args">( g ) result(Int_g)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001995">Int_g</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>g  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(im), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元格子点データの積分
</p>
<pre>
     \int_0^a f(R) W(R) dR, W(R) = R^beta/(a^2-R^2)^(1-alpha)
</pre>
<p>
を行う
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001995-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001995-source">
<pre>
  function Int_g(g)
    !
    ! 1 次元格子点データの積分
    !
    !      \int_0^a f(R) W(R) dR, W(R) = R^beta/(a^2-R^2)^(1-alpha)
    !
    ! を行う
    !
    real(8), dimension(im), intent(in)   :: g
    !(in) 格子点データ

    real(8)                              :: Int_g
    !(out) 積分値

    Int_g = sum(g*g_R_Weight)

  end function Int_g
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001996" class="method-detail">
        <a name="M001996"></a>

        <div class="method-heading">


          <a href="#M001996" class="method-signature">



          <span class="method-name">a_Avr_ag</span><span class="method-args">( ag ) result(a_Avr_ag)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001996">a_Avr_ag</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(ag,1))</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均したデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ag  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in)入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元格子点データが並んだ 2 次元配列の平均
</p>
<pre>
     \int_0^a f(R) W(R) dR/\int_0^a W(R) dR,
         W(R) = R^beta/(a^2-R^2)^(1-alpha)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001996-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001996-source">
<pre>
  function a_Avr_ag(ag)
    !
    ! 1 次元格子点データが並んだ 2 次元配列の平均
    !
    !      \int_0^a f(R) W(R) dR/\int_0^a W(R) dR, 
    !          W(R) = R^beta/(a^2-R^2)^(1-alpha)
    !
    ! を計算する. 
    !
    real(8), dimension(:,0:), intent(in)   :: ag
    !(in)入力格子点データ

    real(8), dimension(size(ag,1))         :: a_Avr_ag
    !(out) 平均したデータ

    a_Avr_ag = a_Int_ag(ag)/sum(g_R_Weight)

  end function a_Avr_ag
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001994" class="method-detail">
        <a name="M001994"></a>

        <div class="method-heading">


          <a href="#M001994" class="method-signature">



          <span class="method-name">a_Int_ag</span><span class="method-args">( ag ) result(a_Int_ag)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001994">a_Int_ag</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(ag,1))</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分したデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ag  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in)入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元格子点データが並んだ 2 次元配列の積分
</p>
<pre>
     \int_0^a f(R) W(R) dR, W(R) = R^beta/(a^2-R^2)^(1-alpha)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001994-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001994-source">
<pre>
  function a_Int_ag(ag)
    !
    ! 1 次元格子点データが並んだ 2 次元配列の積分
    !
    !      \int_0^a f(R) W(R) dR, W(R) = R^beta/(a^2-R^2)^(1-alpha)
    !
    ! を計算する. 
    !
    real(8), dimension(:,:), intent(in)      :: ag
    !(in)入力格子点データ

    real(8), dimension(size(ag,1))           :: a_Int_ag
    !(out) 積分したデータ
    integer :: i

    if ( size(ag,2) &lt; im ) then
       call MessageNotify('E','a_Int_ag', 'The Grid points of input data too small.')
    elseif ( size(ag,2) &gt; im ) then
       call MessageNotify('W','a_Int_ag', 'The Grid points of input data too large.')
    endif

    a_Int_ag = 0.0d0
    do i=1,im
       a_Int_ag(:) = a_Int_ag(:) + ag(:,i)*g_R_Weight(i)
    enddo
  end function a_Int_ag
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002007" class="method-detail">
        <a name="M002007"></a>

        <div class="method-heading">


          <a href="#M002007" class="method-signature">



          <span class="method-name">ag_BoundaryGrid_D</span><span class="method-args">( ag_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>ag_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(jmax,im)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(jmax)

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(選点法, 2 次元配列用)
</p>
<ul>
<li>外側境界(i=im)での値を与える.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002007-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002007-source">
<pre>
  subroutine ag_BoundaryGrid_D_2d(ag_data,value)
    !
    ! Dirichlet 型境界条件の適用(選点法, 2 次元配列用)
    ! * 外側境界(i=im)での値を与える.
    !
    real(8), dimension(:,:),intent(inout)         :: ag_data
    !(inout) 境界条件を適用するチェビシェフデータ(jmax,im)

    real(8), dimension(:), intent(in), optional  :: value
    !(in) 境界値(jmax)

    real(8), dimension(size(ag_data,1))       :: value0 

    if (.not. present(value)) then
       value0=0.0d0
    else
       value0 = value
    endif
    ag_data(:,im) = value0

  end subroutine ag_BoundaryGrid_D_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002006" class="method-detail">
        <a name="M002006"></a>

        <div class="method-heading">


          <a href="#M002006" class="method-signature">



          <span class="method-name">ag_BoundaryGrid_D</span><span class="method-args">( g_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>g_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(im),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(im)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
</p>
<ul>
<li>両境界での値を与える.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002006-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002006-source">
<pre>
  subroutine ag_BoundaryGrid_D_1d(g_data,value)
    !
    ! Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
    ! * 両境界での値を与える.
    !
    real(8), dimension(im),intent(inout)       :: g_data
    !(inout) 境界条件を適用するチェビシェフデータ(im)

    real(8), intent(in), optional              :: value
    !(in) 境界値

    real(8), dimension(1,im)                   :: ag_work
    real(8), dimension(1)                      :: vwork

    if (.not. present(value)) then
       vwork(1)=0.0d0
    else
       vwork(1) = value
    endif

    ag_work(1,:)=g_data
    call ag_BoundaryGrid_D_2d(ag_work,vwork)
    g_data=ag_work(1,:)

  end subroutine ag_BoundaryGrid_D_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002009" class="method-detail">
        <a name="M002009"></a>

        <div class="method-heading">


          <a href="#M002009" class="method-signature">



          <span class="method-name">ag_BoundaryGrid_N</span><span class="method-args">( ag_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>ag_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,im)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m)

</td></tr>
</table>
</td></tr>
</table>
<p>
外側境界 Neumann 型境界条件の適用(選点法, 2 次元配列用)
</p>
<ul>
<li>i=im で勾配の値を与える.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002009-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002009-source">
<pre>
  subroutine ag_BoundaryGrid_N_2d(ag_data,value)
    !
    ! 外側境界 Neumann 型境界条件の適用(選点法, 2 次元配列用)
    ! * i=im で勾配の値を与える.
    !
    real(8), dimension(:,:),intent(inout)         :: ag_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,im)

    real(8), dimension(:), intent(in), optional    :: value
    !(in) 境界値(m)

    real(8), dimension(:,:,:), allocatable    :: alu
    integer, dimension(:,:), allocatable      :: kp
    real(8), dimension(size(ag_data,1),im)    :: ag_work
    real(8), dimension(size(ag_data,1))       :: value0           ! 境界値

    integer :: i
    save    :: alu, kp

    if ( size(ag_data,2) &lt; im ) then
       call MessageNotify('E','aq_BoundaryGrid_N', 'The dimension of input data too small.')
    elseif ( size(ag_data,2) &gt; im ) then
       call MessageNotify('W','aq_BoundaryGrid_N', 'The dimension of input data too large.')
    endif

    if (.not. present(value)) then
       value0=0.0D0
    else
       value0 = value
    endif

    if ( first_Grid_N ) then
       first_Grid_N = .false.
       allocate(alu(jmax,im,im),kp(jmax,im))

       alu=0.0D0
       do i=1,im
          alu(:,i,i) = 1.0D0
       enddo

       do i=1,im
          ag_work = 0.0D0
          ag_work(:,i) = 1.0D0
          ag_work = ag_aq(aq_rDr_aq(aq_ag(ag_work)))/spread(g_R,1,jmax)
          alu(:,im,i) = ag_work(:,im)
       enddo

       call ludecomp(alu,kp)
    endif

    ag_data(:,im) = value0

    ag_data = lusolve(alu,kp,ag_data)

  end subroutine ag_BoundaryGrid_N_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002008" class="method-detail">
        <a name="M002008"></a>

        <div class="method-heading">


          <a href="#M002008" class="method-signature">



          <span class="method-name">ag_BoundaryGrid_N</span><span class="method-args">( g_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>g_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(im),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet/Neumann 型境界条件の適用(選点法, 1 次元配列用)
</p>
<ul>
<li>i=0 で勾配の値を与える.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002008-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002008-source">
<pre>
  subroutine ag_BoundaryGrid_N_1d(g_data,value)
    !
    ! Dirichlet/Neumann 型境界条件の適用(選点法, 1 次元配列用)
    ! * i=0 で勾配の値を与える.
    !
    real(8), dimension(im),intent(inout)       :: g_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), intent(in), optional                :: value
    !(in) 境界値

    real(8), dimension(1,im)                   :: ag_work
    real(8), dimension(1)                        :: vwork           ! 境界値

    if (.not. present(value)) then
       vwork(1)=0.0D0
    else
       vwork(1) = value
    endif

    ag_work(1,:)=g_data
    call ag_BoundaryGrid_N_2d(ag_work,vwork)
    g_data=ag_work(1,:)

  end subroutine ag_BoundaryGrid_N_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001984" class="method-detail">
        <a name="M001984"></a>

        <div class="method-heading">


          <a href="#M001984" class="method-signature">



          <span class="method-name">ag_aq</span><span class="method-args">( aq_data ) result(ag_aq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001984">ag_aq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(aq_data,1),im)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子データへ変換する(2 次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001984-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001984-source">
<pre>
  function ag_aq(aq_data)
    !
    ! スペクトルデータから格子データへ変換する(2 次元配列用).
    !
    real(8), dimension(:,0:), intent(in)    :: aq_data
    !(in) スペクトルデータ

    real(8), dimension(size(aq_data,1),im)  :: ag_aq
    !(out) 格子点データ

    integer :: i, j

    if ( size(aq_data,1) /= jmax ) then
       call MessageNotify('E','ag_aq', '1st dim. of the spectral data should be same as dim. of MD.')
    end if

    if ( size(aq_data,2)-1 &lt; km ) then
       call MessageNotify('E','ag_aq', 'The spectral dimension of input data too small.')
    elseif ( size(aq_data,2)-1 &gt; km ) then
       call MessageNotify('W','ag_aq', 'The spectral dimension of input data too large.')
    endif

    ag_aq = 0.0D0
    do i=1,im
!$omp parallel do
       do j=1,jmax
             ag_aq(j,i) = sum(CB(j,i,md(j):km:2)*aq_data(j,md(j):km:2))
       enddo
!$omp end parallel do
    enddo

  end function ag_aq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002003" class="method-detail">
        <a name="M002003"></a>

        <div class="method-heading">


          <a href="#M002003" class="method-signature">



          <span class="method-name">aq_BoundaryTau_D</span><span class="method-args">( aq_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(jmax,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(jmax)

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
</p>
<ul>
<li>外側境界(i=im)での値を与える.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002003-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002003-source">
<pre>
  subroutine aq_BoundaryTau_D_2d(aq_data,value)
    !
    ! Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
    ! * 外側境界(i=im)での値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: aq_data 
    !(inout) 境界条件を適用するチェビシェフデータ(jmax,0:km)

    real(8), dimension(:), intent(in), optional  :: value
    !(in) 境界値(jmax)

    real(8), dimension(:,:,:), allocatable  :: alu
    integer, dimension(:,:), allocatable    :: kp
    real(8), dimension(size(aq_data,1),0:km):: aq_work
    real(8), dimension(size(aq_data,1),im)  :: ag_work
    real(8), dimension(size(aq_data,1))     :: value0           ! 境界値

    integer :: k, j, kstr, kend
    save    :: alu, kp

    if ( size(aq_data,2)-1 &lt; km ) then
       call MessageNotify('E','aq_BoundaryTau_D', 'The spectral dimension of input data too small.')
    elseif ( size(aq_data,2)-1 &gt; km ) then
       call MessageNotify('W','aq_BoundaryTau_D', 'The spectral dimension of input data too large.')
    endif

    if (.not. present(value)) then
       value0=0.0D0
    else
       value0 = value
    endif

    if ( first_Tau_D ) then
       first_Tau_D = .false.

       allocate(alu(size(aq_data,1),0:km,0:km),kp(size(aq_data,1),0:km))

       alu=0.0D0
       do k=0,km
          alu(:,k,k) = 1.0D0
       enddo

       do j=1,jmax
          if ( mod(md(j),2) .eq. mod(km,2) ) then
             kstr = md(j) 
              kend = km
          else
             kstr = md(j) 
              kend = km-1
          endif

          do k=kstr,kend,2
             aq_work = 0.0D0
             aq_work(j,k) = 1.0D0
             ag_work = ag_aq(aq_work)
             alu(j,kend,k) = ag_work(j,im)
          enddo
       enddo

       call ludecomp(alu,kp)
    endif

    do j=1,jmax
       if ( mod(md(j),2) .eq. mod(km,2) ) then
          aq_data(j,km)   = value0(j)
       else
          aq_data(j,km-1)   = value0(j)
       endif
    enddo

    aq_data = lusolve(alu,kp,aq_data)

  end subroutine aq_BoundaryTau_D_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002002" class="method-detail">
        <a name="M002002"></a>

        <div class="method-heading">


          <a href="#M002002" class="method-signature">



          <span class="method-name">aq_BoundaryTau_D</span><span class="method-args">( q_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
</p>
<ul>
<li>両境界での値を与える.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002002-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002002-source">
<pre>
  subroutine aq_BoundaryTau_D_1d(q_data,value)
    !
    ! Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
    ! * 両境界での値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: q_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), intent(in), optional                :: value
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: aq_work
    real(8), dimension(1)                        :: vwork  ! 境界値

    if (.not. present(value)) then
       vwork(1)=0.0D0
    else
       vwork(1) = value
    endif

    aq_work(1,:)=q_data
    call aq_BoundaryTau_D_2d(aq_work,vwork)
    q_data=aq_work(1,:)

  end subroutine aq_BoundaryTau_D_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002005" class="method-detail">
        <a name="M002005"></a>

        <div class="method-heading">


          <a href="#M002005" class="method-signature">



          <span class="method-name">aq_BoundaryTau_N</span><span class="method-args">( aq_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m)

</td></tr>
</table>
</td></tr>
</table>
<p>
外側境界 Neumann 型境界条件の適用(タウ法, 2 次元配列用)
</p>
<ul>
<li>i=im で勾配の値を与える.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002005-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002005-source">
<pre>
  subroutine aq_BoundaryTau_N_2d(aq_data,value)
    !
    ! 外側境界 Neumann 型境界条件の適用(タウ法, 2 次元配列用)
    ! * i=im で勾配の値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: aq_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:), intent(in), optional    :: value
    !(in) 境界値(m)

    real(8), dimension(:,:,:), allocatable    :: alu
    integer, dimension(:,:), allocatable      :: kp
    real(8), dimension(size(aq_data,1),0:km)  :: aq_work
    real(8), dimension(size(aq_data,1),im)    :: ag_work
    real(8), dimension(size(aq_data,1))       :: value0           ! 境界値

    integer :: j, k, kstr, kend

    save    :: alu, kp

    if ( size(aq_data,2)-1 &lt; km ) then
       call MessageNotify('E','aq_BoundaryTau_N', 'The spectral dimension of input data too small.')
    elseif ( size(aq_data,2)-1 &gt; km ) then
       call MessageNotify('W','aq_BoundaryTau_N', 'The spectral dimension of input data too large.')
    endif

    if (.not. present(value)) then
       value0=0.0D0
    else
       value0 = value
    endif

    if ( first_Tau_N ) then
       first_Tau_N = .false.
       allocate(alu(jmax,0:km,0:km),kp(jmax,0:km))

       alu=0.0D0
       do k=0,km
          alu(:,k,k) = 1.0D0
       enddo

       do j=1,jmax
          if ( mod(md(j),2) .eq. mod(km,2) ) then
             kstr=md(j) 
              kend = km
          else
             kstr=md(j) 
              kend = km-1
          endif

          do k=kstr,kend,2
             aq_work = 0.0D0
             aq_work(j,k) = 1.0D0
             ag_work = ag_aq(aq_rDr_aq(aq_work))/spread(g_R,1,jmax)
             alu(j,kend,k) = ag_work(j,im)
          enddo
       enddo

       call ludecomp(alu,kp)
    endif

    do j=1,jmax
       if ( mod(md(j),2) .eq. mod(km,2) ) then
          aq_data(j,km)   = value0(j)
       else
          aq_data(j,km-1)   = value0(j)
       endif
    enddo

    aq_data = lusolve(alu,kp,aq_data)

  end subroutine aq_BoundaryTau_N_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002004" class="method-detail">
        <a name="M002004"></a>

        <div class="method-heading">


          <a href="#M002004" class="method-signature">



          <span class="method-name">aq_BoundaryTau_N</span><span class="method-args">( q_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet/Neumann 型境界条件の適用(タウ法, 1 次元配列用)
</p>
<ul>
<li>i=0 で勾配の値を与える.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002004-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002004-source">
<pre>
  subroutine aq_BoundaryTau_N_1d(q_data,value)
    !
    ! Dirichlet/Neumann 型境界条件の適用(タウ法, 1 次元配列用)
    ! * i=0 で勾配の値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: q_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), intent(in), optional                :: value
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: aq_work
    real(8), dimension(1)                        :: vwork           ! 境界値

    if (.not. present(value)) then
       vwork(1)=0.0D0
    else
       vwork(1) = value
    endif

    aq_work(1,:)=q_data
    call aq_BoundaryTau_N_2d(aq_work,vwork)
    q_data=aq_work(1,:)

  end subroutine aq_BoundaryTau_N_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001999" class="method-detail">
        <a name="M001999"></a>

        <div class="method-heading">


          <a href="#M001999" class="method-signature">



          <span class="method-name">aq_Boundary_D</span><span class="method-args">( aq_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(jmax,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(jmax)

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
</p>
<ul>
<li>外側境界(i=im)での値を与える.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001999-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001999-source">
<pre>
  subroutine aq_BoundaryTau_D_2d(aq_data,value)
    !
    ! Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
    ! * 外側境界(i=im)での値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: aq_data 
    !(inout) 境界条件を適用するチェビシェフデータ(jmax,0:km)

    real(8), dimension(:), intent(in), optional  :: value
    !(in) 境界値(jmax)

    real(8), dimension(:,:,:), allocatable  :: alu
    integer, dimension(:,:), allocatable    :: kp
    real(8), dimension(size(aq_data,1),0:km):: aq_work
    real(8), dimension(size(aq_data,1),im)  :: ag_work
    real(8), dimension(size(aq_data,1))     :: value0           ! 境界値

    integer :: k, j, kstr, kend
    save    :: alu, kp

    if ( size(aq_data,2)-1 &lt; km ) then
       call MessageNotify('E','aq_BoundaryTau_D', 'The spectral dimension of input data too small.')
    elseif ( size(aq_data,2)-1 &gt; km ) then
       call MessageNotify('W','aq_BoundaryTau_D', 'The spectral dimension of input data too large.')
    endif

    if (.not. present(value)) then
       value0=0.0D0
    else
       value0 = value
    endif

    if ( first_Tau_D ) then
       first_Tau_D = .false.

       allocate(alu(size(aq_data,1),0:km,0:km),kp(size(aq_data,1),0:km))

       alu=0.0D0
       do k=0,km
          alu(:,k,k) = 1.0D0
       enddo

       do j=1,jmax
          if ( mod(md(j),2) .eq. mod(km,2) ) then
             kstr = md(j) 
              kend = km
          else
             kstr = md(j) 
              kend = km-1
          endif

          do k=kstr,kend,2
             aq_work = 0.0D0
             aq_work(j,k) = 1.0D0
             ag_work = ag_aq(aq_work)
             alu(j,kend,k) = ag_work(j,im)
          enddo
       enddo

       call ludecomp(alu,kp)
    endif

    do j=1,jmax
       if ( mod(md(j),2) .eq. mod(km,2) ) then
          aq_data(j,km)   = value0(j)
       else
          aq_data(j,km-1)   = value0(j)
       endif
    enddo

    aq_data = lusolve(alu,kp,aq_data)

  end subroutine aq_BoundaryTau_D_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001998" class="method-detail">
        <a name="M001998"></a>

        <div class="method-heading">


          <a href="#M001998" class="method-signature">



          <span class="method-name">aq_Boundary_D</span><span class="method-args">( q_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
</p>
<ul>
<li>両境界での値を与える.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001998-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001998-source">
<pre>
  subroutine aq_BoundaryTau_D_1d(q_data,value)
    !
    ! Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
    ! * 両境界での値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: q_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), intent(in), optional                :: value
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: aq_work
    real(8), dimension(1)                        :: vwork  ! 境界値

    if (.not. present(value)) then
       vwork(1)=0.0D0
    else
       vwork(1) = value
    endif

    aq_work(1,:)=q_data
    call aq_BoundaryTau_D_2d(aq_work,vwork)
    q_data=aq_work(1,:)

  end subroutine aq_BoundaryTau_D_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002001" class="method-detail">
        <a name="M002001"></a>

        <div class="method-heading">


          <a href="#M002001" class="method-signature">



          <span class="method-name">aq_Boundary_N</span><span class="method-args">( aq_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m)

</td></tr>
</table>
</td></tr>
</table>
<p>
外側境界 Neumann 型境界条件の適用(タウ法, 2 次元配列用)
</p>
<ul>
<li>i=im で勾配の値を与える.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002001-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002001-source">
<pre>
  subroutine aq_BoundaryTau_N_2d(aq_data,value)
    !
    ! 外側境界 Neumann 型境界条件の適用(タウ法, 2 次元配列用)
    ! * i=im で勾配の値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: aq_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:), intent(in), optional    :: value
    !(in) 境界値(m)

    real(8), dimension(:,:,:), allocatable    :: alu
    integer, dimension(:,:), allocatable      :: kp
    real(8), dimension(size(aq_data,1),0:km)  :: aq_work
    real(8), dimension(size(aq_data,1),im)    :: ag_work
    real(8), dimension(size(aq_data,1))       :: value0           ! 境界値

    integer :: j, k, kstr, kend

    save    :: alu, kp

    if ( size(aq_data,2)-1 &lt; km ) then
       call MessageNotify('E','aq_BoundaryTau_N', 'The spectral dimension of input data too small.')
    elseif ( size(aq_data,2)-1 &gt; km ) then
       call MessageNotify('W','aq_BoundaryTau_N', 'The spectral dimension of input data too large.')
    endif

    if (.not. present(value)) then
       value0=0.0D0
    else
       value0 = value
    endif

    if ( first_Tau_N ) then
       first_Tau_N = .false.
       allocate(alu(jmax,0:km,0:km),kp(jmax,0:km))

       alu=0.0D0
       do k=0,km
          alu(:,k,k) = 1.0D0
       enddo

       do j=1,jmax
          if ( mod(md(j),2) .eq. mod(km,2) ) then
             kstr=md(j) 
              kend = km
          else
             kstr=md(j) 
              kend = km-1
          endif

          do k=kstr,kend,2
             aq_work = 0.0D0
             aq_work(j,k) = 1.0D0
             ag_work = ag_aq(aq_rDr_aq(aq_work))/spread(g_R,1,jmax)
             alu(j,kend,k) = ag_work(j,im)
          enddo
       enddo

       call ludecomp(alu,kp)
    endif

    do j=1,jmax
       if ( mod(md(j),2) .eq. mod(km,2) ) then
          aq_data(j,km)   = value0(j)
       else
          aq_data(j,km-1)   = value0(j)
       endif
    enddo

    aq_data = lusolve(alu,kp,aq_data)

  end subroutine aq_BoundaryTau_N_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002000" class="method-detail">
        <a name="M002000"></a>

        <div class="method-heading">


          <a href="#M002000" class="method-signature">



          <span class="method-name">aq_Boundary_N</span><span class="method-args">( q_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet/Neumann 型境界条件の適用(タウ法, 1 次元配列用)
</p>
<ul>
<li>i=0 で勾配の値を与える.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002000-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002000-source">
<pre>
  subroutine aq_BoundaryTau_N_1d(q_data,value)
    !
    ! Dirichlet/Neumann 型境界条件の適用(タウ法, 1 次元配列用)
    ! * i=0 で勾配の値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: q_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), intent(in), optional                :: value
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: aq_work
    real(8), dimension(1)                        :: vwork           ! 境界値

    if (.not. present(value)) then
       vwork(1)=0.0D0
    else
       vwork(1) = value
    endif

    aq_work(1,:)=q_data
    call aq_BoundaryTau_N_2d(aq_work,vwork)
    q_data=aq_work(1,:)

  end subroutine aq_BoundaryTau_N_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001983" class="method-detail">
        <a name="M001983"></a>

        <div class="method-heading">


          <a href="#M001983" class="method-signature">



          <span class="method-name">aq_Initial</span><span class="method-args">( i_in, k_in, r_in, alpha_in, beta_in, md_in ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>i_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>k_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 切断波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>r_in  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 外側境界の座標(半径)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>alpha_in  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 展開多項式パラメター

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>beta_in  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 展開多項式パラメター

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>md_in(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 展開多項式上付次数のならび

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル変換の格子点数, 波数, 領域の大きさ, 重みを設定する.
</p>
<p>
他の関数や変数を呼ぶ前に, 最初にこのサブルーチンを呼んで
初期設定をしなければならない.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001983-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001983-source">
<pre>
  subroutine aq_Initial(i_in,k_in,r_in,alpha_in,beta_in,md_in)
    !
    ! スペクトル変換の格子点数, 波数, 領域の大きさ, 重みを設定する.
    ! 
    ! 他の関数や変数を呼ぶ前に, 最初にこのサブルーチンを呼んで
    ! 初期設定をしなければならない.
    !
    integer,intent(in) :: i_in              !(in) 格子点数
    integer,intent(in) :: k_in              !(in) 切断波数
    real(8),intent(in) :: r_in              !(in) 外側境界の座標(半径)
    real(8),intent(in) :: alpha_in          !(in) 展開多項式パラメター
    real(8),intent(in) :: beta_in           !(in) 展開多項式パラメター 
    integer,intent(in) :: md_in(:)          !(in) 展開多項式上付次数のならび

    integer i, j, n

   !--- パラメターのチェック・記憶
    im=i_in 
     km=k_in 
     ra = r_in
     alpha=alpha_in
     beta=beta_in

    if ( km .ge. 2*im ) then
       call MessageNotify('E','aq_initial','KM shoud be less than 2*IM')
    endif

    if ( alpha .le. 0.0D0 ) then
       call MessageNotify('E','aq_initial','alpha must be larger than 0')
    endif
    if ( alpha .gt. 1.0D0 ) then
       call MessageNotify('E','aq_initial','alpha must be smaller equal to 1')
    endif
    if ( beta .le. 0.0D0 ) then
       call MessageNotify('E','aq_initial','beta must be larger than 0')
    endif

    gamma = 2.0D0 * alpha + beta

   !--- 次数情報の計算
    jmax = size(md_in)
    if ( allocated(md) ) deallocate(md)
    allocate(md(jmax))

    md = md_in

   !--- 格子点, 重みの設定
    if ( allocated(g_R) ) deallocate(g_R)
    if ( allocated(g_R_Weight) ) deallocate(g_R_Weight)
    allocate(g_R(im),g_R_Weight(im))

    call gauss_radau(2*im, g_R, g_R_Weight)
    g_R = ra * g_R
    g_R_Weight = ra**(gamma-1) * g_R_Weight

   !--- 変換行列の設定
    if ( allocated(CF) ) deallocate(CF)
    if ( allocated(CB) ) deallocate(CB)
    allocate(CF(jmax,0:km,im),CB(jmax,im,0:km))

    CF = 0.0D0
    do j=1,jmax
       do n=md(j),km,2
          do i=1,im
             CF(j,n,i) = Phi(g_R(i)/ra,n,md(j)) * g_R_Weight(i)/ra**(gamma-1)
          enddo
       enddo
    enddo

    CB = 0.0D0
    do j=1,jmax
       do i=1,im
          do n=md(j),km,2
             CB(j,i,n) = Phi(g_R(i)/ra,n,md(j)) 
          enddo
       enddo
    enddo

   !--- 各ルーチン変換行列の初期化スイッチ

    first_r2inv  = .true.
    first_Tau_D  = .true.
    first_Tau_N  = .true. 
    first_Grid_N = .true.

    call MessageNotify( 'M','aq_initial','aq_module (2009/01/09) is initialized')

  end subroutine aq_Initial
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001986" class="method-detail">
        <a name="M001986"></a>

        <div class="method-heading">


          <a href="#M001986" class="method-signature">



          <span class="method-name">aq_ag</span><span class="method-args">( ag_data ) result(aq_ag)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001986">aq_ag</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(ag_data,1),0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ag_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからスペクトルデータへ変換する(2 次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001986-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001986-source">
<pre>
  function aq_ag(ag_data)
    !
    ! 格子データからスペクトルデータへ変換する(2 次元配列用).
    !
    real(8), dimension(:,:), intent(in)      :: ag_data
    !(in) 格子点データ

    real(8), dimension(size(ag_data,1),0:km) :: aq_ag
    !(out) スペクトルデータ

    integer :: j, n

    if ( size(ag_data,1) /= jmax ) then
       call MessageNotify('E','aq_ag', '1st dim. of the grid data should be same as dim. of MD.')
    end if

    if ( size(ag_data,2) &lt; im ) then
       call MessageNotify('E','aq_ag', 'The Grid points of input data too small.')
    elseif ( size(ag_data,2) &gt; im ) then
       call MessageNotify('W','aq_ag', 'The Grid points of input data too large.')
    endif

    aq_ag = 0.0D0
!$omp parallel do private(n)
    do j=1,jmax
       do n=md(j),km,2
          aq_ag(j,n) = sum(CF(j,n,:)*ag_data(j,:))
       enddo
    enddo
!$omp end parallel do          

  end function aq_ag
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001992" class="method-detail">
        <a name="M001992"></a>

        <div class="method-heading">


          <a href="#M001992" class="method-signature">



          <span class="method-name">aq_r2Inv_aq</span><span class="method-args">( aq_data ) result(aq_r2Inv_aq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001992">aq_r2Inv_aq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(aq_data,1),0:size(aq_data,2)-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 出力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに対して積 r^-2 のスペクトル係数 を計算する(2
次元配列用).
</p>
<pre>
  a_n^m = aq_r2Inv_aq/sqrt(Inm),  b_n^m = aq_data/sqrt(Inm)

  b_n^m = (n-|m|)(n+|m|+beta-1)/((2n+gamma-5)(2n+gamma-3)) a_n-2^m
      + (2n(n+gamma-1) + 2|m|(|m|+beta-1)+(gamma-3)(beta+1)
           /((2n+gamma+1)(2n+gamma-3)) a_n^m
      + (n-|m|+gamma-beta)(n+|m|+gamma-1)
           /((2n+gamma+3)(2n+gamma+1)) a_n+2^m
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001992-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001992-source">
<pre>
  function aq_r2Inv_aq(aq_data)
    !
    ! 入力スペクトルデータに対して積 r^-2 のスペクトル係数
    ! を計算する(2 次元配列用).
    !
    !   a_n^m = aq_r2Inv_aq/sqrt(Inm),  b_n^m = aq_data/sqrt(Inm)
    !
    !   b_n^m = (n-|m|)(n+|m|+beta-1)/((2n+gamma-5)(2n+gamma-3)) a_n-2^m
    !       + (2n(n+gamma-1) + 2|m|(|m|+beta-1)+(gamma-3)(beta+1)
    !            /((2n+gamma+1)(2n+gamma-3)) a_n^m
    !       + (n-|m|+gamma-beta)(n+|m|+gamma-1)
    !            /((2n+gamma+3)(2n+gamma+1)) a_n+2^m
    !
    real(8), dimension(:,0:), intent(in)     :: aq_data
    !(in) 入力スペクトルデータ

    real(8), dimension(size(aq_data,1),0:size(aq_data,2)-1) :: aq_r2Inv_aq
    !(out) 出力スペクトルデータ

    real(8), dimension(:,:,:), allocatable    :: R2MTX
    integer, dimension(:,:), allocatable      :: kp

    integer :: j, n, m
    integer :: nstr, nend
    real(8) :: sqrInp2m, sqrInm, sqrInm2m

    save R2MTX, kp

    if ( size(aq_data,1) /= jmax ) then
       call MessageNotify('E','aq_r2Inv_aq', '1st dim. of the spectral data should be same as dim. of MD.')
    end if

    if ( size(aq_data,2)-1 &lt; km ) then
       call MessageNotify('E','aq_r2Inv_aq', 'The spectral dimension of input data too small.')
    elseif ( size(aq_data,2)-1 &gt; km ) then
       call MessageNotify('W','aq_r2Inv_aq', 'The spectral dimension of input data too large.')
    endif

    if ( first_r2inv ) then
       first_r2inv = .false.
       if ( allocated(R2MTX) ) deallocate(R2MTX)
       if ( allocated(kp) ) deallocate(kp)
       allocate(R2MTX(jmax,0:km,0:km),kp(jmax,0:km))

       R2MTX(:,:,:) = 0.0D0
       do n=0,km
          R2MTX(:,n,n) = 1.0D0
       enddo

!$omp parallel do private(nstr,nend,sqrInm,sqrInm2m,sqrInp2m,n,m)
       do j=1,jmax
          if ( mod(md(j),2) .eq. mod(km,2) ) then
             nstr=md(j) 
              nend=km
          else
             nstr=md(j) 
              nend=km-1
          endif

          m = abs(md(j))

          n = nstr

          sqrInm   = sqrt(Inm(n,m))
          sqrInp2m = sqrt(Inm(n+2,m))

          R2MTX(j,n,n)   = (2*n*(n+gamma-1) + 2*m*(m+beta-1)+(gamma-3)*(beta+1)) /((2*n+gamma+1)*(2*n+gamma-3))
          
          R2MTX(j,n,n+2) = (n-m+gamma-beta)*(n+m+gamma-1) /((2*n+gamma+3)*(2*n+gamma+1)) * (sqrInm/sqrInp2m)

          do n=nstr+2,nend-2,2
             sqrInm2m = sqrInm
             sqrInm   = sqrInp2m
             sqrInp2m = sqrt(Inm(n+2,m))

             R2MTX(j,n,n-2) = (n-m)*(n+m+beta-1)/((2*n+gamma-5)*(2*n+gamma-3)) *(sqrInm/sqrInm2m)

             R2MTX(j,n,n)   = (2*n*(n+gamma-1) + 2*m*(m+beta-1)+(gamma-3)*(beta+1)) /((2*n+gamma+1)*(2*n+gamma-3))

             R2MTX(j,n,n+2) = (n-m+gamma-beta)*(n+m+gamma-1) /((2*n+gamma+3)*(2*n+gamma+1)) * (sqrInm/sqrInp2m)
          enddo

          n = nend
          sqrInm2m = sqrInm
          sqrInm   = sqrInp2m
             R2MTX(j,n,n-2) = (n-m)*(n+m+beta-1)/((2*n+gamma-5)*(2*n+gamma-3)) *(sqrInm/sqrInm2m)
             R2MTX(j,n,n)   = (2*n*(n+gamma-1) + 2*m*(m+beta-1)+(gamma-3)*(beta+1)) /((2*n+gamma+1)*(2*n+gamma-3))
       enddo
!$omp end parallel do

       R2MTX = R2MTX * ra**2

       call LuDecomp(R2MTX,kp)

    end if

    aq_r2Inv_aq = LuSolve(R2MTX,kp,aq_data)
    
  end function aq_r2Inv_aq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001990" class="method-detail">
        <a name="M001990"></a>

        <div class="method-heading">


          <a href="#M001990" class="method-signature">



          <span class="method-name">aq_r2_aq</span><span class="method-args">( aq_data ) result(aq_r2_aq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001990">aq_r2_aq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(aq_data,1),0:size(aq_data,2)-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 出力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに対して積 r^2 のスペクトル係数 を計算する(2
次元配列用).
</p>
<pre>
  a_n^m = aq_data/sqrt(Inm),  b_n^m = aq_rDr_aq/sqrt(Inm)

  b_n^m = (n-|m|)(n+|m|+beta-1)/((2n+gamma-5)(2n+gamma-3)) a_n-2^m
      + (2n(n+gamma-1) + 2|m|(|m|+beta-1)+(gamma-3)(beta+1)
           /((2n+gamma+1)(2n+gamma-3)) a_n^m
      + (n-|m|+gamma-beta)(n+|m|+gamma-1)
           /((2n+gamma+3)(2n+gamma+1)) a_n+2^m
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001990-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001990-source">
<pre>
  function aq_r2_aq(aq_data)
    !
    ! 入力スペクトルデータに対して積 r^2 のスペクトル係数
    ! を計算する(2 次元配列用).
    !
    !   a_n^m = aq_data/sqrt(Inm),  b_n^m = aq_rDr_aq/sqrt(Inm)
    !
    !   b_n^m = (n-|m|)(n+|m|+beta-1)/((2n+gamma-5)(2n+gamma-3)) a_n-2^m
    !       + (2n(n+gamma-1) + 2|m|(|m|+beta-1)+(gamma-3)(beta+1)
    !            /((2n+gamma+1)(2n+gamma-3)) a_n^m
    !       + (n-|m|+gamma-beta)(n+|m|+gamma-1)
    !            /((2n+gamma+3)(2n+gamma+1)) a_n+2^m
    !
    real(8), dimension(:,0:), intent(in)     :: aq_data
    !(in) 入力スペクトルデータ

    real(8), dimension(size(aq_data,1),0:size(aq_data,2)-1) :: aq_r2_aq
    !(out) 出力スペクトルデータ

    integer :: j, n, m
    integer :: nstr, nend
    real(8) :: sqrInp2m, sqrInm, sqrInm2m

    if ( size(aq_data,1) /= jmax ) then
       call MessageNotify('E','aq_r2_aq', '1st dim. of the spectral data should be same as dim. of MD.')
    end if

    if ( size(aq_data,2)-1 &lt; km ) then
       call MessageNotify('E','aq_r2_aq', 'The spectral dimension of input data too small.')
    elseif ( size(aq_data,2)-1 &gt; km ) then
       call MessageNotify('W','aq_r2_aq', 'The spectral dimension of input data too large.')
    endif

    aq_r2_aq = 0.0D0

!$omp parallel do private(nstr,nend,sqrInm,sqrInm2m,sqrInp2m,n,m)
    do j=1,jmax
       if ( mod(md(j),2) .eq. mod(km,2) ) then
          nstr=md(j) 
           nend=km
       else
          nstr=md(j) 
           nend=km-1
       endif

       m = abs(md(j))

       n = nstr
       sqrInm   = sqrt(Inm(n,m))
       sqrInp2m = sqrt(Inm(n+2,m))
       aq_r2_aq(j,n) = (2*n*(n+gamma-1) + 2*m*(m+beta-1)+(gamma-3)*(beta+1)) /((2*n+gamma+1)*(2*n+gamma-3)) * aq_data(j,n) + (n-m+gamma-beta)*(n+m+gamma-1) /((2*n+gamma+3)*(2*n+gamma+1)) * aq_data(j,n+2) * (sqrInm/sqrInp2m)

       do n=nstr+2,nend-2,2
          sqrInm2m = sqrInm
          sqrInm   = sqrInp2m
          sqrInp2m = sqrt(Inm(n+2,m))

          aq_r2_aq(j,n) = (n-m)*(n+m+beta-1)/((2*n+gamma-5)*(2*n+gamma-3)) * aq_data(j,n-2)* (sqrInm/sqrInm2m) + (2*n*(n+gamma-1) + 2*m*(m+beta-1)+(gamma-3)*(beta+1)) /((2*n+gamma+1)*(2*n+gamma-3)) * aq_data(j,n) + (n-m+gamma-beta)*(n+m+gamma-1) /((2*n+gamma+3)*(2*n+gamma+1)) * aq_data(j,n+2) * (sqrInm/sqrInp2m)
       enddo

       n = nend
       sqrInm2m = sqrInm
       sqrInm   = sqrInp2m
       aq_r2_aq(j,n) = (n-m)*(n+m+beta-1)/((2*n+gamma-5)*(2*n+gamma-3)) * aq_data(j,n-2)* (sqrInm/sqrInm2m) + (2*n*(n+gamma-1) + 2*m*(m+beta-1)+(gamma-3)*(beta+1)) /((2*n+gamma+1)*(2*n+gamma-3)) * aq_data(j,n)      
    enddo
!$omp end parallel do

    aq_r2_aq = aq_r2_aq * ra**2

  end function aq_r2_aq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001988" class="method-detail">
        <a name="M001988"></a>

        <div class="method-heading">


          <a href="#M001988" class="method-signature">



          <span class="method-name">aq_rDr_aq</span><span class="method-args">( aq_data ) result(aq_rDr_aq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001988">aq_rDr_aq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(aq_data,1),0:size(aq_data,2)-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 出力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに対して微分 r(d/dr) のスペクトル係数 を計算する(2
次元配列用).
</p>
<pre>
  a_n = aq_data/sqrt(Inm),  b_n = aq_rDr_aq/sqrt(Inm)

  b_n = (2n+gamma-1)/(2n+gamma+3)b_n+2
      + (2n+gamma-1)(n+gamma+1)/(2n+gamma+3)a_n+2 + n a_n
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001988-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001988-source">
<pre>
  function aq_rDr_aq(aq_data)
    !
    ! 入力スペクトルデータに対して微分 r(d/dr) のスペクトル係数
    ! を計算する(2 次元配列用).
    !
    !   a_n = aq_data/sqrt(Inm),  b_n = aq_rDr_aq/sqrt(Inm)
    !
    !   b_n = (2n+gamma-1)/(2n+gamma+3)b_n+2
    !       + (2n+gamma-1)(n+gamma+1)/(2n+gamma+3)a_n+2 + n a_n
    !
    real(8), dimension(:,0:), intent(in)     :: aq_data
    !(in) 入力スペクトルデータ

    real(8), dimension(size(aq_data,1),0:size(aq_data,2)-1) :: aq_rDr_aq
    !(out) 出力スペクトルデータ

    integer :: j, n
    integer :: nstr, nend
    real(8) :: sqInm, sqInm2

    if ( size(aq_data,1) /= jmax ) then
       call MessageNotify('E','aq_rDr_aq', '1st dim. of the spectral data should be same as dim. of MD.')
    end if

    if ( size(aq_data,2)-1 &lt; km ) then
       call MessageNotify('E','aq_rDr_aq', 'The spectral dimension of input data too small.')
    elseif ( size(aq_data,2)-1 &gt; km ) then
       call MessageNotify('W','aq_rDr_aq', 'The spectral dimension of input data too large.')
    endif

    aq_rDr_aq = 0.0D0
!$omp parallel do private(nstr,nend,sqInm,sqInm2,n)
    do j=1,jmax
       if ( mod(md(j),2) .eq. mod(km,2) ) then
          nstr=md(j) 
           nend=km
       else
          nstr=md(j) 
           nend=km-1
       endif
       
       sqInm = sqrt(Inm(nend,md(j)))
       aq_rDr_aq(j,nend) = nend * aq_data(j,nend)

       do n=nend-2,nstr,-2
          sqInm2 = sqInm
          sqInm = sqrt(Inm(n,md(j)))

          aq_rDr_aq(j,n) = sqInm/sqInm2 * ( (2*n+gamma-1)/(2*n+gamma+3) * aq_rDr_aq(j,n+2) + (2*n+gamma-1)*(n+gamma+1)/(2*n+gamma+3) * aq_data(j,n+2) ) + n * aq_data(j,n)
       enddo
    enddo
!$omp end parallel do

  end function aq_rDr_aq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001981" class="method-detail">
        <a name="M001981"></a>

        <div class="method-heading">




          <span class="method-name">g_R</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001981">g_R</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> ガウス&#8212;ラダウ格子点

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001982" class="method-detail">
        <a name="M001982"></a>

        <div class="method-heading">




          <span class="method-name">g_R_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001982">g_R_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> ガウス重み

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001985" class="method-detail">
        <a name="M001985"></a>

        <div class="method-heading">


          <a href="#M001985" class="method-signature">



          <span class="method-name">g_q</span><span class="method-args">( q_data ) result(g_q)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001985">g_q</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(im)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子データへ変換する(1 次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001985-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001985-source">
<pre>
  function g_q(q_data)
    !
    ! スペクトルデータから格子データへ変換する(1 次元配列用).
    !
    real(8), dimension(:), intent(in)  :: q_data
    !(in) スペクトルデータ

    real(8), dimension(im)             :: g_q
    !(out) 格子点データ

    real(8), dimension(1,size(q_data)) :: q_work
    ! 作業用配列
    real(8), dimension(1,im)         :: g_work
    ! 作業用配列

    q_work(1,:) = q_data  
    g_work = ag_aq(q_work)
    g_q = g_work(1,:)

  end function g_q
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001987" class="method-detail">
        <a name="M001987"></a>

        <div class="method-heading">


          <a href="#M001987" class="method-signature">



          <span class="method-name">q_g</span><span class="method-args">( g_data ) result(q_g)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001987">q_g</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>g_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからスペクトルデータへ変換する(1 次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001987-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001987-source">
<pre>
  function q_g(g_data)
    !
    ! 格子データからスペクトルデータへ変換する(1 次元配列用).
    !
    real(8), dimension(:), intent(in)     :: g_data
    !(in) 格子点データ

    real(8), dimension(0:km)              :: q_g
    !(out) スペクトルデータ

    real(8), dimension(1,size(g_data)) :: ag_work
    real(8), dimension(1,0:km)         :: aq_work

    ag_work(1,:) = g_data
    aq_work = aq_ag(ag_work)
    q_g = aq_work(1,:)
    
  end function q_g
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001993" class="method-detail">
        <a name="M001993"></a>

        <div class="method-heading">


          <a href="#M001993" class="method-signature">



          <span class="method-name">q_r2Inv_q</span><span class="method-args">( q_data ) result(q_r2Inv_q)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001993">q_r2Inv_q</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの R 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに対して積 r^2 のスペクトル係数 を計算する(1
次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001993-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001993-source">
<pre>
  function q_r2Inv_q(q_data)
    !
    ! 入力スペクトルデータに対して積 r^2 のスペクトル係数
    ! を計算する(1 次元配列用).
    !
    real(8), dimension(:), intent(in)   :: q_data
    !(in) 入力チェビシェフデータ

    real(8), dimension(0:km)            :: q_r2Inv_q
    !(out) チェビシェフデータの R 微分

    real(8), dimension(1,size(q_data))  :: aq_work
    ! 作業用配列

    aq_work(1,:) = q_data
    aq_work = aq_r2Inv_aq(aq_work)
    q_r2Inv_q = aq_work(1,:)

  end function q_r2Inv_q
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001991" class="method-detail">
        <a name="M001991"></a>

        <div class="method-heading">


          <a href="#M001991" class="method-signature">



          <span class="method-name">q_r2_q</span><span class="method-args">( q_data ) result(q_r2_q)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001991">q_r2_q</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの R 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに対して積 r^2 のスペクトル係数 を計算する(1
次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001991-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001991-source">
<pre>
  function q_r2_q(q_data)
    !
    ! 入力スペクトルデータに対して積 r^2 のスペクトル係数
    ! を計算する(1 次元配列用).
    !
    real(8), dimension(:), intent(in)   :: q_data
    !(in) 入力チェビシェフデータ

    real(8), dimension(0:km)            :: q_r2_q
    !(out) チェビシェフデータの R 微分

    real(8), dimension(1,size(q_data))  :: aq_work
    ! 作業用配列

    aq_work(1,:) = q_data
    aq_work = aq_r2_aq(aq_work)
    q_r2_q = aq_work(1,:)

  end function q_r2_q
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001989" class="method-detail">
        <a name="M001989"></a>

        <div class="method-heading">


          <a href="#M001989" class="method-signature">



          <span class="method-name">q_rDr_q</span><span class="method-args">( q_data ) result(q_rDr_q)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="aq_module.html#M001989">q_rDr_q</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの R 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに r(d/dR) 微分を作用する(1 次元配列用).
</p>
<p>
スペクトルデータの r(d/dR) 微分とは, 対応する格子点データに R 微分を
作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001989-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001989-source">
<pre>
  function q_rDr_q(q_data)
    !
    ! 入力スペクトルデータに r(d/dR) 微分を作用する(1 次元配列用).
    !
    ! スペクトルデータの r(d/dR) 微分とは, 対応する格子点データに R 微分を
    ! 作用させたデータのスペクトル変換のことである.
    !
    !
    real(8), dimension(:), intent(in)   :: q_data
    !(in) 入力チェビシェフデータ

    real(8), dimension(0:km)            :: q_rDr_q
    !(out) チェビシェフデータの R 微分

    real(8), dimension(1,size(q_data))  :: aq_work
    ! 作業用配列

    aq_work(1,:) = q_data
    aq_work = aq_rDr_aq(aq_work)
    q_rDr_q = aq_work(1,:)

  end function q_rDr_q
</pre>
          </div>

        </div>
      </div>



    </div>



  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
