<?xml version="1.0" encoding="euc-jp"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: eq_module</title>
  <meta http-equiv="Content-Type" content="text/html; charset=euc-jp" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">eq_module</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../files/src/eq_module_f90.html">

                src/eq_module.f90

                </a>


        <br />
            </td>
        </tr>


        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">


  <div id="contextContent">



    <div id="description">
      <h1><a href="eq_module.html">eq_module</a></h1>
<table>
<tr><td valign="top">Authors:</td><td>Shin-ichi Takehiro, Youhei SASAKI

</td></tr>
<tr><td valign="top">Version:</td><td>$Id: <a href="../files/src/eq_module_f90.html">eq_module.f90</a>,v 1.5
2009-02-28 21:33:46 uwabami Exp $

</td></tr>
<tr><td valign="top">Copyright&amp;License:</td><td>See <a href="../../COPYRIGHT">COPYRIGHT</a>

</td></tr>
</table>
<h2>概要</h2>
<p>
spml/eq_module モジュールは 2 次元円盤領域での流体運動を
スペクトル法により数値計算を実行するための Fortran90 関数を提供する.
周期的な境界条件を扱うための方位角方向へのフーリエ変換と
境界壁を扱うための動径方向の多項式変換を用いる場合の
スペクトル計算のためのさまざまな関数を提供する.
</p>
<p>
内部で <a href="ae_module.html">ae_module</a>, <a
href="aq_module.html">aq_module</a> を用いている.
最下部ではフーリエ変換およびチェビシェフ変換のエンジンとして ISPACK/FTPACK
の Fortran77 サブルーチンを用いている.
</p>
<p>
Matsushima and Marcus (1994) の多項式に関する説明は
動径座標のスペクトル法(<a
href=".././spectral_radial.pdf">spectral_radial.pdf</a>)を 参照のこと.
</p>
<h2>関数・変数の名前と型について</h2>
<h3>命名法</h3>
<ul>
<li>関数名の先頭 (eq_, rp_, r_, p_) は, 返す値の形を示している.

<table>
<tr><td valign="top">eq_ :</td><td>2次元スペクトルデータ

</td></tr>
<tr><td valign="top">rp_ :</td><td>2 次元格子点データ

</td></tr>
<tr><td valign="top">r_  :</td><td>動径方向 1 次元格子点データ

</td></tr>
<tr><td valign="top">p_  :</td><td>方位角方向 1 次元格子点データ

</td></tr>
</table>
</li>
<li>関数名の間の文字列(Dr, Dp, Lapla, LaplaInv, Jacobian)は,
その関数の作用を表している.

</li>
<li>関数名の最後 (_eq_eq,_eq,_rp, _r, _p) は, 入力変数のスペクトルデータ
および格子点データであることを示している.

<table>
<tr><td valign="top">_eq    :</td><td>2次元スペクトルデータ

</td></tr>
<tr><td valign="top">_eq_eq :</td><td>2 つの2次元スペクトルデータ

</td></tr>
<tr><td valign="top">_rp    :</td><td>2 次元格子点データ

</td></tr>
<tr><td valign="top">_r     :</td><td>動径方向 1 次元格子点データ

</td></tr>
<tr><td valign="top">_p     :</td><td>方位角方向 1 次元格子点データ

</td></tr>
</table>
</li>
</ul>
<h3>各データの種類の説明</h3>
<ul>
<li>rp : 2 次元格子点データ.

<ul>
<li>変数の種類と次元は real(8), dimension(jm,0:im-1).

</li>
<li>im, jm はそれぞれ方位角, 動径座標の格子点数であり, サブルーチン <a
href="eq_module.html#M001921">eq_initial</a> にてあらかじめ設定しておく.

</li>
<li>第 1 次元が動径座標の格子点位置番号, 第 2 次元が方位角座標の
格子点位置番号である.

</li>
</ul>
</li>
<li>eq : 2 次元スペクトルデータ.

<ul>
<li>変数の種類と次元は real(8), dimension(-km:km,0:lm).

</li>
<li>km, lm はそれぞれ方位角, 動径方向の最大波数であり, サブルーチン <a
href="eq_module.html#M001921">eq_initial</a> にてあらかじめ設定しておく.

</li>
<li>動径スペクトルデータの格納のされ方については <a
href="../files/src/aq_module_f90.html">aq_module.f90</a> を参照のこと.

</li>
</ul>
</li>
<li>p, r : X, Y 方向 1 次元格子点データ.

<ul>
<li>変数の種類と次元はそれぞれ real(8), dimension(0:im-1) および real(8),
dimension(jm).

</li>
</ul>
</li>
<li>e, q : 1 次元スペクトルデータ.

<ul>
<li>変数の種類と次元は real(8), dimension(-km:km) および real(8),
dimension(0:lm).

</li>
</ul>
</li>
<li>ap, ar : 1 次元格子点データの並んだ 2 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(:,0:im-1) および real(8),
dimension(:,jm).

</li>
</ul>
</li>
<li>ae, aq : 1 次元スペクトルデータの並んだ 2 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(:,-km:km) および real(8),
dimension(:,0:lm).

</li>
</ul>
</li>
<li>eq_ で始まる関数が返す値はスペクトルデータに同じ.

</li>
<li>rp_ で始まる関数が返す値は 2 次元格子点データに同じ.

</li>
<li>p_, p_ で始まる関数が返す値は 1 次元格子点データに同じ.

</li>
<li>スペクトルデータに対する微分等の作用とは, 対応する格子点データに
微分などを作用させたデータをスペクトル変換したものことである.

</li>
</ul>
<h2>変数・手続き群の要約</h2>
<h4>初期化</h4>
<table>
<tr><td valign="top"><a href="eq_module.html#M001921">eq_Initial</a> :</td><td>スペクトル変換の格子点数, 波数, 領域の大きさの設定

</td></tr>
</table>
<h4>座標変数</h4>
<table>
<tr><td valign="top"><a href="eq_module.html#M001946">p_Phi</a>, <a href="eq_module.html#M001948">r_Rad</a>               :</td><td>格子点座標(X,Y座標)を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001947">p_Phi_Weight</a>, <a href="eq_module.html#M001949">r_Rad_Weight</a> :</td><td>重み座標を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001918">rp_Phi</a>, <a href="eq_module.html#M001919">rp_Rad</a>             :</td><td>格子点データの XY 座標(X,Y) (格子点データ型 2 次元配列)

</td></tr>
</table>
<h4>基本変換</h4>
<table>
<tr><td valign="top"><a href="eq_module.html#M001922">rp_eq</a> :</td><td>スペクトルデータから格子データへの変換

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001923">eq_rp</a> :</td><td>格子データからスペクトルデータへの変換

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001953">ap_ae</a>, <a href="eq_module.html#M001951">p_e</a> :</td><td>方位角方向のスペクトルデータから格子データへの変換

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001957">ar_aq</a>, <a href="eq_module.html#M001955">r_q</a> :</td><td>動径方向のスペクトルデータから格子データへの変換

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001952">ae_ap</a>, <a href="eq_module.html#M001950">e_p</a> :</td><td>方位角方向の格子点データからスペクトルデータへの変換

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001956">aq_ar</a>, <a href="eq_module.html#M001954">q_r</a> :</td><td>動径方向の格子点データからスペクトルデータへの変換

</td></tr>
</table>
<h4>微分</h4>
<table>
<tr><td valign="top"><a href="eq_module.html#M001931">eq_Lapla_eq</a>  :</td><td>スペクトルデータにラプラシアンを作用させる

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001928">eq_DPhi_eq</a>, <a href="eq_module.html#M001959">ae_DPhi_ae</a>, <a href="eq_module.html#M001958">e_DPhi_e</a> :</td><td>スペクトルデータに 方位角微分を作用させる

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001929">eq_RadDRad_eq</a>, <a href="eq_module.html#M001961">aq_RadDRad_aq</a>, <a href="eq_module.html#M001960">q_RadDRad_q</a> :</td><td>スペクトルデータに 動径微分を作用させる

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001932">eq_Jacobian_eq_eq</a> :</td><td>2 つのスペクトルデータからヤコビアンを計算する

</td></tr>
</table>
<h4>境界値問題</h4>
<table>
<tr><td valign="top"><a href="eq_module.html#M001933">eq_Boundary</a>    :</td><td>ディリクレ, ノイマン境界条件の適用

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001934">eq_LaplaInv_eq</a> :</td><td>スペクトルデータにラプラシアンの逆変換を作用させる

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001935">eq_Vor2Strm_eq</a> :</td><td>渦度から流線を計算する

</td></tr>
</table>
<h4>積分・平均</h4>
<table>
<tr><td valign="top"><a href="eq_module.html#M001936">IntRadPhi_rp</a>, <a href="eq_module.html#M001941">AvrRadPhi_rp</a>   :</td><td>2 次元格子点データの全領域積分および平均

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001937">r_IntPhi_rp</a>, <a href="eq_module.html#M001942">r_AvrPhi_rp</a> :</td><td>2 次元格子点データの方位角方向積分および平均

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001939">IntPhi_p</a>, <a href="eq_module.html#M001944">AvrPhi_p</a>       :</td><td>1 次元(X)格子点データの方位角方向積分および平均

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001938">p_IntRad_rp</a>, <a href="eq_module.html#M001943">p_AvrRad_rp</a> :</td><td>2 次元格子点データの動径方向積分および平均

</td></tr>
<tr><td valign="top"><a href="eq_module.html#M001940">IntRad_r</a>, <a href="eq_module.html#M001945">AvrRad_r</a>       :</td><td>1 次元(Y)格子点データの動径方向積分および平均

</td></tr>
</table>

    </div>





   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M001944">AvrPhi_p</a>&nbsp;&nbsp;

        <a href="#M001941">AvrRadPhi_rp</a>&nbsp;&nbsp;

        <a href="#M001945">AvrRad_r</a>&nbsp;&nbsp;

        <a href="#M001939">IntPhi_p</a>&nbsp;&nbsp;

        <a href="#M001936">IntRadPhi_rp</a>&nbsp;&nbsp;

        <a href="#M001940">IntRad_r</a>&nbsp;&nbsp;

        <a href="#M001959">ae_DPhi_ae</a>&nbsp;&nbsp;

        <a href="#M001952">ae_ap</a>&nbsp;&nbsp;

        <a href="#M001953">ap_ae</a>&nbsp;&nbsp;

        <a href="#M001963">aq_Boundary_D</a>&nbsp;&nbsp;

        <a href="#M001962">aq_Boundary_D</a>&nbsp;&nbsp;

        <a href="#M001965">aq_Boundary_N</a>&nbsp;&nbsp;

        <a href="#M001964">aq_Boundary_N</a>&nbsp;&nbsp;

        <a href="#M001961">aq_RadDRad_aq</a>&nbsp;&nbsp;

        <a href="#M001956">aq_ar</a>&nbsp;&nbsp;

        <a href="#M001957">ar_aq</a>&nbsp;&nbsp;

        <a href="#M001958">e_DPhi_e</a>&nbsp;&nbsp;

        <a href="#M001950">e_p</a>&nbsp;&nbsp;

        <a href="#M001933">eq_Boundary</a>&nbsp;&nbsp;

        <a href="#M001928">eq_DPhi_eq</a>&nbsp;&nbsp;

        <a href="#M001921">eq_Initial</a>&nbsp;&nbsp;

        <a href="#M001932">eq_Jacobian_eq_eq</a>&nbsp;&nbsp;

        <a href="#M001934">eq_LaplaInv_eq</a>&nbsp;&nbsp;

        <a href="#M001931">eq_Lapla_eq</a>&nbsp;&nbsp;

        <a href="#M001929">eq_RadDRad_eq</a>&nbsp;&nbsp;

        <a href="#M001935">eq_Vor2Strm_eq</a>&nbsp;&nbsp;

        <a href="#M001924">eq_er</a>&nbsp;&nbsp;

        <a href="#M001923">eq_rp</a>&nbsp;&nbsp;

        <a href="#M001930">er_Lapla_eq</a>&nbsp;&nbsp;

        <a href="#M001920">er_Rad</a>&nbsp;&nbsp;

        <a href="#M001925">er_eq</a>&nbsp;&nbsp;

        <a href="#M001927">er_rp</a>&nbsp;&nbsp;

        <a href="#M001943">p_AvrRad_rp</a>&nbsp;&nbsp;

        <a href="#M001938">p_IntRad_rp</a>&nbsp;&nbsp;

        <a href="#M001946">p_Phi</a>&nbsp;&nbsp;

        <a href="#M001947">p_Phi_weight</a>&nbsp;&nbsp;

        <a href="#M001951">p_e</a>&nbsp;&nbsp;

        <a href="#M001960">q_RadDRad_q</a>&nbsp;&nbsp;

        <a href="#M001954">q_r</a>&nbsp;&nbsp;

        <a href="#M001942">r_AvrPhi_rp</a>&nbsp;&nbsp;

        <a href="#M001937">r_IntPhi_rp</a>&nbsp;&nbsp;

        <a href="#M001948">r_Rad</a>&nbsp;&nbsp;

        <a href="#M001949">r_Rad_Weight</a>&nbsp;&nbsp;

        <a href="#M001955">r_q</a>&nbsp;&nbsp;

        <a href="#M001918">rp_Phi</a>&nbsp;&nbsp;

        <a href="#M001919">rp_Rad</a>&nbsp;&nbsp;

        <a href="#M001922">rp_eq</a>&nbsp;&nbsp;

        <a href="#M001926">rp_er</a>&nbsp;&nbsp;
      </div>
    </div>


  </div>


    <!-- if includes -->

    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">

        <span class="include-name">dc_message</span>

        <span class="include-name"><a href="lumatrix.html">lumatrix</a></span>

        <span class="include-name"><a href="ae_module.html">ae_module</a></span>

        <span class="include-name"><a href="aq_module.html">aq_module</a></span>
      </div>
    </div>



    <div id="section">










      


    <!-- if method_list -->

    <div id="methods">


      <h3 class="section-bar">Public Instance methods</h3>


      <div id="method-M001944" class="method-detail">
        <a name="M001944"></a>

        <div class="method-heading">


          <a href="#M001944" class="method-signature">



          <span class="method-name">AvrPhi_p</span><span class="method-args">( p ) result(AvrPhi_p)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001944">AvrPhi_p</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>p  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(Phi)格子点データの Phi 方向平均
</p>
<p>
実際には格子点データ各点毎に <a
href="eq_module.html#M001947">p_Phi_Weight</a> をかけた総和を計算し, <a
href="eq_module.html#M001947">p_Phi_Weight</a>
の総和で割ることで平均している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001944-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001944-source">
<pre>
    function AvrPhi_p(p)
      !
      ! 1 次元(Phi)格子点データの Phi 方向平均
      !
      ! 実際には格子点データ各点毎に p_Phi_Weight をかけた総和を計算し, 
      ! p_Phi_Weight の総和で割ることで平均している. 
      !
      real(8), dimension(0:im-1)   :: p          !(in)  1 次元格子点データ
      real(8)                      :: AvrPhi_p     !(out) 平均値

      AvrPhi_p = IntPhi_p(p)/sum(p_Phi_weight)
    end function AvrPhi_p
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001941" class="method-detail">
        <a name="M001941"></a>

        <div class="method-heading">


          <a href="#M001941" class="method-signature">



          <span class="method-name">AvrRadPhi_rp</span><span class="method-args">( rp ) result(AvrRadPhi_rp)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001941">AvrRadPhi_rp</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>rp  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元格子点データの全領域平均
</p>
<p>
実際には格子点データ各点毎に <a
href="eq_module.html#M001947">p_Phi_Weight</a>, <a
href="eq_module.html#M001949">r_Rad_Weight</a> をかけた 総和を計算し, <a
href="eq_module.html#M001947">p_Phi_Weight</a>*<a
href="eq_module.html#M001949">r_Rad_Weight</a>
の総和で割ることで平均している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001941-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001941-source">
<pre>
    function AvrRadPhi_rp(rp)
      !
      ! 2 次元格子点データの全領域平均
      !
      ! 実際には格子点データ各点毎に p_Phi_Weight, r_Rad_Weight をかけた
      ! 総和を計算し, p_Phi_Weight*r_Rad_Weight の総和で割ることで平均している. 
      !
      real(8), dimension(jm,0:im-1)   :: rp
      !(in)  2 次元格子点データ

      real(8)                         :: AvrRadPhi_rp
      !(out) 平均値

      AvrRadPhi_rp = IntRadPhi_rp(rp)/(sum(p_Phi_weight)*sum(r_Rad_weight))
    end function AvrRadPhi_rp
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001945" class="method-detail">
        <a name="M001945"></a>

        <div class="method-heading">


          <a href="#M001945" class="method-signature">



          <span class="method-name">AvrRad_r</span><span class="method-args">( r ) result(AvrRad_r)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001945">AvrRad_r</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>r  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(Rad)格子点データの Rad 方向平均
</p>
<p>
実際には格子点データ各点毎に <a
href="eq_module.html#M001949">r_Rad_Weight</a> をかけた総和を計算し, <a
href="eq_module.html#M001949">r_Rad_Weight</a>
の総和で割ることで平均している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001945-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001945-source">
<pre>
    function AvrRad_r(r)
      !
      ! 1 次元(Rad)格子点データの Rad 方向平均
      !
      ! 実際には格子点データ各点毎に r_Rad_Weight をかけた総和を計算し, 
      ! r_Rad_Weight の総和で割ることで平均している. 
      !
      real(8), dimension(jm)   :: r            !(in)  1 次元格子点データ
      real(8)                  :: AvrRad_r     !(out) 平均値

      AvrRad_r = IntRad_r(r)/sum(r_Rad_weight)
    end function AvrRad_r
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001939" class="method-detail">
        <a name="M001939"></a>

        <div class="method-heading">


          <a href="#M001939" class="method-signature">



          <span class="method-name">IntPhi_p</span><span class="method-args">( p ) result(IntPhi_p)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001939">IntPhi_p</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>p  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(Phi)格子点データの Phi 方向積分
</p>
<p>
実際には格子点データ各点毎に <a
href="eq_module.html#M001947">p_Phi_Weight</a> をかけた総和を計算している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001939-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001939-source">
<pre>
    function IntPhi_p(p)
      !
      ! 1 次元(Phi)格子点データの Phi 方向積分
      !
      ! 実際には格子点データ各点毎に p_Phi_Weight をかけた総和を計算している. 
      !
      real(8), dimension(0:im-1)   :: p         !(in)  1 次元格子点データ
      real(8)                      :: IntPhi_p    !(out) 積分値

      IntPhi_p = sum(p*p_Phi_Weight)
    end function IntPhi_p
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001936" class="method-detail">
        <a name="M001936"></a>

        <div class="method-heading">


          <a href="#M001936" class="method-signature">



          <span class="method-name">IntRadPhi_rp</span><span class="method-args">( rp ) result(IntRadPhi_rp)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001936">IntRadPhi_rp</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>rp  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元格子点データの全領域積分および平均.
</p>
<p>
実際には格子点データ各点毎に <a
href="eq_module.html#M001947">p_Phi_Weight</a>, <a
href="eq_module.html#M001949">r_Rad_Weight</a> をかけた 総和を計算している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001936-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001936-source">
<pre>
    function IntRadPhi_rp(rp)
      !
      ! 2 次元格子点データの全領域積分および平均.
      !
      ! 実際には格子点データ各点毎に p_Phi_Weight, r_Rad_Weight をかけた
      ! 総和を計算している. 
      !
      real(8), dimension(jm,0:im-1)   :: rp
      !(in)  2 次元格子点データ

      real(8)                         :: IntRadPhi_rp
      !(out) 積分値

      integer :: i, j

      IntRadPhi_rp = 0.0d0
      do i=0,im-1
         do j=1,jm
            IntRadPhi_rp = IntRadPhi_rp + rp(j,i) * r_Rad_Weight(j) * p_Phi_Weight(i)
         enddo
      enddo
    end function IntRadPhi_rp
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001940" class="method-detail">
        <a name="M001940"></a>

        <div class="method-heading">


          <a href="#M001940" class="method-signature">



          <span class="method-name">IntRad_r</span><span class="method-args">( r ) result(IntRad_r)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001940">IntRad_r</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>r  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(Rad)格子点データの Rad 方向積分
</p>
<p>
実際には格子点データ各点毎に <a
href="eq_module.html#M001949">r_Rad_Weight</a> をかけた総和を計算している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001940-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001940-source">
<pre>
    function IntRad_r(r) 
      !
      ! 1 次元(Rad)格子点データの Rad 方向積分
      !
      ! 実際には格子点データ各点毎に r_Rad_Weight をかけた総和を計算している. 
      !
      real(8), dimension(jm)   :: r          !(in)  1 次元格子点データ
      real(8)                  :: IntRad_r     !(out) 積分値

      IntRad_r = sum(r*r_Rad_Weight)
    end function IntRad_r
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001959" class="method-detail">
        <a name="M001959"></a>

        <div class="method-heading">




          <span class="method-name">ae_DPhi_ae</span><span class="method-args">( ae ) result(ae_Dx_ae)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>ae  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,-km:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに X 微分を作用する(2 次元データ).
</p>
<p>
スペクトルデータの X 微分とは, 対応する格子点データに X 微分を
作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="ae_module.html#M001553">ae_module#ae_Dx_ae</a>
</p>


        </div>
      </div>


      <div id="method-M001952" class="method-detail">
        <a name="M001952"></a>

        <div class="method-heading">




          <span class="method-name">ae_ap</span><span class="method-args">( ag ) result(ae_ag)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>ae_ag  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(ag,1),-km:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ag  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データからスペクトルデータへ変換する(2 次元データ用)
</p>
<p>
Original external subprogram is <a
href="ae_module.html#M001551">ae_module#ae_ag</a>
</p>


        </div>
      </div>


      <div id="method-M001953" class="method-detail">
        <a name="M001953"></a>

        <div class="method-heading">




          <span class="method-name">ap_ae</span><span class="method-args">( ae ) result(ag_ae)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>ag_ae  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(ae,1),0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ae  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,-km:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子点データへ変換する(2 次元データ用)
</p>
<p>
Original external subprogram is <a
href="ae_module.html#M001549">ae_module#ag_ae</a>
</p>


        </div>
      </div>


      <div id="method-M001963" class="method-detail">
        <a name="M001963"></a>

        <div class="method-heading">




          <span class="method-name">aq_Boundary_D</span><span class="method-args">( aq_data, [value] ) </span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(jmax,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(jmax)

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
</p>
<ul>
<li>外側境界(i=im)での値を与える.

</li>
</ul>
<p>
Original external subprogram is <a
href="aq_module.html#M001998">aq_module#aq_Boundary_D</a>
</p>


        </div>
      </div>


      <div id="method-M001962" class="method-detail">
        <a name="M001962"></a>

        <div class="method-heading">




          <span class="method-name">aq_Boundary_D</span><span class="method-args">( q_data, [value] ) </span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
</p>
<ul>
<li>両境界での値を与える.

</li>
</ul>
<p>
Original external subprogram is <a
href="aq_module.html#M001998">aq_module#aq_Boundary_D</a>
</p>


        </div>
      </div>


      <div id="method-M001965" class="method-detail">
        <a name="M001965"></a>

        <div class="method-heading">




          <span class="method-name">aq_Boundary_N</span><span class="method-args">( aq_data, [value] ) </span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m)

</td></tr>
</table>
</td></tr>
</table>
<p>
外側境界 Neumann 型境界条件の適用(タウ法, 2 次元配列用)
</p>
<ul>
<li>i=im で勾配の値を与える.

</li>
</ul>
<p>
Original external subprogram is <a
href="aq_module.html#M002000">aq_module#aq_Boundary_N</a>
</p>


        </div>
      </div>


      <div id="method-M001964" class="method-detail">
        <a name="M001964"></a>

        <div class="method-heading">




          <span class="method-name">aq_Boundary_N</span><span class="method-args">( q_data, [value] ) </span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet/Neumann 型境界条件の適用(タウ法, 1 次元配列用)
</p>
<ul>
<li>i=0 で勾配の値を与える.

</li>
</ul>
<p>
Original external subprogram is <a
href="aq_module.html#M002000">aq_module#aq_Boundary_N</a>
</p>


        </div>
      </div>


      <div id="method-M001961" class="method-detail">
        <a name="M001961"></a>

        <div class="method-heading">




          <span class="method-name">aq_RadDRad_aq</span><span class="method-args">( aq_data ) result(aq_rDr_aq)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>aq_rDr_aq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(aq_data,1),0:size(aq_data,2)-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 出力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに対して微分 r(d/dr) のスペクトル係数 を計算する(2
次元配列用).
</p>
<pre>
  a_n = aq_data/sqrt(Inm),  b_n = aq_rDr_aq/sqrt(Inm)

  b_n = (2n+gamma-1)/(2n+gamma+3)b_n+2
      + (2n+gamma-1)(n+gamma+1)/(2n+gamma+3)a_n+2 + n a_n
</pre>
<p>
Original external subprogram is <a
href="aq_module.html#M001988">aq_module#aq_rDr_aq</a>
</p>


        </div>
      </div>


      <div id="method-M001956" class="method-detail">
        <a name="M001956"></a>

        <div class="method-heading">




          <span class="method-name">aq_ar</span><span class="method-args">( ag_data ) result(aq_ag)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>aq_ag  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(ag_data,1),0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ag_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからスペクトルデータへ変換する(2 次元配列用).
</p>
<p>
Original external subprogram is <a
href="aq_module.html#M001986">aq_module#aq_ag</a>
</p>


        </div>
      </div>


      <div id="method-M001957" class="method-detail">
        <a name="M001957"></a>

        <div class="method-heading">




          <span class="method-name">ar_aq</span><span class="method-args">( aq_data ) result(ag_aq)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>ag_aq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(aq_data,1),im)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子データへ変換する(2 次元配列用).
</p>
<p>
Original external subprogram is <a
href="aq_module.html#M001984">aq_module#ag_aq</a>
</p>


        </div>
      </div>


      <div id="method-M001958" class="method-detail">
        <a name="M001958"></a>

        <div class="method-heading">




          <span class="method-name">e_DPhi_e</span><span class="method-args">( e ) result(e_Dx_e)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>e_Dx_e  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 入力スペクトルデータの X 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>e  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに X 微分を作用する(1 次元データ).
</p>
<p>
スペクトルデータの X 微分とは, 対応する格子点データに X 微分を
作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="ae_module.html#M001554">ae_module#e_Dx_e</a>
</p>


        </div>
      </div>


      <div id="method-M001950" class="method-detail">
        <a name="M001950"></a>

        <div class="method-heading">




          <span class="method-name">e_p</span><span class="method-args">( g ) result(e_g)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>e_g  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>g  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データからスペクトルデータへ変換する(1 次元データ用)
</p>
<p>
Original external subprogram is <a
href="ae_module.html#M001552">ae_module#e_g</a>
</p>


        </div>
      </div>


      <div id="method-M001933" class="method-detail">
        <a name="M001933"></a>

        <div class="method-heading">


          <a href="#M001933" class="method-signature">



          <span class="method-name">eq_Boundary</span><span class="method-args">( eq, [value], [cond] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>eq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> 境界での 値/勾配 分布を水平スペクトル変換したものを与える. 省略時は値/勾配
0 となる.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=1), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> 境界条件. 省略時は &#8216;D&#8216;

<pre>
  D : 両端ディリクレ
  N : 両端ノイマン
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
ディリクレ, ノイマン条件の適用. チェビシェフ空間での計算
</p>
<p>
実際には中で呼ばれている <a href="aq_module.html">aq_module</a>
のサブルーチン <a href="eq_module.html#M001962">aq_Boundary_D</a>,, <a
href="eq_module.html#M001964">aq_Boundary_N</a> を用いている.
これらを直接呼ぶことも出来る.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001933-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001933-source">
<pre>
    subroutine eq_Boundary(eq,value,cond)
      !
      ! ディリクレ, ノイマン条件の適用. チェビシェフ空間での計算
      !
      ! 実際には中で呼ばれている aq_module のサブルーチン 
      ! aq_Boundary_D,, aq_Boundary_N を用いている. 
      ! これらを直接呼ぶことも出来る.
      !
      real(8), dimension(-km:km,0:lm),intent(inout)      :: eq
              ! 境界条件を適用するデータ. 修正された値を返す. 

      real(8), dimension(-km:km), intent(in), optional   :: value
              ! 境界での 値/勾配 分布を水平スペクトル変換したものを与える. 
              ! 省略時は値/勾配 0 となる. 

      character(len=1), intent(in), optional             :: cond
              ! 境界条件. 省略時は 'D'
              !   D : 両端ディリクレ
              !   N : 両端ノイマン

      if (.not. present(cond)) then
         if (present(value)) then
            call aq_Boundary_D(eq,value)
         else
            call aq_Boundary_D(eq)
         endif
         return
      endif

      select case(cond)
      case ('N')
         if (present(value)) then
            call aq_Boundary_N(eq,value)
         else
            call aq_Boundary_N(eq)
         endif
      case ('D')
         if (present(value)) then
            call aq_Boundary_D(eq,value)
         else
            call aq_Boundary_D(eq)
         endif
      case default
         call MessageNotify('E','eq_Boundaries','B.C. not supported')
      end select

    end subroutine eq_Boundary
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001928" class="method-detail">
        <a name="M001928"></a>

        <div class="method-heading">


          <a href="#M001928" class="method-signature">



          <span class="method-name">eq_DPhi_eq</span><span class="method-args">( eq ) result(eq_DPhi_eq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001928">eq_DPhi_eq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

</td></tr>
<tr><td valign="top"><b><tt>eq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

</td></tr>
</table>
<p>
入力スペクトルデータに方位角微分(∂φ)を作用する.
</p>
<p>
スペクトルデータのφ微分とは, 対応する格子点データにφ微分を
作用させたデータのスペクトル変換のことである.
</p>
<p>
実際にはスペクトルデータに X 方向波数 k をかけて sin(kx) &lt;-&gt; cos(kx)
成分に入れ換える計算を行っている.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001928-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001928-source">
<pre>
    function eq_DPhi_eq(eq)
      !
      ! 入力スペクトルデータに方位角微分(∂φ)を作用する.
      !
      ! スペクトルデータのφ微分とは, 対応する格子点データにφ微分を
      ! 作用させたデータのスペクトル変換のことである.
      !
      ! 実際にはスペクトルデータに X 方向波数 k をかけて
      ! sin(kx) &lt;-&gt; cos(kx) 成分に入れ換える計算を行っている.
      !
      real(8), dimension(-km:km,0:lm)                :: eq_DPhi_eq
      real(8), dimension(-km:km,0:lm), intent(in)    :: eq
      integer k

      do k=-km,km
         eq_DPhi_eq(k,:)  =  -k*eq(-k,:)
      enddo
    end function eq_DPhi_eq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001921" class="method-detail">
        <a name="M001921"></a>

        <div class="method-heading">


          <a href="#M001921" class="method-signature">



          <span class="method-name">eq_Initial</span><span class="method-args">( i, j, k, l, ra_in ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>i  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点数(X)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>j  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点数(Y)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>k  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 切断波数(X)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>l  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 切断波数(Y)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ra_in  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 半径

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル変換の格子点数, 波数, 領域の大きさを設定する.
</p>
<p>
他の関数や変数を呼ぶ前に, 最初にこのサブルーチンを呼んで
初期設定をしなければならない.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001921-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001921-source">
<pre>
    subroutine eq_Initial(i,j,k,l,ra_in)
      !
      ! スペクトル変換の格子点数, 波数, 領域の大きさを設定する.
      !
      ! 他の関数や変数を呼ぶ前に, 最初にこのサブルーチンを呼んで
      ! 初期設定をしなければならない.
      !
      integer,intent(in) :: i           ! 格子点数(X)
      integer,intent(in) :: j           ! 格子点数(Y)
      integer,intent(in) :: k           ! 切断波数(X)
      integer,intent(in) :: l           ! 切断波数(Y)

      real(8),intent(in) :: ra_in       ! 半径

      integer :: kk

      im = i       
       jm = j
      km = k       
       lm = l
      ra = ra_in

      allocate(md(-km:km))

      do kk=-km,km
         md(kk) = abs(kk)
      enddo

      call ae_initial(im,km,0.0D0,2*pi)
      call aq_Initial(jm,lm,ra,alpha,beta,md)

      allocate(rp_Phi(jm,0:im-1),rp_Rad(jm,0:im-1))
      rp_Phi = spread(p_Phi,1,jm)
      rp_Rad = spread(r_Rad,2,im)

      allocate(er_Rad(-km:km,jm))
      er_Rad = spread(r_Rad,1,2*km+1)

      call MessageNotify('M','eq_initial','eq_module (2009/01/09) is initialized')
    end subroutine eq_initial
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001932" class="method-detail">
        <a name="M001932"></a>

        <div class="method-heading">


          <a href="#M001932" class="method-signature">



          <span class="method-name">eq_Jacobian_eq_eq</span><span class="method-args">( eq_a, eq_b ) result(eq_Jacobian_eq_eq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001932">eq_Jacobian_eq_eq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 つのスペクトルデータのヤコビアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>eq_a  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1つ目の入力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>eq_b  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2つ目の入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<pre>
 2 つのスペクトルデータからヤコビアン

    J(A,B)=1/r[(∂rA)(∂φB)-(∂φA)(∂rB)]

 を計算する. 1/r のファクターがついていることに注意.

 2 つのスペクトルデータのヤコビアンとは, 対応する 2 つの
 格子点データのヤコビアンのスペクトル変換のことである.
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001932-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001932-source">
<pre>
    function eq_Jacobian_eq_eq(eq_a,eq_b)
      !
      !  2 つのスペクトルデータからヤコビアン
      !
      !     J(A,B)=1/r[(∂rA)(∂φB)-(∂φA)(∂rB)]
      !
      !  を計算する. 1/r のファクターがついていることに注意. 
      !
      !  2 つのスペクトルデータのヤコビアンとは, 対応する 2 つの
      !  格子点データのヤコビアンのスペクトル変換のことである.
      !
      real(8), dimension(-km:km,0:lm)                :: eq_Jacobian_eq_eq
      !(out) 2 つのスペクトルデータのヤコビアン

      real(8), dimension(-km:km,0:lm), intent(in)    :: eq_a
      !(in) 1つ目の入力スペクトルデータ

      real(8), dimension(-km:km,0:lm), intent(in)    :: eq_b
      !(in) 2つ目の入力スペクトルデータ

      eq_Jacobian_eq_eq = eq_rp( (  rp_eq(eq_RadDRad_eq(eq_a)) * rp_eq(eq_DPhi_eq(eq_b)) -rp_eq(eq_DPhi_eq(eq_a)) * rp_eq(eq_RadDRad_eq(eq_b)) ) /rp_Rad**2)

    end function eq_Jacobian_eq_eq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001934" class="method-detail">
        <a name="M001934"></a>

        <div class="method-heading">


          <a href="#M001934" class="method-signature">



          <span class="method-name">eq_LaplaInv_eq</span><span class="method-args">( eq, [value] ) result(eq_LaplaInv_eq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001934">eq_LaplaInv_eq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの逆ラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>eq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値. 省略時は 0 が設定される.

</td></tr>
</table>
</td></tr>
</table>
<p>
境界で値を与える条件(ディリクレ条件)下で,
入力スペクトルデータに逆ラプラシアン [(1/r)(∂r(r∂r)+ (1/r^2) ∂φφ]^{-1}
を作用する.
</p>
<p>
タウ法による計算
</p>
<p>
スペクトルデータの逆ラプラシアンとは, 対応する格子点データに
逆ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001934-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001934-source">
<pre>
    function eq_LaplaInv_eq(eq,value)
      !
      ! 境界で値を与える条件(ディリクレ条件)下で, 
      ! 入力スペクトルデータに逆ラプラシアン
      ! [(1/r)(∂r(r∂r)+ (1/r^2) ∂φφ]^{-1} を作用する.
      !
      ! タウ法による計算
      !
      ! スペクトルデータの逆ラプラシアンとは, 対応する格子点データに
      ! 逆ラプラシアンを作用させたデータのスペクトル変換のことである.
      !
      real(8), dimension(-km:km,0:lm),intent(in)  :: eq
      !(in) スペクトルデータ

      real(8), dimension(-km:km,0:lm)             :: eq_LaplaInv_eq
      !(out) スペクトルデータの逆ラプラシアン

      real(8), dimension(-km:km), intent(in), optional :: value
      !(in) 境界値. 省略時は 0 が設定される. 

      real(8), dimension(:,:,:), allocatable  :: alu
      integer, dimension(:,:), allocatable    :: kp

      real(8), dimension(-km:km,0:lm)         :: eq_work
      real(8), dimension(-km:km,jm)           :: er_work
      real(8), dimension(-km:km)              :: value1       ! 境界値

      logical :: first = .true.
      integer :: k, l
      save    :: alu, kp, first

      if (.not. present(value)) then
         value1=0
      else
         value1 = value
      endif

      if ( first ) then
         first = .false.

         allocate(alu(-km:km,0:lm,0:lm),kp(-km:km,0:lm))

         do l=0,lm
            eq_work = 0.0 
             eq_work(:,l) = 1.0
            alu(:,:,l) = eq_er(er_Lapla_eq(eq_work))
         enddo

         ! 0 成分のところを 1 で埋める.
         do k=-km,km
            do l=0,md(k)-1
               alu(k,l,l) = 1.0D0
            enddo
            do l=md(k)+1,lm,2
               alu(k,l,l) = 1.0D0
            enddo
         enddo

         ! 境界条件 r=ra で値を与える. 
         do k=-km,km
            do l=0,lm
               eq_work=0 
                eq_work(k,l)=1.0
               er_work=er_eq(eq_work)
               if ( mod(md(k),2) .eq. mod(lm,2) ) then
                  alu(k,lm,l) = er_work(k,jm)
               else
                  alu(k,lm-1,l) = er_work(k,jm)
               endif
            enddo
         enddo

         call ludecomp(alu,kp)
      endif

      eq_work = eq
      do k=-km,km
         if ( mod(md(k),2) .eq. mod(lm,2) ) then
            eq_work(k,lm)   = value1(k)
         else
            eq_work(k,lm-1) = value1(k)
         endif
      enddo
      eq_LaplaInv_eq = lusolve(alu,kp,eq_work)

    end function eq_LaplaInv_eq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001931" class="method-detail">
        <a name="M001931"></a>

        <div class="method-heading">


          <a href="#M001931" class="method-signature">



          <span class="method-name">eq_Lapla_eq</span><span class="method-args">( eq ) result(eq_Lapla_eq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001931">eq_Lapla_eq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータのラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>eq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータにラプラシアン
</p>
<pre>
 (1/r)(∂r(r∂r)+ (1/r^2) ∂φφ を作用する.
</pre>
<p>
スペクトルデータのラプラシアンとは,
対応する格子点データにラプラシアンを作用させたデータの
スペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001931-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001931-source">
<pre>
    function eq_Lapla_eq(eq)
      !
      ! 入力スペクトルデータにラプラシアン 
      !  (1/r)(∂r(r∂r)+ (1/r^2) ∂φφ を作用する.
      !
      ! スペクトルデータのラプラシアンとは, 
      ! 対応する格子点データにラプラシアンを作用させたデータの
      ! スペクトル変換のことである. 
      !
      real(8), dimension(-km:km,0:lm)              :: eq_Lapla_eq
      !(out) スペクトルデータのラプラシアン

      real(8), dimension(-km:km,0:lm), intent(in)  :: eq
      !(in) 入力スペクトルデータ

      eq_Lapla_eq = eq_er(er_Lapla_eq(eq))

    end function eq_Lapla_eq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001929" class="method-detail">
        <a name="M001929"></a>

        <div class="method-heading">


          <a href="#M001929" class="method-signature">



          <span class="method-name">eq_RadDRad_eq</span><span class="method-args">( eq ) result(eq_RadDRad_eq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001929">eq_RadDRad_eq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの動径微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>eq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに動径微分(r∂r)を作用する.
</p>
<p>
スペクトルデータの動径微分とは, 対応する格子点データに動径微分を
作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001929-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001929-source">
<pre>
    function eq_RadDRad_eq(eq)
      !
      ! 入力スペクトルデータに動径微分(r∂r)を作用する.
      !
      ! スペクトルデータの動径微分とは, 対応する格子点データに動径微分を
      ! 作用させたデータのスペクトル変換のことである.
      !
      real(8), dimension(-km:km,0:lm)               :: eq_RadDRad_eq
      !(out) スペクトルデータの動径微分

      real(8), dimension(-km:km,0:lm), intent(in)   :: eq
      !(in) 入力スペクトルデータ

      eq_RadDRad_eq = aq_RadDRad_aq(eq)

    end function eq_RadDRad_eq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001935" class="method-detail">
        <a name="M001935"></a>

        <div class="method-heading">


          <a href="#M001935" class="method-signature">



          <span class="method-name">eq_Vor2Strm_eq</span><span class="method-args">( eq, [value], [cond], [new] ) result(eq_Vor2Strm_eq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001935">eq_Vor2Strm_eq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 出力流線関数分布

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>eq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力渦度分布

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> 流線境界値. 境界で一定なので波数 0 成分のみ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=1), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件スイッチ. 省略時は &#8216;R&#8216;

<pre>
    R    : 上側粘着条件
    F    : 上側応力なし条件
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
渦度から流線を求める.
</p>
<p>
Chebyshev-tau 法による計算 渦度 zeta を与えて流線 psi を求める.
</p>
<pre>
   \nabla^2 \psi = \zeta,
   \psi = const. at the boundary
</pre>
<p>
粘着条件
</p>
<pre>
   \DP{\psi}{r} = 0 at the boundary
</pre>
<p>
応力なし条件
</p>
<pre>
   r\DP{}{r}(1/r\DP{\psi}{r})  = 0 at the boundary
</pre>
<p>
l=0,lm 成分の式の代わりに境界条件を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001935-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001935-source">
<pre>
    function eq_Vor2Strm_eq(eq,value,cond,new)
      !
      ! 渦度から流線を求める. 
      !
      ! Chebyshev-tau 法による計算
      ! 渦度 \zeta を与えて流線 \psi を求める.
      !    \nabla^2 \psi = \zeta, 
      !    \psi = const. at the boundary
      ! 粘着条件
      !    \DP{\psi}{r} = 0 at the boundary
      ! 応力なし条件
      !    r\DP{}{r}(1/r\DP{\psi}{r})  = 0 at the boundary
      !
      ! l=0,lm 成分の式の代わりに境界条件を与える. 
      !
      real(8), dimension(-km:km,0:lm),intent(in)  :: eq
              !(in) 入力渦度分布

      real(8), dimension(-km:km,0:lm)             :: eq_Vor2Strm_eq
              !(out) 出力流線関数分布

      real(8), intent(in), optional               :: value
              ! 流線境界値. 境界で一定なので波数 0 成分のみ

      character(len=1), intent(in), optional  :: cond
              !(in) 境界条件スイッチ. 省略時は 'R'
              !     R    : 上側粘着条件
              !     F    : 上側応力なし条件

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:,:), allocatable  :: alu, alub
      integer, dimension(:,:), allocatable    :: kp, kpb

      real(8), dimension(-km:km,0:lm)         :: eq_work
      real(8), dimension(-km:km,jm)           :: er_work
      real(8)                                 :: value1          ! 境界値
      logical                                 :: rigid

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer :: k, l, ll
      save    :: alu, kp, first
      save    :: alub, kpb

      if (.not. present(value)) then
         value1=0
      else
         value1 = value
      endif

      if (.not. present(cond)) then
         rigid=.TRUE. 
      else
         select case (cond)
         case ('R')
            rigid = .TRUE.
         case ('F')
            rigid = .FALSE.
         case default
            call MessageNotify('E','eq_Vor2Strm_eq','B.C. not supported')
         end select
      endif

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         allocate(alu(-km:km,0:lm,0:lm),kp(-km:km,0:lm))

         if ( allocated(alub) ) deallocate(alub)
         if ( allocated(kpb) ) deallocate(kpb)
         allocate(alub(-km:km,0:lm,0:lm),kpb(-km:km,0:lm))

         ! 内部条件
         do l=0,lm
            eq_work = 0.0 
             eq_work(:,l) = 1.0
            alu(:,:,l) = eq_er(er_Lapla_eq(eq_work))
         enddo

         ! 0 成分のところを 1 で埋める.
         do k=-km,km
            do l=0,md(k)-1
               alu(k,l,l) = 1.0D0
            enddo
            do l=md(k)+1,lm,2
               alu(k,l,l) = 1.0D0
            enddo
         enddo
         
         ! alu(:,:,nd(k)) 列は 0 なので 1 をいれておく. 
         ! l=md(k) 成分は境界条件で決める. 
         do k=-km,km
            if ( mod(md(k),2) .eq. mod(lm,2) ) then
               alu(k,lm,md(k)) = 1.0D0
            else
               alu(k,lm-1,md(k)) = 1.0D0
            endif
         enddo

         call ludecomp(alu,kp)

         !---- 境界条件計算用行列 -----
         alub = 0.0
         do l=0,lm
            alub(:,l,l) = 1.0D0
         enddo

         ! 運動学的条件. 流線は境界で一定
         !     l=nd(n) 成分を境界条件で決める. 
         do l=0,lm
            eq_work = 0.0 
             eq_work(:,l)=1.0D0
            er_work = er_eq(eq_work)
            do k=-km,km
               alub(k,md(k),l) = er_work(k,jm)
            enddo
         enddo

         ! 力学的条件粘着条件 
         !     l=lm or lm-1 成分を境界条件で決める. 
         if ( rigid ) then
            do l=0,lm
               eq_work = 0.0 
                 eq_work(:,l)=1.0D0
               er_work=er_eq(eq_RadDRad_eq(eq_work))/er_Rad
               do k=-km,km
                  if ( mod(md(k),2) .eq. mod(lm,2) ) then
                     alub(k,lm,l) = er_work(k,jm)
                  else
                     alub(k,lm-1,l) = er_work(k,jm)
                  endif
               end do
            enddo
         else
            do l=0,lm
               eq_work = 0.0 
                eq_work(:,l)=1.0D0
               er_work=er_eq(eq_RadDRad_eq(eq_RadDRad_eq(eq_work)) -2*eq_RadDRad_eq(eq_work))/er_Rad**2
               do k=-km,km
                  if ( mod(md(k),2) .eq. mod(lm,2) ) then
                     alub(k,lm,l) = er_work(k,jm)
                  else
                     alub(k,lm-1,l) = er_work(k,jm)
                  endif
               end do
            enddo
         endif

         call ludecomp(alub,kpb)

         if ( rigid ) then
            call MessageNotify('M','eq_Vor2Strm_eq', 'Matrix to apply rigid b.c. newly produced.')
         else
            call MessageNotify('M','eq_Vor2Strm_eq', 'Matrix to apply stress-free b.c. newly produced.')
         endif
      endif

      ! 内部領域計算
      eq_work = eq

      eq_work = lusolve(alu,kp,eq_work)

      ! 境界条件計算
      do k=-km,km
         eq_work(k,md(k)) = 0
         if ( mod(md(k),2) .eq. mod(lm,2) ) then
            eq_work(k,lm)   = 0
         else
            eq_work(k,lm-1) = 0
         endif
      enddo
      eq_work(0,0)   = value1*2     ! 運動学的条件. 波数 0 は重み 1/2

      eq_Vor2Strm_eq = lusolve(alub,kpb,eq_work)

    end function eq_Vor2Strm_eq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001924" class="method-detail">
        <a name="M001924"></a>

        <div class="method-heading">


          <a href="#M001924" class="method-signature">



          <span class="method-name">eq_er</span><span class="method-args">( er ) result(eq_er)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001924">eq_er</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>er  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,jm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
動径格子データからスペクトルデータへ変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001924-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001924-source">
<pre>
    function eq_er(er)
      !
      ! 動径格子データからスペクトルデータへ変換する.
      !
      real(8), dimension(-km:km,0:lm)              :: eq_er
      !(out) スペクトルデータ

      real(8), dimension(-km:km,jm), intent(in)    :: er
      !(in) 格子点データ

      eq_er = aq_ar(er)

    end function eq_er
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001923" class="method-detail">
        <a name="M001923"></a>

        <div class="method-heading">


          <a href="#M001923" class="method-signature">



          <span class="method-name">eq_rp</span><span class="method-args">( rp ) result(eq_rp)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001923">eq_rp</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>rp  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm,0:im-1), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからスペクトルデータへ変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001923-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001923-source">
<pre>
    function eq_rp(rp)
      !
      ! 格子データからスペクトルデータへ変換する.
      !
      real(8), dimension(-km:km,0:lm)              :: eq_rp
      !(out) スペクトルデータ

      real(8), dimension(jm,0:im-1), intent(in)    :: rp
      !(in) 格子点データ

      eq_rp = aq_ar(transpose(ae_ap(rp)))

    end function eq_rp
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001930" class="method-detail">
        <a name="M001930"></a>

        <div class="method-heading">


          <a href="#M001930" class="method-signature">



          <span class="method-name">er_Lapla_eq</span><span class="method-args">( eq ) result(er_Lapla_eq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001930">er_Lapla_eq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータのラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>eq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータにラプラシアン
</p>
<pre>
 (1/r)(∂r(r∂r)+ (1/r^2) ∂φφ を作用する.
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001930-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001930-source">
<pre>
    function er_Lapla_eq(eq)
      !
      ! 入力スペクトルデータにラプラシアン 
      !  (1/r)(∂r(r∂r)+ (1/r^2) ∂φφ を作用する.
      !
      real(8), dimension(-km:km,jm)                :: er_Lapla_eq
      !(out) スペクトルデータのラプラシアン

      real(8), dimension(-km:km,0:lm), intent(in)  :: eq
      !(in) 入力スペクトルデータ

      real(8), dimension(-km:km,0:lm)              :: eq_work

      integer k

      do k=-km,km
         eq_work(k,:) = -k**2 * eq(k,:)
      enddo

      er_Lapla_eq = er_eq(eq_work + eq_RadDRad_eq(eq_RadDRad_eq(eq)))/er_Rad**2

    end function er_Lapla_eq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001920" class="method-detail">
        <a name="M001920"></a>

        <div class="method-heading">




          <span class="method-name">er_Rad</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001920">er_Rad</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), allocatable</tt>

</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001925" class="method-detail">
        <a name="M001925"></a>

        <div class="method-heading">


          <a href="#M001925" class="method-signature">



          <span class="method-name">er_eq</span><span class="method-args">( eq ) result(er_eq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001925">er_eq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>eq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
動径格子データからスペクトルデータへ変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001925-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001925-source">
<pre>
    function er_eq(eq)
      !
      ! 動径格子データからスペクトルデータへ変換する.
      !
      real(8), dimension(-km:km,jm)                :: er_eq
      !(out) 格子点データ

      real(8), dimension(-km:km,0:lm), intent(in)  :: eq
      !(out) スペクトルデータ

      er_eq = ar_aq(eq)

    end function er_eq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001927" class="method-detail">
        <a name="M001927"></a>

        <div class="method-heading">


          <a href="#M001927" class="method-signature">



          <span class="method-name">er_rp</span><span class="method-args">( rp ) result(er_rp)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001927">er_rp</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>rp  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm,0:im-1), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからスペクトルデータへ変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001927-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001927-source">
<pre>
    function er_rp(rp)
      !
      ! 格子データからスペクトルデータへ変換する.
      !
      real(8), dimension(-km:km,jm)                :: er_rp
      !(out) スペクトルデータ

      real(8), dimension(jm,0:im-1), intent(in)    :: rp
      !(in) 格子点データ

      er_rp = transpose(ae_ap(rp))

    end function er_rp
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001943" class="method-detail">
        <a name="M001943"></a>

        <div class="method-heading">


          <a href="#M001943" class="method-signature">



          <span class="method-name">p_AvrRad_rp</span><span class="method-args">( rp ) result(p_AvrRad_rp)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001943">p_AvrRad_rp</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元(Phi)格子点

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>rp  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元格子点データの Rad 方向平均
</p>
<p>
実際には格子点データ各点毎に <a
href="eq_module.html#M001949">r_Rad_Weight</a> をかけた総和を計算し, <a
href="eq_module.html#M001949">r_Rad_Weight</a>
の総和で割ることで平均している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001943-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001943-source">
<pre>
    function p_AvrRad_rp(rp)
      !
      ! 2 次元格子点データの Rad 方向平均
      !
      ! 実際には格子点データ各点毎に r_Rad_Weight をかけた総和を計算し, 
      ! r_Rad_Weight の総和で割ることで平均している. 
      !
      real(8), dimension(jm,0:im-1)   :: rp
      !(in) 2 次元格子点データ

      real(8), dimension(0:im-1)      :: p_AvrRad_rp
      !(out) 平均された 1 次元(Phi)格子点

      p_AvrRad_rp = p_IntRad_rp(rp)/sum(r_Rad_weight)
    end function p_AvrRad_rp
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001938" class="method-detail">
        <a name="M001938"></a>

        <div class="method-heading">


          <a href="#M001938" class="method-signature">



          <span class="method-name">p_IntRad_rp</span><span class="method-args">( rp ) result(p_IntRad_rp)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001938">p_IntRad_rp</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元(Phi)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>rp  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元格子点データの Rad 方向積分
</p>
<p>
実際には格子点データ各点毎に <a
href="eq_module.html#M001949">r_Rad_Weight</a> をかけた総和を計算している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001938-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001938-source">
<pre>
    function p_IntRad_rp(rp)
      !
      ! 2 次元格子点データの Rad 方向積分
      !
      ! 実際には格子点データ各点毎に r_Rad_Weight をかけた総和を計算している. 
      !
      real(8), dimension(jm,0:im-1)   :: rp
      !(in)  2 次元格子点データ

      real(8), dimension(0:im-1)      :: p_IntRad_rp
      !(out) 積分された 1 次元(Phi)格子点データ

      integer :: j
      ! 作業変数

      p_IntRad_rp = 0.0d0
      do j=1,jm
         p_IntRad_rp(:) = p_IntRad_rp(:) + rp(j,:) * r_Rad_Weight(j)
      enddo
    end function p_IntRad_rp
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001946" class="method-detail">
        <a name="M001946"></a>

        <div class="method-heading">




          <span class="method-name">p_Phi</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>g_x(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点座標(X)を格納した 1 次元配列.

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="ae_module.html#M001546">ae_module#g_x</a>
</p>


        </div>
      </div>


      <div id="method-M001947" class="method-detail">
        <a name="M001947"></a>

        <div class="method-heading">




          <span class="method-name">p_Phi_weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>g_x_weight(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 重み座標を格納した 1 次元配列. X 方向の格子点の間隔が格納してある.

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="ae_module.html#M001547">ae_module#g_x_weight</a>
</p>


        </div>
      </div>


      <div id="method-M001951" class="method-detail">
        <a name="M001951"></a>

        <div class="method-heading">




          <span class="method-name">p_e</span><span class="method-args">( e ) result(g_e)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>g_e  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>e  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子点データへ変換する(1 次元データ用)
</p>
<p>
Original external subprogram is <a
href="ae_module.html#M001550">ae_module#g_e</a>
</p>


        </div>
      </div>


      <div id="method-M001960" class="method-detail">
        <a name="M001960"></a>

        <div class="method-heading">




          <span class="method-name">q_RadDRad_q</span><span class="method-args">( q_data ) result(q_rDr_q)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>q_rDr_q  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの R 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに r(d/dR) 微分を作用する(1 次元配列用).
</p>
<p>
スペクトルデータの r(d/dR) 微分とは, 対応する格子点データに R 微分を
作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="aq_module.html#M001989">aq_module#q_rDr_q</a>
</p>


        </div>
      </div>


      <div id="method-M001954" class="method-detail">
        <a name="M001954"></a>

        <div class="method-heading">




          <span class="method-name">q_r</span><span class="method-args">( g_data ) result(q_g)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>q_g  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>g_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからスペクトルデータへ変換する(1 次元配列用).
</p>
<p>
Original external subprogram is <a
href="aq_module.html#M001987">aq_module#q_g</a>
</p>


        </div>
      </div>


      <div id="method-M001942" class="method-detail">
        <a name="M001942"></a>

        <div class="method-heading">


          <a href="#M001942" class="method-signature">



          <span class="method-name">r_AvrPhi_rp</span><span class="method-args">( rp ) result(r_AvrPhi_rp)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001942">r_AvrPhi_rp</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元(Rad)格子点

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>rp  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元格子点データの Phi 方向平均
</p>
<p>
実際には格子点データ各点毎に <a
href="eq_module.html#M001947">p_Phi_Weight</a> をかけた総和を計算し, <a
href="eq_module.html#M001947">p_Phi_Weight</a>
の総和で割ることで平均している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001942-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001942-source">
<pre>
    function r_AvrPhi_rp(rp)
      !
      ! 2 次元格子点データの Phi 方向平均
      !
      ! 実際には格子点データ各点毎に p_Phi_Weight をかけた総和を計算し, 
      ! p_Phi_Weight の総和で割ることで平均している. 
      !
      real(8), dimension(jm,0:im-1)   :: rp
      !(in) 2 次元格子点データ

      real(8), dimension(jm)          :: r_AvrPhi_rp
      !(out) 平均された 1 次元(Rad)格子点

      r_AvrPhi_rp = r_IntPhi_rp(rp)/sum(p_Phi_weight)
    end function r_AvrPhi_rp
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001937" class="method-detail">
        <a name="M001937"></a>

        <div class="method-heading">


          <a href="#M001937" class="method-signature">



          <span class="method-name">r_IntPhi_rp</span><span class="method-args">( rp ) result(r_IntPhi_rp)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001937">r_IntPhi_rp</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元(Rad)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>rp  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元格子点データの Phi 方向積分
</p>
<p>
実際には格子点データ各点毎に <a
href="eq_module.html#M001947">p_Phi_Weight</a> をかけた総和を計算している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001937-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001937-source">
<pre>
    function r_IntPhi_rp(rp)
      !
      ! 2 次元格子点データの Phi 方向積分
      !
      ! 実際には格子点データ各点毎に p_Phi_Weight をかけた総和を計算している. 
      !
      real(8), dimension(jm,0:im-1)   :: rp
      !(in) 2 次元格子点データ

      real(8), dimension(jm)          :: r_IntPhi_rp
      !(out) 積分された 1 次元(Rad)格子点データ

      integer :: i
      ! 作業変数

      r_IntPhi_rp = 0.0d0
      do i=0,im-1
         r_IntPhi_rp(:) = r_IntPhi_rp(:) + rp(:,i) * p_Phi_Weight(i)
      enddo
    end function r_IntPhi_rp
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001948" class="method-detail">
        <a name="M001948"></a>

        <div class="method-heading">




          <span class="method-name">r_Rad</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>g_R(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> ガウス&#8212;ラダウ格子点

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="aq_module.html#M001981">aq_module#g_R</a>
</p>


        </div>
      </div>


      <div id="method-M001949" class="method-detail">
        <a name="M001949"></a>

        <div class="method-heading">




          <span class="method-name">r_Rad_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>g_R_Weight(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> ガウス重み

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="aq_module.html#M001982">aq_module#g_R_Weight</a>
</p>


        </div>
      </div>


      <div id="method-M001955" class="method-detail">
        <a name="M001955"></a>

        <div class="method-heading">




          <span class="method-name">r_q</span><span class="method-args">( q_data ) result(g_q)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>g_q  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(im)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子データへ変換する(1 次元配列用).
</p>
<p>
Original external subprogram is <a
href="aq_module.html#M001985">aq_module#g_q</a>
</p>


        </div>
      </div>


      <div id="method-M001918" class="method-detail">
        <a name="M001918"></a>

        <div class="method-heading">




          <span class="method-name">rp_Phi</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001918">rp_Phi</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), allocatable</tt>

</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001919" class="method-detail">
        <a name="M001919"></a>

        <div class="method-heading">




          <span class="method-name">rp_Rad</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001919">rp_Rad</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), allocatable</tt>

</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001922" class="method-detail">
        <a name="M001922"></a>

        <div class="method-heading">


          <a href="#M001922" class="method-signature">



          <span class="method-name">rp_eq</span><span class="method-args">( eq ) result(rp_eq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001922">rp_eq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>eq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子データへ変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001922-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001922-source">
<pre>
    function rp_eq(eq)
      !
      ! スペクトルデータから格子データへ変換する.
      !
      real(8), dimension(jm,0:im-1)                :: rp_eq
      !(out) 格子点データ

      real(8), dimension(-km:km,0:lm), intent(in)  :: eq
      !(in) スペクトルデータ

      rp_eq = ap_ae(transpose(ar_aq(eq)))

    end function rp_eq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001926" class="method-detail">
        <a name="M001926"></a>

        <div class="method-heading">


          <a href="#M001926" class="method-signature">



          <span class="method-name">rp_er</span><span class="method-args">( er ) result(rp_er)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="eq_module.html#M001926">rp_er</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>er  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,jm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子データへ変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001926-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001926-source">
<pre>
    function rp_er(er)
      !
      ! スペクトルデータから格子データへ変換する.
      !
      real(8), dimension(jm,0:im-1)              :: rp_er
      !(out) 格子点データ

      real(8), dimension(-km:km,jm), intent(in)  :: er
      !(in) スペクトルデータ

      rp_er = ap_ae(transpose(er))

    end function rp_er
</pre>
          </div>

        </div>
      </div>



    </div>



  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
