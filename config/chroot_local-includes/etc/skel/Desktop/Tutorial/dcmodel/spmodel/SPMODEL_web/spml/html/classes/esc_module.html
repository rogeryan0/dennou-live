<?xml version="1.0" encoding="euc-jp"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: esc_module</title>
  <meta http-equiv="Content-Type" content="text/html; charset=euc-jp" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">esc_module</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../files/src/esc_module_f90.html">

                src/esc_module.f90

                </a>


        <br />
            </td>
        </tr>


        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">


  <div id="contextContent">



    <div id="description">
      <h1><a href="esc_module.html">esc_module</a></h1>
<table>
<tr><td valign="top">Authors:</td><td>Shin-ichi Takehiro, Youhei SASAKI

</td></tr>
<tr><td valign="top">Version:</td><td>$Id: <a href="../files/src/esc_module_f90.html">esc_module.f90</a>,v 1.14
2009-02-28 21:33:46 uwabami Exp $

</td></tr>
<tr><td valign="top">Copyright&amp;License:</td><td>See <a href="../../COPYRIGHT">COPYRIGHT</a>

</td></tr>
</table>
<h2>概要</h2>
<p>
spml/esc_module モジュールは 2 次元チャネル領域での流体運動を
スペクトル法により数値計算するための Fortran90 関数を提供する.
</p>
<p>
内部で ISPACK/C2PACK の Fortran77 サブルーチンを呼んでいる.
スペクトルデータおよび格子点データの格納方法については ISPACK/C2PACK
のマニュアルを参照されたい.
</p>
<h2>関数・変数の名前と型について</h2>
<h3>命名法</h3>
<ul>
<li>関数名の先頭 (es_, ec_, yx_, x_, y_) は, 返す値の形を示している.

<table>
<tr><td valign="top">es_,ec_ :</td><td>スペクトルデータ(Y 方向 SIN 展開, COS 展開)

</td></tr>
<tr><td valign="top">yx_     :</td><td>2 次元格子点データ

</td></tr>
<tr><td valign="top">x_      :</td><td>X 方向 1 次元格子点データ

</td></tr>
<tr><td valign="top">y_      :</td><td>Y 方向 1 次元格子点データ

</td></tr>
</table>
</li>
<li>関数名の間の文字列(Dx, Dy, Lapla, LaplaInv, Jacobian)は,
その関数の作用を表している.

</li>
<li>関数名の最後 (_es_es, _es_ec, _es, _ec, _yx, _x, _y) は,
入力変数の形スペクトルデータおよび格子点データであることを示している.

<table>
<tr><td valign="top">_es    :</td><td>スペクトルデータ(Y 方向 SIN 型)

</td></tr>
<tr><td valign="top">_ec    :</td><td>スペクトルデータ(Y 方向 COS 型)

</td></tr>
<tr><td valign="top">_es_es :</td><td>2 つのスペクトルデータ

</td></tr>
<tr><td valign="top">_es_ec :</td><td>2 つのスペクトルデータ

</td></tr>
<tr><td valign="top">_yx    :</td><td>2 次元格子点データ,

</td></tr>
<tr><td valign="top">_x     :</td><td>X 方向 1 次元格子点データ

</td></tr>
<tr><td valign="top">_y     :</td><td>Y 方向 1 次元格子点データ

</td></tr>
</table>
</li>
</ul>
<h3>各データの種類の説明</h3>
<ul>
<li>yx : 2 次元格子点データ.

</li>
</ul>
<pre>
 * 変数の種類と次元は real(8), dimension(0:jm,0:im-1).
 * im, jm はそれぞれ X, Y 座標の格子点数であり,
   サブルーチン esc_Initial にてあらかじめ設定しておく.
 * 第 1 次元が Y 座標の格子点位置番号, 第 2 次元が X 座標の格子点位置番号
   である (X, Y の順ではない)ことに注意.
</pre>
<ul>
<li>es : X 方向フーリエ型, Y 方向 SIN 型スペクトルデータ.

<ul>
<li>変数の種類と次元は real(8), dimension(-km:km,lm).

</li>
<li>km, lm はそれぞれ X, Y 方向の最大波数であり, サブルーチン <a
href="esc_module.html#M000785">esc_Initial</a> にて あらかじめ設定しておく.

</li>
<li>スペクトルデータの格納のされ方については&#8230;

</li>
</ul>
</li>
<li>ec : X 方向フーリエ型, Y 方向 COS 型スペクトルデータ.

<ul>
<li>変数の種類と次元は real(8), dimension(-km:km,0:lm).

</li>
<li>km, lm はそれぞれ X, Y 方向の最大波数であり, サブルーチン <a
href="esc_module.html#M000785">esc_Initial</a> にてあらかじめ設定しておく.

</li>
<li>スペクトルデータの格納のされ方については&#8230;

</li>
</ul>
</li>
<li>x, y : X, Y 方向 1 次元格子点データ.

<ul>
<li>変数の種類と次元はそれぞれ real(8), dimension(0:im-1) および real(8),
dimension(0:jm).

</li>
</ul>
</li>
<li>es_, ec_ で始まる関数が返す値はスペクトルデータに同じ.

</li>
<li>yx_ で始まる関数が返す値は 2 次元格子点データに同じ.

</li>
<li>x_, y_ で始まる関数が返す値は 1 次元格子点データに同じ.

</li>
<li>スペクトルデータに対する微分等の作用とは, 対応する格子点データに
微分などを作用させたデータをスペクトル変換したものことである.

</li>
</ul>
<h2>変数・手続き群の要約</h2>
<h4>初期化</h4>
<table>
<tr><td valign="top"><a href="esc_module.html#M000785">esc_initial</a> :</td><td>スペクトル変換の格子点数, 波数, 領域の大きさの設定

</td></tr>
</table>
<h4>座標変数</h4>
<table>
<tr><td valign="top"><a href="esc_module.html#M000779">x_X</a>, <a href="esc_module.html#M000780">y_Y</a>     :</td><td>格子点座標(X,Y座標)を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="esc_module.html#M000781">x_X_Weight</a>, <a href="esc_module.html#M000782">y_Y_Weight</a> :</td><td>重み座標を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="esc_module.html#M000783">yx_X</a>, <a href="esc_module.html#M000784">yx_Y</a>   :</td><td>格子点データの XY 座標(X,Y)(格子点データ型 2 次元配列)

</td></tr>
</table>
<h4>基本変換</h4>
<table>
<tr><td valign="top"><a href="esc_module.html#M000786">yx_es</a>, <a href="esc_module.html#M000787">yx_ec</a> :</td><td>スペクトルデータから格子データへの変換

</td></tr>
<tr><td valign="top"><a href="esc_module.html#M000788">es_yx</a>, <a href="esc_module.html#M000789">ec_yx</a> :</td><td>格子データからスペクトルデータへの変換

</td></tr>
</table>
<h4>微分</h4>
<table>
<tr><td valign="top"><a href="esc_module.html#M000790">es_Lapla_es</a>, <a href="esc_module.html#M000791">ec_Lapla_ec</a>  :</td><td>スペクトルデータにラプラシアンを作用させる

</td></tr>
<tr><td valign="top"><a href="esc_module.html#M000792">es_LaplaInv_es</a>, <a href="esc_module.html#M000793">ec_LaplaInv_ec</a> :</td><td>スペクトルデータに ラプラシアンの逆変換を作用させる

</td></tr>
<tr><td valign="top"><a href="esc_module.html#M000794">es_Dx_es</a>, <a href="esc_module.html#M000795">ec_Dx_ec</a>  :</td><td>スペクトルデータに X 微分を作用させる

</td></tr>
<tr><td valign="top"><a href="esc_module.html#M000796">ec_Dy_es</a>, <a href="esc_module.html#M000797">es_Dy_ec</a>  :</td><td>スペクトルデータに Y 微分を作用させる

</td></tr>
<tr><td valign="top"><a href="esc_module.html#M000798">es_Jacobian_es_es</a>, <a href="esc_module.html#M000799">ec_Jacobian_es_ec</a> :</td><td>2 つのスペクトルデータから ヤコビアンを計算する

</td></tr>
</table>
<h4>積分・平均</h4>
<table>
<tr><td valign="top"><a href="esc_module.html#M000800">IntYX_yx</a>, <a href="esc_module.html#M000805">AvrYX_yx</a>   :</td><td>2 次元格子点データの全領域積分および平均

</td></tr>
<tr><td valign="top"><a href="esc_module.html#M000801">y_IntX_yx</a>, <a href="esc_module.html#M000806">y_AvrX_yx</a> :</td><td>2 次元格子点データの X 方向積分および平均

</td></tr>
<tr><td valign="top"><a href="esc_module.html#M000803">IntX_x</a>, <a href="esc_module.html#M000808">AvrX_x</a>       :</td><td>1 次元(X)格子点データの X 方向積分および平均

</td></tr>
<tr><td valign="top"><a href="esc_module.html#M000802">x_IntY_yx</a>, <a href="esc_module.html#M000807">x_AvrY_yx</a> :</td><td>2 次元格子点データの Y 方向積分および平均

</td></tr>
<tr><td valign="top"><a href="esc_module.html#M000804">IntY_y</a>, <a href="esc_module.html#M000809">AvrY_y</a>       :</td><td>1 次元(Y)格子点データの Y 方向積分および平均

</td></tr>
</table>

    </div>





   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M000808">AvrX_x</a>&nbsp;&nbsp;

        <a href="#M000805">AvrYX_yx</a>&nbsp;&nbsp;

        <a href="#M000809">AvrY_y</a>&nbsp;&nbsp;

        <a href="#M000803">IntX_x</a>&nbsp;&nbsp;

        <a href="#M000800">IntYX_yx</a>&nbsp;&nbsp;

        <a href="#M000804">IntY_y</a>&nbsp;&nbsp;

        <a href="#M000795">ec_Dx_ec</a>&nbsp;&nbsp;

        <a href="#M000796">ec_Dy_es</a>&nbsp;&nbsp;

        <a href="#M000799">ec_Jacobian_es_ec</a>&nbsp;&nbsp;

        <a href="#M000793">ec_LaplaInv_ec</a>&nbsp;&nbsp;

        <a href="#M000791">ec_Lapla_ec</a>&nbsp;&nbsp;

        <a href="#M000789">ec_yx</a>&nbsp;&nbsp;

        <a href="#M000794">es_Dx_es</a>&nbsp;&nbsp;

        <a href="#M000797">es_Dy_ec</a>&nbsp;&nbsp;

        <a href="#M000798">es_Jacobian_es_es</a>&nbsp;&nbsp;

        <a href="#M000792">es_LaplaInv_es</a>&nbsp;&nbsp;

        <a href="#M000790">es_Lapla_es</a>&nbsp;&nbsp;

        <a href="#M000788">es_yx</a>&nbsp;&nbsp;

        <a href="#M000785">esc_Initial</a>&nbsp;&nbsp;

        <a href="#M000807">x_AvrY_yx</a>&nbsp;&nbsp;

        <a href="#M000802">x_IntY_yx</a>&nbsp;&nbsp;

        <a href="#M000779">x_X</a>&nbsp;&nbsp;

        <a href="#M000781">x_X_Weight</a>&nbsp;&nbsp;

        <a href="#M000806">y_AvrX_yx</a>&nbsp;&nbsp;

        <a href="#M000801">y_IntX_yx</a>&nbsp;&nbsp;

        <a href="#M000780">y_Y</a>&nbsp;&nbsp;

        <a href="#M000782">y_Y_Weight</a>&nbsp;&nbsp;

        <a href="#M000783">yx_X</a>&nbsp;&nbsp;

        <a href="#M000784">yx_Y</a>&nbsp;&nbsp;

        <a href="#M000787">yx_ec</a>&nbsp;&nbsp;

        <a href="#M000786">yx_es</a>&nbsp;&nbsp;
      </div>
    </div>


  </div>


    <!-- if includes -->

    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">

        <span class="include-name">dc_message</span>
      </div>
    </div>



    <div id="section">










      


    <!-- if method_list -->

    <div id="methods">


      <h3 class="section-bar">Public Instance methods</h3>


      <div id="method-M000808" class="method-detail">
        <a name="M000808"></a>

        <div class="method-heading">


          <a href="#M000808" class="method-signature">



          <span class="method-name">AvrX_x</span><span class="method-args">( x ) result(AvrX_x)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000808">AvrX_x</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>x  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元(X)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
X 方向平均
</p>
<p>
1 次元(X)格子点データの X 方向平均
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000808-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000808-source">
<pre>
    function AvrX_x(x)       ! X 方向平均
      !
      ! 1 次元(X)格子点データの X 方向平均
      !
      real(8), dimension(0:im-1)   :: x
      !(in) 1 次元(X)格子点データ

      real(8)                      :: AvrX_x
      !(out) 平均値

      AvrX_x = IntX_x(x)/sum(x_X_weight)
    end function AvrX_x
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000805" class="method-detail">
        <a name="M000805"></a>

        <div class="method-heading">


          <a href="#M000805" class="method-signature">



          <span class="method-name">AvrYX_yx</span><span class="method-args">( yx ) result(AvrYX_yx)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000805">AvrYX_yx</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yx  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
全領域平均
</p>
<p>
2 次元格子点データの全領域平均
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000805-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000805-source">
<pre>
    function AvrYX_yx(yx)    ! 全領域平均
      !
      ! 2 次元格子点データの全領域平均
      !
      real(8), dimension(0:jm,0:im-1)   :: yx
      !(in) 2 次元格子点データ

      real(8)                           :: AvrYX_yx
      !(out) 平均値

      AvrYX_yx = IntYX_yx(yx)/(sum(x_X_weight)*sum(y_Y_weight))
    end function AvrYX_yx
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000809" class="method-detail">
        <a name="M000809"></a>

        <div class="method-heading">


          <a href="#M000809" class="method-signature">



          <span class="method-name">AvrY_y</span><span class="method-args">( y ) result(AvrY_y)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000809">AvrY_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元(Y)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
Y 方向平均
</p>
<p>
1 次元(Y)格子点データの Y 方向平均
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000809-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000809-source">
<pre>
    function AvrY_y(y)       ! Y 方向平均
      !
      ! 1 次元(Y)格子点データの Y 方向平均
      !
      real(8), dimension(0:jm)   :: y
      !(in) 1 次元(Y)格子点データ

      real(8)                    :: AvrY_y
      ! 平均値

      AvrY_y = IntY_y(y)/sum(y_Y_weight)
    end function AvrY_y
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000803" class="method-detail">
        <a name="M000803"></a>

        <div class="method-heading">


          <a href="#M000803" class="method-signature">



          <span class="method-name">IntX_x</span><span class="method-args">( x ) result(IntX_x)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000803">IntX_x</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>x  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元(X)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
X 方向積分
</p>
<p>
1 次元(X)格子点データの X 方向積分
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000803-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000803-source">
<pre>
    function IntX_x(x)      ! X 方向積分
      !
      ! 1 次元(X)格子点データの X 方向積分
      !
      real(8), dimension(0:im-1)   :: x
      !(in) 1 次元(X)格子点データ

      real(8)                      :: IntX_x
      !(out) 積分値

      IntX_x = sum(x*x_X_Weight)
    end function IntX_x
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000800" class="method-detail">
        <a name="M000800"></a>

        <div class="method-heading">


          <a href="#M000800" class="method-signature">



          <span class="method-name">IntYX_yx</span><span class="method-args">( yx ) result(IntYX_yx)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000800">IntYX_yx</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yx  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元格子点データの全領域積分および平均.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000800-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000800-source">
<pre>
    function IntYX_yx(yx)
      !
      ! 2 次元格子点データの全領域積分および平均.
      !
      real(8), dimension(0:jm,0:im-1)   :: yx
      !(in) 2 次元格子点データ

      real(8)                           :: IntYX_yx
      !(out) 積分値

      integer :: i, j

      IntYX_yx = 0.0d0
      do i=0,im-1
         do j=0,jm
            IntYX_yx = IntYX_yx + yx(j,i) * y_Y_Weight(j) * x_X_Weight(i)
         enddo
      enddo
    end function IntYX_yx
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000804" class="method-detail">
        <a name="M000804"></a>

        <div class="method-heading">


          <a href="#M000804" class="method-signature">



          <span class="method-name">IntY_y</span><span class="method-args">( y ) result(IntY_y)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000804">IntY_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元(Y)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
Y 方向積分
</p>
<p>
1 次元(Y)格子点データの Y 方向積分
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000804-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000804-source">
<pre>
    function IntY_y(y)      ! Y 方向積分
      !
      ! 1 次元(Y)格子点データの Y 方向積分
      !
      real(8), dimension(0:jm)   :: y
      !(in) 1 次元(Y)格子点データ

      real(8)                    :: IntY_y
      !(out) 積分値

      IntY_y = sum(y*y_Y_Weight)
    end function IntY_y
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000795" class="method-detail">
        <a name="M000795"></a>

        <div class="method-heading">


          <a href="#M000795" class="method-signature">



          <span class="method-name">ec_Dx_ec</span><span class="method-args">( ec ) result(ec_Dx_ec)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000795">ec_Dx_ec</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの X 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ec  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) COS(Y)型入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
COS(Y)型入力スペクトルデータに X 微分(∂x)を作用する.
</p>
<p>
スペクトルデータの X 微分とは, 対応する格子点データに X 微分を
作用させたデータのスペクトル変換のことである.
</p>
<p>
実際にはスペクトルデータに X 方向波数 k をかけて sin(kx) &lt;-&gt; cos(kx)
成分に入れ換える計算を行っている.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000795-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000795-source">
<pre>
    function ec_Dx_ec(ec)
      !
      ! COS(Y)型入力スペクトルデータに X 微分(∂x)を作用する.
      !
      ! スペクトルデータの X 微分とは, 対応する格子点データに X 微分を
      ! 作用させたデータのスペクトル変換のことである.
      !
      ! 実際にはスペクトルデータに X 方向波数 k をかけて
      ! sin(kx) &lt;-&gt; cos(kx) 成分に入れ換える計算を行っている.
      !
      real(8), dimension(-km:km,0:lm)                :: ec_Dx_ec
      !(out) スペクトルデータの X 微分

      real(8), dimension(-km:km,0:lm), intent(in)    :: ec
      !(in) COS(Y)型入力スペクトルデータ

      integer k,l

      do l=0,lm
         do k=-km,km
            ec_Dx_ec(k,l)  =  (-2*pi*k/xl)*ec(-k,l)
         enddo
      enddo
    end function ec_Dx_ec
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000796" class="method-detail">
        <a name="M000796"></a>

        <div class="method-heading">


          <a href="#M000796" class="method-signature">



          <span class="method-name">ec_Dy_es</span><span class="method-args">( es ) result(ec_Dy_es)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000796">ec_Dy_es</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの Y 微分, COS(Y)型.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>es  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) SIN(Y)型入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル SINY に作用する y 微分演算子
</p>
<p>
SIN(Y)型入力スペクトルデータに Y 微分(∂y)を作用する.
</p>
<p>
スペクトルデータの X 微分とは, 対応する格子点データに Y 微分を
作用させたデータのスペクトル変換のことである.
</p>
<p>
実際にはスペクトルデータに X 方向波数 l をかけている.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000796-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000796-source">
<pre>
    function ec_Dy_es(es)   ! スペクトル SINY に作用する y 微分演算子
      !
      ! SIN(Y)型入力スペクトルデータに Y 微分(∂y)を作用する.
      !
      ! スペクトルデータの X 微分とは, 対応する格子点データに Y 微分を
      ! 作用させたデータのスペクトル変換のことである.
      !
      ! 実際にはスペクトルデータに X 方向波数 l をかけている. 
      !
      real(8), dimension(-km:km,0:lm)              :: ec_Dy_es
      !(out) スペクトルデータの Y 微分, COS(Y)型.

      real(8), dimension(-km:km,lm), intent(in)    :: es
      !(in) SIN(Y)型入力スペクトルデータ

      integer k,l

      do k=-km,km
         ec_Dy_es(k,0)  =  0.0
      enddo
      do l=1,lm
         do k=-km,km
            ec_Dy_es(k,l)  =  (pi*l/yl)*es(k,l)
         enddo
      enddo
    end function ec_Dy_es
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000799" class="method-detail">
        <a name="M000799"></a>

        <div class="method-heading">


          <a href="#M000799" class="method-signature">



          <span class="method-name">ec_Jacobian_es_ec</span><span class="method-args">( es, ec ) result(ec_Jacobian_es_ec)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000799">ec_Jacobian_es_ec</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 つのスペクトルデータのヤコビアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>es  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1つ目の SIN(Y)型入力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ec  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2つ目の COS(Y)型入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル COS(Y) に作用するヤコビアン
</p>
<pre>
 2 つのスペクトルデータからヤコビアン

    J(A,B)=(∂xA)(∂yB)-(∂yA)(∂xB)

 を計算する.

 2 つのスペクトルデータのヤコビアンとは, 対応する 2 つの
 格子点データのヤコビアンのスペクトル変換のことである.
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000799-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000799-source">
<pre>
    function ec_Jacobian_es_ec(es,ec)  ! スペクトル COS(Y) に作用するヤコビアン
      !
      !  2 つのスペクトルデータからヤコビアン
      !
      !     J(A,B)=(∂xA)(∂yB)-(∂yA)(∂xB)
      !
      !  を計算する.
      !
      !  2 つのスペクトルデータのヤコビアンとは, 対応する 2 つの
      !  格子点データのヤコビアンのスペクトル変換のことである.
      !
      real(8), dimension(-km:km,0:lm)              :: ec_Jacobian_es_ec
      !(out) 2 つのスペクトルデータのヤコビアン

      real(8), dimension(-km:km,lm), intent(in)    :: es
      !(in) 1つ目の SIN(Y)型入力スペクトルデータ

      real(8), dimension(-km:km,0:lm), intent(in)  :: ec
      !(in) 2つ目の COS(Y)型入力スペクトルデータ

      integer k,l

      call c2ajcc(lm,km,jm,im,es,ec,ec_work,ws,wgj,itj,tj,iti,ti)

      do l=0,lm
         do k=-km,km
            ec_Jacobian_es_ec(k,l) = (2*pi/xl)*(pi/yl)*ec_work(k,l)
         enddo
      enddo
    end function ec_Jacobian_es_ec
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000793" class="method-detail">
        <a name="M000793"></a>

        <div class="method-heading">


          <a href="#M000793" class="method-signature">



          <span class="method-name">ec_LaplaInv_ec</span><span class="method-args">( ec ) result(ec_LaplaInv_ec)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000793">ec_LaplaInv_ec</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの逆ラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ec  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) SIN(Y)型スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル COSY に作用する逆 lapla 演算子
</p>
<p>
入力スペクトルデータに逆ラプラシアン(∂xx+∂yy)**(-1)を作用する.
</p>
<p>
スペクトルデータの逆ラプラシアンとは, 対応する格子点データに
逆ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>
<p>
実際にはスペクトルデータに全波数 (k**2 + l**2) で割る 計算を行っている.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000793-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000793-source">
<pre>
    function ec_LaplaInv_ec(ec)   ! スペクトル COSY に作用する逆 \lapla 演算子
      !
      ! 入力スペクトルデータに逆ラプラシアン(∂xx+∂yy)**(-1)を作用する.
      !
      ! スペクトルデータの逆ラプラシアンとは, 対応する格子点データに
      ! 逆ラプラシアンを作用させたデータのスペクトル変換のことである.
      !
      ! 実際にはスペクトルデータに全波数 (k**2 + l**2) で割る
      ! 計算を行っている. 
      !
      real(8), dimension(-km:km,0:lm)              :: ec_LaplaInv_ec
      !(out) スペクトルデータの逆ラプラシアン

      real(8), dimension(-km:km,0:lm), intent(in)  :: ec
      !(in) SIN(Y)型スペクトルデータ

      integer k,l

      if ( ec(0,0) .ne. 0.0D0 ) then
           call MessageNotify('W','ec_LaplaInv_ec', '0-0 component of input data is not zero.')
           call MessageNotify('W','ec_LaplaInv_ec', '0-0 component of output set to zero.')
      endif

      do l=1,lm
         do k=-km,km
            ec_LaplaInv_ec(k,l) = -ec(k,l)/((2*pi*k/xl)**2+(pi*l/yl)**2)
         enddo
      enddo

      do k=1,km
         ec_LaplaInv_ec(k,0)  = -ec(k,0)/(2*pi*k/xl)**2
         ec_LaplaInv_ec(-k,0) = -ec(-k,0)/(2*pi*k/xl)**2
      enddo

      ec_LaplaInv_ec(0,0) = 0.0

    end function ec_LaplaInv_ec
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000791" class="method-detail">
        <a name="M000791"></a>

        <div class="method-heading">


          <a href="#M000791" class="method-signature">



          <span class="method-name">ec_Lapla_ec</span><span class="method-args">( ec ) result(ec_Lapla_ec)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000791">ec_Lapla_ec</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータのラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ec  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) COS(Y)型入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
COS(Y)型入力スペクトルデータにラプラシアン(∂xx+∂yy)を作用する.
</p>
<p>
スペクトルデータのラプラシアンとは, 対応する格子点データに
ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>
<p>
実際にはスペクトルデータに全波数 (k**2 + l**2) をかける 計算を行っている.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000791-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000791-source">
<pre>
    function ec_Lapla_ec(ec)
      !
      ! COS(Y)型入力スペクトルデータにラプラシアン(∂xx+∂yy)を作用する.
      !
      ! スペクトルデータのラプラシアンとは, 対応する格子点データに
      ! ラプラシアンを作用させたデータのスペクトル変換のことである.
      !
      ! 実際にはスペクトルデータに全波数 (k**2 + l**2) をかける
      ! 計算を行っている. 
      !
      real(8), dimension(-km:km,0:lm)                :: ec_Lapla_ec
      !(out) スペクトルデータのラプラシアン

      real(8), dimension(-km:km,0:lm), intent(in)    :: ec
      !(in) COS(Y)型入力スペクトルデータ

      integer k,l

      do l=0,lm
         do k=-km,km
            ec_Lapla_ec(k,l) = -((2*pi*k/xl)**2+(pi*l/yl)**2)*ec(k,l)
         enddo
      enddo
    end function ec_Lapla_ec
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000789" class="method-detail">
        <a name="M000789"></a>

        <div class="method-heading">


          <a href="#M000789" class="method-signature">



          <span class="method-name">ec_yx</span><span class="method-args">( yx ) result(ec_yx)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000789">ec_yx</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) COS(Y)型スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yx  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm,0:im-1), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子データから COS(Y)型スペクトルデータへ変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000789-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000789-source">
<pre>
    function ec_yx(yx)
      !
      ! 格子データから COS(Y)型スペクトルデータへ変換する.
      !
      real(8), dimension(-km:km,0:lm)              :: ec_yx
      !(in) COS(Y)型スペクトルデータ

      real(8), dimension(0:jm,0:im-1), intent(in)  :: yx
      !(out) 格子点データ

      yx_work = yx
      call c2g2sa(lm,km,jm,im,yx_work,ec_yx,wg,itj,tj,iti,ti,2)
    end function ec_yx
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000794" class="method-detail">
        <a name="M000794"></a>

        <div class="method-heading">


          <a href="#M000794" class="method-signature">



          <span class="method-name">es_Dx_es</span><span class="method-args">( es ) result(es_Dx_es)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000794">es_Dx_es</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの X 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>es  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) SIN(Y)型入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
SIN(Y)型入力スペクトルデータに X 微分(∂x)を作用する.
</p>
<p>
スペクトルデータの X 微分とは, 対応する格子点データに X 微分を
作用させたデータのスペクトル変換のことである.
</p>
<p>
実際にはスペクトルデータに X 方向波数 k をかけて sin(kx) &lt;-&gt; cos(kx)
成分に入れ換える計算を行っている.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000794-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000794-source">
<pre>
    function es_Dx_es(es)
      !
      ! SIN(Y)型入力スペクトルデータに X 微分(∂x)を作用する.
      !
      ! スペクトルデータの X 微分とは, 対応する格子点データに X 微分を
      ! 作用させたデータのスペクトル変換のことである.
      !
      ! 実際にはスペクトルデータに X 方向波数 k をかけて
      ! sin(kx) &lt;-&gt; cos(kx) 成分に入れ換える計算を行っている.
      !
      real(8), dimension(-km:km,lm)                :: es_Dx_es
      !(out) スペクトルデータの X 微分

      real(8), dimension(-km:km,lm), intent(in)    :: es
      !(in) SIN(Y)型入力スペクトルデータ

      integer k,l

      do l=1,lm
         do k=-km,km
            es_Dx_es(k,l)  =  (-2*pi*k/xl)*es(-k,l)
         enddo
      enddo
    end function es_Dx_es
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000797" class="method-detail">
        <a name="M000797"></a>

        <div class="method-heading">


          <a href="#M000797" class="method-signature">



          <span class="method-name">es_Dy_ec</span><span class="method-args">( ec ) result(es_Dy_ec)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000797">es_Dy_ec</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの Y 微分, SIN(Y)型.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ec  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) COS(Y)型入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル COSY に作用する y 微分演算子
</p>
<p>
COS(Y)型入力スペクトルデータに Y 微分(∂y)を作用する.
</p>
<p>
スペクトルデータの X 微分とは, 対応する格子点データに Y 微分を
作用させたデータのスペクトル変換のことである.
</p>
<p>
実際にはスペクトルデータに X 方向波数 l をかけている.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000797-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000797-source">
<pre>
    function es_Dy_ec(ec)   ! スペクトル COSY に作用する y 微分演算子
      !
      ! COS(Y)型入力スペクトルデータに Y 微分(∂y)を作用する.
      !
      ! スペクトルデータの X 微分とは, 対応する格子点データに Y 微分を
      ! 作用させたデータのスペクトル変換のことである.
      !
      ! 実際にはスペクトルデータに X 方向波数 l をかけている. 
      !
      real(8), dimension(-km:km,lm)                 :: es_Dy_ec
      !(out) スペクトルデータの Y 微分, SIN(Y)型.

      real(8), dimension(-km:km,0:lm), intent(in)   :: ec
      !(in) COS(Y)型入力スペクトルデータ

      integer k,l

      do l=1,lm
         do k=-km,km
            es_Dy_ec(k,l)  =  -(pi*l/yl)*ec(k,l)
         enddo
      enddo
    end function es_Dy_ec
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000798" class="method-detail">
        <a name="M000798"></a>

        <div class="method-heading">


          <a href="#M000798" class="method-signature">



          <span class="method-name">es_Jacobian_es_es</span><span class="method-args">( ) result(es_Jacobian_es_es)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000798">es_Jacobian_es_es</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 つのスペクトルデータのヤコビアン

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル SINY に作用するヤコビアン
</p>
<pre>
 2 つのスペクトルデータからヤコビアン

    J(A,B)=(∂xA)(∂yB)-(∂yA)(∂xB)

 を計算する.

 2 つのスペクトルデータのヤコビアンとは, 対応する 2 つの
 格子点データのヤコビアンのスペクトル変換のことである.
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000798-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000798-source">
<pre>
    function es_Jacobian_es_es(es_a,es_b) !スペクトル SINY に作用するヤコビアン
      !
      !  2 つのスペクトルデータからヤコビアン
      !
      !     J(A,B)=(∂xA)(∂yB)-(∂yA)(∂xB)
      !
      !  を計算する.
      !
      !  2 つのスペクトルデータのヤコビアンとは, 対応する 2 つの
      !  格子点データのヤコビアンのスペクトル変換のことである.
      !
      real(8), dimension(-km:km,lm)                :: es_Jacobian_es_es
      !(out) 2 つのスペクトルデータのヤコビアン

      real(8), dimension(-km:km,lm), intent(in)    :: es_A,es_B
      !(in) 2つの SIN(Y)型入力スペクトルデータ

      integer k,l

      call c2ajcb(lm,km,jm,im,es_A,es_B,es_work,ws,wgj,itj,tj,iti,ti)

      do l=1,lm
         do k=-km,km
            es_Jacobian_es_es(k,l) = (2*pi/xl)*(pi/yl)*es_work(k,l)
         enddo
      enddo
    end function es_Jacobian_es_es
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000792" class="method-detail">
        <a name="M000792"></a>

        <div class="method-heading">


          <a href="#M000792" class="method-signature">



          <span class="method-name">es_LaplaInv_es</span><span class="method-args">( es ) result(es_LaplaInv_es)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000792">es_LaplaInv_es</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの逆ラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>es  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) SIN(Y)型スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル SINY に作用する逆 lapla 演算子
</p>
<p>
入力スペクトルデータに逆ラプラシアン(∂xx+∂yy)**(-1)を作用する.
</p>
<p>
スペクトルデータの逆ラプラシアンとは, 対応する格子点データに
逆ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>
<p>
実際にはスペクトルデータに全波数 (k**2 + l**2) で割る 計算を行っている.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000792-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000792-source">
<pre>
    function es_LaplaInv_es(es)   ! スペクトル SINY に作用する逆 \lapla 演算子
      !
      ! 入力スペクトルデータに逆ラプラシアン(∂xx+∂yy)**(-1)を作用する.
      !
      ! スペクトルデータの逆ラプラシアンとは, 対応する格子点データに
      ! 逆ラプラシアンを作用させたデータのスペクトル変換のことである.
      !
      ! 実際にはスペクトルデータに全波数 (k**2 + l**2) で割る
      ! 計算を行っている. 
      !
      real(8), dimension(-km:km,lm)                :: es_LaplaInv_es
      !(out) スペクトルデータの逆ラプラシアン

      real(8), dimension(-km:km,lm), intent(in)    :: es
      !(in) SIN(Y)型スペクトルデータ

      integer k,l

      do l=1,lm
         do k=-km,km
            es_LaplaInv_es(k,l) = -es(k,l)/((2*pi*k/xl)**2+(pi*l/yl)**2)
         enddo
      enddo
    end function es_LaplaInv_es
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000790" class="method-detail">
        <a name="M000790"></a>

        <div class="method-heading">


          <a href="#M000790" class="method-signature">



          <span class="method-name">es_Lapla_es</span><span class="method-args">( es ) result(es_Lapla_es)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000790">es_Lapla_es</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータのラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>es  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) SIN(Y)型入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
SIN(Y)型入力スペクトルデータにラプラシアン(∂xx+∂yy)を作用する.
</p>
<p>
スペクトルデータのラプラシアンとは, 対応する格子点データに
ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>
<p>
実際にはスペクトルデータに全波数 (k**2 + l**2) をかける 計算を行っている.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000790-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000790-source">
<pre>
    function es_Lapla_es(es)
      !
      ! SIN(Y)型入力スペクトルデータにラプラシアン(∂xx+∂yy)を作用する.
      !
      ! スペクトルデータのラプラシアンとは, 対応する格子点データに
      ! ラプラシアンを作用させたデータのスペクトル変換のことである.
      !
      ! 実際にはスペクトルデータに全波数 (k**2 + l**2) をかける
      ! 計算を行っている. 
      !
      real(8), dimension(-km:km,lm)                :: es_Lapla_es
      !(out) スペクトルデータのラプラシアン

      real(8), dimension(-km:km,lm), intent(in)    :: es
      !(in) SIN(Y)型入力スペクトルデータ

      integer k,l

      do l=1,lm
         do k=-km,km
            es_Lapla_es(k,l) = -((2*pi*k/xl)**2+(pi*l/yl)**2)*es(k,l)
         enddo
      enddo
    end function es_Lapla_es
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000788" class="method-detail">
        <a name="M000788"></a>

        <div class="method-heading">


          <a href="#M000788" class="method-signature">



          <span class="method-name">es_yx</span><span class="method-args">( yx ) result(es_yx)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000788">es_yx</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) SIN(Y)型スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yx  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm,0:im-1), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子データから SIN(Y)型スペクトルデータへ変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000788-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000788-source">
<pre>
    function es_yx(yx)
      !
      ! 格子データから SIN(Y)型スペクトルデータへ変換する.
      !
      real(8), dimension(-km:km,lm)                :: es_yx
      !(out) SIN(Y)型スペクトルデータ

      real(8), dimension(0:jm,0:im-1), intent(in)  :: yx
      !(in) 格子点データ

      yx_work = yx
      call c2g2sa(lm,km,jm,im,yx_work,es_yx,wg,itj,tj,iti,ti,1)
    end function es_yx
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000785" class="method-detail">
        <a name="M000785"></a>

        <div class="method-heading">


          <a href="#M000785" class="method-signature">



          <span class="method-name">esc_Initial</span><span class="method-args">( i, j, k, l, xmin, xmax, ymin, ymax ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>i  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点数(X)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>j  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点数(Y)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>k  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 切断波数(X)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>l  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 切断波数(Y)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xmin  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) X 座標範囲

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xmax  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) X 座標範囲

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ymin  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) Y 座標範囲

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ymax  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) Y 座標範囲

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル変換の格子点数, 波数, 領域の大きさを設定する.
</p>
<p>
他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで
初期設定をしなければならない.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000785-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000785-source">
<pre>
    subroutine esc_Initial(i,j,k,l,xmin,xmax,ymin,ymax)
      !
      ! スペクトル変換の格子点数, 波数, 領域の大きさを設定する.
      !
      ! 他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで
      ! 初期設定をしなければならない.
      !
      integer,intent(in) :: i           !(in) 格子点数(X)
      integer,intent(in) :: j           !(in) 格子点数(Y)
      integer,intent(in) :: k           !(in) 切断波数(X)
      integer,intent(in) :: l           !(in) 切断波数(Y)

      real(8),intent(in) :: xmin, xmax     !(in) X 座標範囲
      real(8),intent(in) :: ymin, ymax     !(in) Y 座標範囲

      integer :: ii, jj

      im = i         
       jm = j
      km = k         
       lm = l
      xl = xmax-xmin 
       yl = ymax-ymin

      allocate(tj(jm*6),ti(im*2))
      allocate(wg((jm+1)*im))
      allocate(ws((2*km+1)*(lm+1)),wgj((jm+1)*im*3))
      allocate(yx_work(0:jm,0:im-1))
      allocate(es_work(-km:km,lm),ec_work(-km:km,0:lm))

      call c2init(jm,im,itj,tj,iti,ti)

      allocate(x_X(0:im-1), x_X_Weight(0:im-1))
      allocate(y_Y(0:jm), y_Y_Weight(0:jm))
      allocate(yx_X(0:jm,0:im-1), yx_Y(0:jm,0:im-1))

      do ii=0,im-1
         x_X(ii) = xmin + xl/im*ii
      enddo
      x_X_Weight = xl/im

      do jj=0,jm
         y_Y(jj) = ymin + yl/jm*jj
      enddo
      y_Y_Weight(0) = yl/(2*jm)
      y_Y_Weight(1:jm-1) = yl/jm 
      y_Y_Weight(jm) = yl/(2*jm)

      yx_X = spread(x_X,1,jm+1)
      yx_Y = spread(y_Y,2,im)

      call MessageNotify('M','esc_initial','esc_module (2009/01/09) is initialized')
    end subroutine esc_Initial
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000807" class="method-detail">
        <a name="M000807"></a>

        <div class="method-heading">


          <a href="#M000807" class="method-signature">



          <span class="method-name">x_AvrY_yx</span><span class="method-args">( yx ) result(x_AvrY_yx)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000807">x_AvrY_yx</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) Y 方向に平均された 1 次元(X)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yx  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
Y 方向平均
</p>
<p>
2 次元格子点データの Y 方向平均
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000807-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000807-source">
<pre>
    function x_AvrY_yx(yx)   ! Y 方向平均
      !
      ! 2 次元格子点データの Y 方向平均
      !
      real(8), dimension(0:jm,0:im-1)   :: yx
      !(in) 2 次元格子点データ

      real(8), dimension(0:im-1)        :: x_AvrY_yx
      !(out) Y 方向に平均された 1 次元(X)格子点データ

      x_AvrY_yx = x_IntY_yx(yx)/sum(y_Y_weight)
    end function x_AvrY_yx
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000802" class="method-detail">
        <a name="M000802"></a>

        <div class="method-heading">


          <a href="#M000802" class="method-signature">



          <span class="method-name">x_IntY_yx</span><span class="method-args">( yx ) result(x_IntY_yx)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000802">x_IntY_yx</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) Y 方向に積分された 1 次元(X)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yx  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元格子点データの Y 方向積分
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000802-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000802-source">
<pre>
    function x_IntY_yx(yx)
      !
      ! 2 次元格子点データの Y 方向積分
      !
      real(8), dimension(0:jm,0:im-1)   :: yx
      !(in) 2 次元格子点データ

      real(8), dimension(0:im-1)        :: x_IntY_yx
      !(out) Y 方向に積分された 1 次元(X)格子点データ

      integer :: j

      x_IntY_yx = 0.0d0
      do j=0,jm
         x_IntY_yx(:) = x_IntY_yx(:) + yx(j,:) * y_Y_Weight(j)
      enddo
    end function x_IntY_yx
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000779" class="method-detail">
        <a name="M000779"></a>

        <div class="method-heading">




          <span class="method-name">x_X</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000779">x_X</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点座標(X)を格納した 1 次元配列

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M000781" class="method-detail">
        <a name="M000781"></a>

        <div class="method-heading">




          <span class="method-name">x_X_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000781">x_X_Weight</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 重み座標(X)を格納した 1 次元配列. X 方向の格子点の間隔が格納してある.

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M000806" class="method-detail">
        <a name="M000806"></a>

        <div class="method-heading">


          <a href="#M000806" class="method-signature">



          <span class="method-name">y_AvrX_yx</span><span class="method-args">( yx ) result(y_AvrX_yx)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000806">y_AvrX_yx</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) X 方向に平均された 1 次元(Y)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yx  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
X 方向平均
</p>
<p>
1 次元(X)格子点データの X 方向平均
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000806-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000806-source">
<pre>
    function y_AvrX_yx(yx)   ! X 方向平均
      !
      ! 1 次元(X)格子点データの X 方向平均
      !
      real(8), dimension(0:jm,0:im-1)   :: yx
      !(in) 2 次元格子点データ

      real(8), dimension(0:jm)          :: y_AvrX_yx
      !(out) X 方向に平均された 1 次元(Y)格子点データ

      y_AvrX_yx = y_IntX_yx(yx)/sum(x_X_weight)
    end function y_AvrX_yx
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000801" class="method-detail">
        <a name="M000801"></a>

        <div class="method-heading">


          <a href="#M000801" class="method-signature">



          <span class="method-name">y_IntX_yx</span><span class="method-args">( yx ) result(y_IntX_yx)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000801">y_IntX_yx</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) X 方向に積分された 1 次元(Y)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yx  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
X 方向積分
</p>
<p>
1 次元(X)格子点データの X 方向積分
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000801-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000801-source">
<pre>
    function y_IntX_yx(yx)  ! X 方向積分
      !
      ! 1 次元(X)格子点データの X 方向積分
      !
      real(8), dimension(0:jm,0:im-1)   :: yx
      !(in) 2 次元格子点データ

      real(8), dimension(0:jm)          :: y_IntX_yx
      !(out) X 方向に積分された 1 次元(Y)格子点データ

      integer :: i

      y_IntX_yx = 0.0d0
      do i=0,im-1
         y_IntX_yx(:) = y_IntX_yx(:) + yx(:,i) * x_X_Weight(i)
      enddo
    end function y_IntX_yx
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000780" class="method-detail">
        <a name="M000780"></a>

        <div class="method-heading">




          <span class="method-name">y_Y</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000780">y_Y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点座標(X)を格納した 1 次元配列

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M000782" class="method-detail">
        <a name="M000782"></a>

        <div class="method-heading">




          <span class="method-name">y_Y_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000782">y_Y_Weight</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 重み座標(Y)を格納した 1 次元配列. Y 方向の格子点の間隔が格納してある.

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M000783" class="method-detail">
        <a name="M000783"></a>

        <div class="method-heading">




          <span class="method-name">yx_X</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000783">yx_X</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 各格子点(i,j)の位置の X 座標を格納した格子データ.

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M000784" class="method-detail">
        <a name="M000784"></a>

        <div class="method-heading">




          <span class="method-name">yx_Y</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000784">yx_Y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 各格子点(i,j)の位置の Y 座標を格納した格子データ.

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M000787" class="method-detail">
        <a name="M000787"></a>

        <div class="method-heading">


          <a href="#M000787" class="method-signature">



          <span class="method-name">yx_ec</span><span class="method-args">( ec ) result(yx_ec)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000787">yx_ec</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ec  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) COS(Y)型スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
COS(Y)型スペクトルデータから格子データへ変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000787-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000787-source">
<pre>
    function yx_ec(ec)
      !
      ! COS(Y)型スペクトルデータから格子データへ変換する.
      !
      real(8), dimension(0:jm,0:im-1)              :: yx_ec
      !(out) 格子点データ

      real(8), dimension(-km:km,0:lm), intent(in)  :: ec
      !(in) COS(Y)型スペクトルデータ

      call c2s2ga(lm,km,jm,im,ec,yx_ec,wg,itj,tj,iti,ti,2)
    end function yx_ec
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000786" class="method-detail">
        <a name="M000786"></a>

        <div class="method-heading">


          <a href="#M000786" class="method-signature">



          <span class="method-name">yx_es</span><span class="method-args">( es ) result(yx_es)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="esc_module.html#M000786">yx_es</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:jm,0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>es  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(-km:km,lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) SIN(Y)型スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
SIN(Y)型スペクトルデータから格子データへ変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000786-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000786-source">
<pre>
    function yx_es(es)
      !
      ! SIN(Y)型スペクトルデータから格子データへ変換する.
      !
      real(8), dimension(0:jm,0:im-1)              :: yx_es
      !(out) 格子点データ

      real(8), dimension(-km:km,lm), intent(in)    :: es
      !(in) SIN(Y)型スペクトルデータ

      call c2s2ga(lm,km,jm,im,es,yx_es,wg,itj,tj,iti,ti,1)
    end function yx_es
</pre>
          </div>

        </div>
      </div>



    </div>



  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
