<?xml version="1.0" encoding="euc-jp"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: at_module</title>
  <meta http-equiv="Content-Type" content="text/html; charset=euc-jp" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">at_module</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../files/src/at_module_f90.html">

                src/at_module.f90

                </a>


        <br />
            </td>
        </tr>


        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">


  <div id="contextContent">



    <div id="description">
      <h1><a href="at_module.html">at_module</a></h1>
<table>
<tr><td valign="top">Authors:</td><td>Shin-ichi Takehiro, Youhei SASAKI

</td></tr>
<tr><td valign="top">Version:</td><td>$Id: <a href="../files/src/at_module_f90.html">at_module.f90</a>,v 1.19
2009-02-28 21:33:46 uwabami Exp $

</td></tr>
<tr><td valign="top">Copyright&amp;License:</td><td>See <a href="../../COPYRIGHT">COPYRIGHT</a>

</td></tr>
</table>
<h2>概要</h2>
<p>
spml/at_module モジュールは 1 次元有限領域の下での流体運動を
チェビシェフ変換によりスペクトル数値計算するための Fortran90 関数を
提供する.
</p>
<p>
2 次元データの 1 次元に関して同時にスペクトル計算を実行するための
関数も提供しており, 2, 3 次元領域での計算のベースも提供する.
</p>
<p>
このモジュールは内部で ISPACK/FTPACK の Fortran77 サブルーチンを
呼んでいる. スペクトルデータおよび格子点データの格納方法については
ISPACK/FTPACK のマニュアルを参照されたい.
</p>
<h2>関数・変数の名前と型について</h2>
<h3>命名法</h3>
<ul>
<li>関数名の先頭 (t_, g_, at_, ag_) は, 返す値の形を示している.

<table>
<tr><td valign="top">t_  :</td><td>チェビシェフデータ

</td></tr>
<tr><td valign="top">g_  :</td><td>1 次元格子点データ

</td></tr>
<tr><td valign="top">at_ :</td><td>1 次元チェビシェフデータが複数並んだ 2 次元データ

</td></tr>
<tr><td valign="top">ag_ :</td><td>1 次元格子点データが複数並んだ 2 次元データ.

</td></tr>
</table>
</li>
<li>関数名の間の文字列(Dx)は, その関数の作用を表している.

</li>
<li>関数名の最後 (_e,_at,_g, _ag) は, 入力変数の形がチェビシェフデータ
および格子点データであることを示している.

<table>
<tr><td valign="top">_t  :</td><td>チェビシェフデータ

</td></tr>
<tr><td valign="top">_g  :</td><td>1 次元格子点データ

</td></tr>
<tr><td valign="top">_at :</td><td>1 次元チェビシェフデータが複数並んだ 2 次元データ

</td></tr>
<tr><td valign="top">_ag :</td><td>1 次元格子点データが複数並んだ 2 次元データ

</td></tr>
</table>
</li>
</ul>
<h3>各データの種類の説明</h3>
<ul>
<li>g : 1 次元格子点データ.

<ul>
<li>変数の種類と次元は real(8), dimension(0:im).

</li>
<li>im は X 座標の格子点数であり, サブルーチン <a
href="at_module.html#M001337">at_Initial</a> にて あらかじめ設定しておく.

</li>
</ul>
</li>
<li>t : チェビシェフデータ.

<ul>
<li>変数の種類と次元は real(8), dimension(0:km).

</li>
<li>km は X 方向の最大波数であり, サブルーチン <a
href="at_module.html#M001337">at_Initial</a> にて あらかじめ設定しておく.
スペクトルデータの格納のされ方については&#8230;

</li>
</ul>
</li>
<li>ag : 1 次元(X)格子点データの並んだ 2 次元データ.

<ul>
<li>変数の種類と次元は real(8), dimension(:,0:im). 第 2 次元が X 方向を表す.

</li>
</ul>
</li>
<li>at : 1 次元チェビシェフデータの並んだ 2 次元データ.

<ul>
<li>変数の種類と次元は real(8), dimension(:,0:km). 第 2 次元がスペクトルを表す.

</li>
</ul>
</li>
<li>g_ で始まる関数が返す値は 1 次元格子点データに同じ.

</li>
<li>t_ で始まる関数が返す値はチェビシェフデータに同じ.

</li>
<li>ag_ で始まる関数が返す値は 1 次元格子点データの並んだ 2 次元データに同じ.

</li>
<li>at_ で始まる関数が返す値は 1 次元チェビシェフデータの並んだ 2
次元データに同じ.

</li>
<li>チェビシェフデータに対する微分等の作用とは, 対応する格子点データに
微分などを作用させたデータをチェビシェフ変換したもののことである.

</li>
</ul>
<h2>変数・手続き群の要約</h2>
<h4>初期化</h4>
<table>
<tr><td valign="top"><a href="at_module.html#M001337">at_Initial</a>  :</td><td>チェビシェフ変換の格子点数, 波数, 領域の大きさの設定

</td></tr>
</table>
<h4>座標変数</h4>
<table>
<tr><td valign="top"><a href="at_module.html#M001335">g_X</a>        :</td><td>格子点座標(X)を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="at_module.html#M001336">g_X_Weight</a> :</td><td>重み座標を格納した 1 次元配列

</td></tr>
</table>
<h4>基本変換</h4>
<table>
<tr><td valign="top"><a href="at_module.html#M001339">g_t</a>, <a href="at_module.html#M001338">ag_at</a> :</td><td>チェビシェフデータから格子データへの変換

</td></tr>
<tr><td valign="top"><a href="at_module.html#M001341">t_g</a>, <a href="at_module.html#M001340">at_ag</a> :</td><td>格子データからチェビシェフデータへの変換

</td></tr>
</table>
<h4>微分</h4>
<table>
<tr><td valign="top"><a href="at_module.html#M001343">t_Dx_t</a>, <a href="at_module.html#M001342">at_Dx_at</a> :</td><td>チェビシェフデータに X 微分を作用させる

</td></tr>
</table>
<h4>補間</h4>
<p>
<a href="at_module.html#M001344">Interpolate_t</a>, <a
href="at_module.html#M001345">a_Interpolate_at</a> ::
チェビシェフデータから任意の点での値を求める
</p>
<h4>境界値問題</h4>
<p>
<a href="at_module.html#M001350">at_Boundaries_DD</a>, <a
href="at_module.html#M001352">at_Boundaries_DN</a>, <a
href="at_module.html#M001354">at_Boundaries_ND</a>, <a
href="at_module.html#M001356">at_Boundaries_NN</a> ::
ディリクレ,ノイマン境界条件の適用
</p>
<p>
<a href="at_module.html#M001358">at_BoundariesTau_DD</a>, <a
href="at_module.html#M001360">at_BoundariesTau_DN</a>, <a
href="at_module.html#M001362">at_BoundariesTau_ND</a>, <a
href="at_module.html#M001364">at_BoundariesTau_NN</a> :: ディリクレ,
ノイマン境界条件の適用(タウ法)
</p>
<p>
<a href="at_module.html#M001366">at_BoundariesGrid_DD</a>, <a
href="at_module.html#M001368">at_BoundariesGrid_DN</a>, <a
href="at_module.html#M001370">at_BoundariesGrid_ND</a>, <a
href="at_module.html#M001372">at_BoundariesGrid_NN</a> :: ディリクレ,
ノイマン境界条件の適用(選点法)
</p>
<h4>積分・平均</h4>
<table>
<tr><td valign="top"><a href="at_module.html#M001346">a_Int_ag</a>, <a href="at_module.html#M001348">a_Avr_ag</a> :</td><td>1 次元格子点データの並んだ 2 次元配列の積分および平均

</td></tr>
<tr><td valign="top"><a href="at_module.html#M001347">Int_g</a>, <a href="at_module.html#M001349">Avr_g</a>       :</td><td>1 次元格子点データの積分および平均

</td></tr>
</table>

    </div>





   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M001349">Avr_g</a>&nbsp;&nbsp;

        <a href="#M001347">Int_g</a>&nbsp;&nbsp;

        <a href="#M001344">Interpolate_t</a>&nbsp;&nbsp;

        <a href="#M001348">a_Avr_ag</a>&nbsp;&nbsp;

        <a href="#M001346">a_Int_ag</a>&nbsp;&nbsp;

        <a href="#M001345">a_Interpolate_at</a>&nbsp;&nbsp;

        <a href="#M001338">ag_at</a>&nbsp;&nbsp;

        <a href="#M001367">at_BoundariesGrid_DD</a>&nbsp;&nbsp;

        <a href="#M001366">at_BoundariesGrid_DD</a>&nbsp;&nbsp;

        <a href="#M001369">at_BoundariesGrid_DN</a>&nbsp;&nbsp;

        <a href="#M001368">at_BoundariesGrid_DN</a>&nbsp;&nbsp;

        <a href="#M001371">at_BoundariesGrid_ND</a>&nbsp;&nbsp;

        <a href="#M001370">at_BoundariesGrid_ND</a>&nbsp;&nbsp;

        <a href="#M001373">at_BoundariesGrid_NN</a>&nbsp;&nbsp;

        <a href="#M001372">at_BoundariesGrid_NN</a>&nbsp;&nbsp;

        <a href="#M001359">at_BoundariesTau_DD</a>&nbsp;&nbsp;

        <a href="#M001358">at_BoundariesTau_DD</a>&nbsp;&nbsp;

        <a href="#M001361">at_BoundariesTau_DN</a>&nbsp;&nbsp;

        <a href="#M001360">at_BoundariesTau_DN</a>&nbsp;&nbsp;

        <a href="#M001363">at_BoundariesTau_ND</a>&nbsp;&nbsp;

        <a href="#M001362">at_BoundariesTau_ND</a>&nbsp;&nbsp;

        <a href="#M001365">at_BoundariesTau_NN</a>&nbsp;&nbsp;

        <a href="#M001364">at_BoundariesTau_NN</a>&nbsp;&nbsp;

        <a href="#M001351">at_Boundaries_DD</a>&nbsp;&nbsp;

        <a href="#M001350">at_Boundaries_DD</a>&nbsp;&nbsp;

        <a href="#M001353">at_Boundaries_DN</a>&nbsp;&nbsp;

        <a href="#M001352">at_Boundaries_DN</a>&nbsp;&nbsp;

        <a href="#M001355">at_Boundaries_ND</a>&nbsp;&nbsp;

        <a href="#M001354">at_Boundaries_ND</a>&nbsp;&nbsp;

        <a href="#M001357">at_Boundaries_NN</a>&nbsp;&nbsp;

        <a href="#M001356">at_Boundaries_NN</a>&nbsp;&nbsp;

        <a href="#M001342">at_Dx_at</a>&nbsp;&nbsp;

        <a href="#M001337">at_Initial</a>&nbsp;&nbsp;

        <a href="#M001340">at_ag</a>&nbsp;&nbsp;

        <a href="#M001335">g_X</a>&nbsp;&nbsp;

        <a href="#M001336">g_X_Weight</a>&nbsp;&nbsp;

        <a href="#M001339">g_t</a>&nbsp;&nbsp;

        <a href="#M001343">t_Dx_t</a>&nbsp;&nbsp;

        <a href="#M001341">t_g</a>&nbsp;&nbsp;
      </div>
    </div>


  </div>


    <!-- if includes -->

    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">

        <span class="include-name">dc_message</span>

        <span class="include-name"><a href="lumatrix.html">lumatrix</a></span>
      </div>
    </div>



    <div id="section">










      


    <!-- if method_list -->

    <div id="methods">


      <h3 class="section-bar">Public Instance methods</h3>


      <div id="method-M001349" class="method-detail">
        <a name="M001349"></a>

        <div class="method-heading">


          <a href="#M001349" class="method-signature">



          <span class="method-name">Avr_g</span><span class="method-args">( g ) result(Avr_g)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001349">Avr_g</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>g  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元格子点データの平均
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001349-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001349-source">
<pre>
    function Avr_g(g)
      !
      ! 1 次元格子点データの平均
      !
      real(8), dimension(0:im), intent(in)   :: g
      !(in) 格子点データ

      real(8)                                :: Avr_g
      !(out) 積分値

      Avr_g = Int_g(g)/sum(g_X_Weight)
    end function Avr_g
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001347" class="method-detail">
        <a name="M001347"></a>

        <div class="method-heading">


          <a href="#M001347" class="method-signature">



          <span class="method-name">Int_g</span><span class="method-args">( g ) result(Int_g)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001347">Int_g</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>g  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元格子点データの積分および平均.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001347-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001347-source">
<pre>
    function Int_g(g)
      !
      ! 1 次元格子点データの積分および平均.
      !
      real(8), dimension(0:im), intent(in)   :: g
      !(in) 格子点データ

      real(8)                                :: Int_g
      !(out) 積分値

      Int_g = sum(g*g_X_Weight)
    end function Int_g
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001344" class="method-detail">
        <a name="M001344"></a>

        <div class="method-heading">


          <a href="#M001344" class="method-signature">



          <span class="method-name">Interpolate_t</span><span class="method-args">( t_data, xval ) result(Interpolate_t)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001344">Interpolate_t</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間した結果の値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xval  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間する点の座標

</td></tr>
</table>
</td></tr>
</table>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001344-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001344-source">
<pre>
  function Interpolate_t(t_data,xval)
    real(8), dimension(0:), intent(in)  :: t_data
    !(in) 入力チェビシェフデータ

    real(8), intent(in)                 :: xval
    ! 補間する点の座標

    real(8)                             :: Interpolate_t
    ! 補間した結果の値

    integer :: kmax
    ! 入力配列の最大次数

    real(8) :: y2, y1, y0, x
    ! Crenshow's reccurence formula 計算用変数 
    
    integer :: k
    ! DO 文変数

    kmax = size(t_data)-1
    
    x =(xval -(g_X(0)+g_X(im))/2 )/(g_X(0)-g_X(im))*2

    y2 = 0 
     y1 = 0
    do k=kmax,1,-1
       y0 = 2*x*y1 - y2 + t_data(k)
       y2 = y1 
        y1 = y0
    enddo

    Interpolate_t = - y2 + x*y1 + t_data(0)/2 
    if ( kmax == im ) then
       Interpolate_t = Interpolate_t -t_data(kmax)/2*cos(kmax*acos(x))
    endif

  end function Interpolate_t
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001348" class="method-detail">
        <a name="M001348"></a>

        <div class="method-heading">


          <a href="#M001348" class="method-signature">



          <span class="method-name">a_Avr_ag</span><span class="method-args">( ag ) result(a_Avr_ag)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001348">a_Avr_ag</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(ag,1))</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均したデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ag  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in)入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元格子点データが並んだ 2 次元配列の平均
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001348-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001348-source">
<pre>
    function a_Avr_ag(ag)
      !
      ! 1 次元格子点データが並んだ 2 次元配列の平均
      !
      real(8), dimension(:,0:), intent(in)   :: ag
      !(in)入力格子点データ

      real(8), dimension(size(ag,1))         :: a_Avr_ag
      !(out) 平均したデータ

      a_Avr_ag = a_Int_ag(ag)/sum(g_X_Weight)
    end function a_Avr_ag
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001346" class="method-detail">
        <a name="M001346"></a>

        <div class="method-heading">


          <a href="#M001346" class="method-signature">



          <span class="method-name">a_Int_ag</span><span class="method-args">( ag ) result(a_Int_ag)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001346">a_Int_ag</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(ag,1))</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分したデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ag  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in)入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元格子点データが並んだ 2 次元配列の積分
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001346-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001346-source">
<pre>
    function a_Int_ag(ag)
      !
      ! 1 次元格子点データが並んだ 2 次元配列の積分
      !
      real(8), dimension(:,0:), intent(in)     :: ag
      !(in)入力格子点データ

      real(8), dimension(size(ag,1))           :: a_Int_ag
      !(out) 積分したデータ
      integer :: i

      if ( size(ag,2) &lt; im+1 ) then
         call MessageNotify('E','ae_ag', 'The Grid points of input data too small.')
      elseif ( size(ag,2) &gt; im+1 ) then
         call MessageNotify('W','ae_ag', 'The Grid points of input data too large.')
      endif

      a_Int_ag = 0.0d0
      do i=0,im
         a_Int_ag(:) = a_Int_ag(:) + ag(:,i)*g_X_Weight(i)
      enddo
    end function a_Int_ag
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001345" class="method-detail">
        <a name="M001345"></a>

        <div class="method-heading">


          <a href="#M001345" class="method-signature">



          <span class="method-name">a_Interpolate_at</span><span class="method-args">( at_data, xval ) result(a_Interpolate_at)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001345">a_Interpolate_at</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(at_data,1))</tt>

<table>
<tr><td valign="top"> :</td><td> 補間した結果の値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xval  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間する点の座標

</td></tr>
</table>
</td></tr>
</table>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001345-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001345-source">
<pre>
  function a_Interpolate_at(at_data,xval)
    real(8), dimension(:,0:), intent(in) :: at_data
    !(in) 入力チェビシェフデータ

    real(8), intent(in)                  :: xval
    ! 補間する点の座標

    real(8), dimension(size(at_data,1))  :: a_Interpolate_at
    ! 補間した結果の値

    integer :: kmax
    ! 入力配列の最大次数

    real(8), dimension(size(at_data,1))  :: y2, y1, y0
    real(8)                              ::  x
    ! Crenshow's reccurence formula 計算用変数 

    integer :: k
    ! DO 文変数

    kmax = size(at_data,2)-1
    
    x =(xval -(g_X(0)+g_X(im))/2 )/(g_X(0)-g_X(im))*2

    y2 = 0 
     y1 = 0
    do k=kmax,1,-1
       y0 = 2*x*y1 - y2 + at_data(:,k)
       y2 = y1 
        y1 = y0
    enddo

    a_Interpolate_at = - y2 + x*y1 + at_data(:,0)/2 
    if ( kmax == im ) then
       a_Interpolate_at = a_Interpolate_at -at_data(:,kmax)/2*cos(kmax*acos(x))
    endif
  end function a_Interpolate_at
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001338" class="method-detail">
        <a name="M001338"></a>

        <div class="method-heading">


          <a href="#M001338" class="method-signature">



          <span class="method-name">ag_at</span><span class="method-args">( at_data ) result(ag_at)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001338">ag_at</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(at_data,1),0:im)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
チェビシェフデータから格子データへ変換する(2 次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001338-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001338-source">
<pre>
  function ag_at(at_data)
    !
    ! チェビシェフデータから格子データへ変換する(2 次元配列用).
    !
    real(8), dimension(:,:), intent(in)      :: at_data
    !(in) チェビシェフデータ

    real(8), dimension(size(at_data,1),0:im) :: ag_at
    !(out) 格子点データ

    real(8), dimension(size(at_data,1)*im) :: y
    ! 作業用配列
    integer :: m

    m = size(at_data,1)
    if ( size(at_data,2)-1 &lt; km ) then
       call MessageNotify('E','ag_at', 'The Chebyshev dimension of input data too small.')
    elseif ( size(at_data,2)-1 &gt; km ) then
       call MessageNotify('W','ag_at', 'The Chebyshev dimension of input data too large.')
    endif

    ag_at = 0.0D0
    ag_at(:,0:km)=at_data
    call fttctb(m,im,ag_at,y,it,t)

  end function ag_at
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001367" class="method-detail">
        <a name="M001367"></a>

        <div class="method-heading">


          <a href="#M001367" class="method-signature">



          <span class="method-name">at_BoundariesGrid_DD</span><span class="method-args">( at_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m,2)

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(実空間での評価, 2 次元配列用)
両境界での値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001367-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001367-source">
<pre>
  subroutine at_BoundariesGrid_DD_2d(at_data,values)
    !
    ! Dirichlet 型境界条件の適用(実空間での評価, 2 次元配列用)
    ! 両境界での値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: at_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:,:), intent(in), optional  :: values
    !(in) 境界値(m,2)

    real(8), dimension(:,:), allocatable     :: alu
    integer, dimension(:), allocatable       :: kp
    real(8), dimension(size(at_data,1),0:im) :: ag_data
    real(8), dimension(0:km,0:km)            :: tt_data
    real(8), dimension(0:km,0:im)            :: tg_data
    real(8), dimension(size(at_data,1))      :: value1, value2  ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( im /= km ) then
       call MessageNotify('E','at_BoundariesGrid_DD', 'Chebyshev truncation and number of grid points should be same.')
    endif

    if ( size(at_data,2)-1 &lt; km ) then
       call MessageNotify('E','at_BoundariesGrid_DD', 'The Chebyshev dimension of input data too small.')
    elseif ( size(at_data,2)-1 &gt; km ) then
       call MessageNotify('W','at_BoundariesGrid_DD', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(values)) then
       value1=0 
        value2=0
    else
       value1 = values(:,1) 
        value2 = values(:,2)
    endif

    if ( first ) then
       first = .false.
       allocate(alu(0:im,0:km),kp(0:im))

       tt_data = 0
       do k=0,km
          tt_data(k,k)=1.0
       enddo
       tg_data = ag_at(tt_data)
       alu = transpose(tg_data)
!       alu(km-1,:) = tg_data(:,0)
!       alu(km,:)   = tg_data(:,im)

       call ludecomp(alu,kp)
    endif

    ag_data = ag_at(at_data)
    ag_data(:,0)  = value1
    ag_data(:,im) = value2
    at_data = lusolve(alu,kp,ag_data)

  end subroutine at_BoundariesGrid_DD_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001366" class="method-detail">
        <a name="M001366"></a>

        <div class="method-heading">


          <a href="#M001366" class="method-signature">



          <span class="method-name">at_BoundariesGrid_DD</span><span class="method-args">( t_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(実空間での評価, 1 次元配列用)
両境界での値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001366-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001366-source">
<pre>
  subroutine at_BoundariesGrid_DD_1d(t_data,values)
    !
    ! Dirichlet 型境界条件の適用(実空間での評価, 1 次元配列用)
    ! 両境界での値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: t_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), dimension(2), intent(in), optional  :: values
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: at_work
    real(8), dimension(1,2)                      :: vwork           ! 境界値

    if (.not. present(values)) then
       vwork(1,1)=0 
        vwork(1,2)=0
    else
       vwork(1,:) = values
    endif

    at_work(1,:)=t_data
    call at_BoundariesGrid_DD_2d(at_work,vwork)
    t_data=at_work(1,:)

  end subroutine at_BoundariesGrid_DD_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001369" class="method-detail">
        <a name="M001369"></a>

        <div class="method-heading">


          <a href="#M001369" class="method-signature">



          <span class="method-name">at_BoundariesGrid_DN</span><span class="method-args">( at_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m,2)

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet/Neumann 型境界条件の適用(実空間での評価, 2 次元配列用) i=0 で値,
i=im で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001369-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001369-source">
<pre>
  subroutine at_BoundariesGrid_DN_2d(at_data,values)
    !
    ! Dirichlet/Neumann 型境界条件の適用(実空間での評価, 2 次元配列用)
    ! i=0 で値, i=im で勾配の値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: at_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:,:), intent(in), optional  :: values
    !(in) 境界値(m,2)

    real(8), dimension(:,:), allocatable     :: alu
    integer, dimension(:), allocatable       :: kp
    real(8), dimension(size(at_data,1),0:im) :: ag_data
    real(8), dimension(0:km,0:km)            :: tt_data
    real(8), dimension(0:km,0:im)            :: tg_data
    real(8), dimension(size(at_data,1))      :: value1, value2  ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( im /= km ) then
       call MessageNotify('E','at_BoundariesGrid_DN', 'Chebyshev truncation and number of grid points should be same.')
    endif

    if ( size(at_data,2)-1 &lt; km ) then
       call MessageNotify('E','at_BoundariesGrid_DN', 'The Chebyshev dimension of input data too small.')
    elseif ( size(at_data,2)-1 &gt; km ) then
       call MessageNotify('W','at_BoundariesGrid_DN', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(values)) then
       value1=0 
        value2=0
    else
       value1 = values(:,1) 
        value2 = values(:,2)
    endif

    if ( first ) then
       first = .false.
       allocate(alu(0:im,0:km),kp(0:im))

       tt_data = 0
       do k=0,km
          tt_data(k,k)=1.0
       enddo
       tg_data = ag_at(tt_data)
       alu = transpose(tg_data)

       tg_data = ag_at(at_dx_at(tt_data))
       alu(im,:) = tg_data(:,im)

       call ludecomp(alu,kp)
    endif

    ag_data = ag_at(at_data)
    ag_data(:,0)  = value1
    ag_data(:,im) = value2
    at_data = lusolve(alu,kp,ag_data)

  end subroutine at_BoundariesGrid_DN_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001368" class="method-detail">
        <a name="M001368"></a>

        <div class="method-heading">


          <a href="#M001368" class="method-signature">



          <span class="method-name">at_BoundariesGrid_DN</span><span class="method-args">( t_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet/Neumann 型境界条件の適用(実空間での評価, 1 次元配列用) i=0 で値,
i=im で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001368-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001368-source">
<pre>
  subroutine at_BoundariesGrid_DN_1d(t_data,values)
    !
    ! Dirichlet/Neumann 型境界条件の適用(実空間での評価, 1 次元配列用)
    ! i=0 で値, i=im で勾配の値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: t_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), dimension(2), intent(in), optional  :: values
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: at_work
    real(8), dimension(1,2)                      :: vwork           ! 境界値

    if (.not. present(values)) then
       vwork(1,1)=0 
        vwork(1,2)=0
    else
       vwork(1,:) = values
    endif

    at_work(1,:)=t_data
    call at_BoundariesGrid_DN_2d(at_work,vwork)
    t_data=at_work(1,:)

  end subroutine at_BoundariesGrid_DN_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001371" class="method-detail">
        <a name="M001371"></a>

        <div class="method-heading">


          <a href="#M001371" class="method-signature">



          <span class="method-name">at_BoundariesGrid_ND</span><span class="method-args">( at_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m,2)

</td></tr>
</table>
</td></tr>
</table>
<p>
Neumann/Dirichlet 型境界条件の適用(実空間での評価, 2 次元配列用) i=0
で勾配の値, i=im で値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001371-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001371-source">
<pre>
  subroutine at_BoundariesGrid_ND_2d(at_data,values)
    !
    ! Neumann/Dirichlet 型境界条件の適用(実空間での評価, 2 次元配列用)
    ! i=0 で勾配の値, i=im で値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: at_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:,:), intent(in), optional  :: values
    !(in) 境界値(m,2)

    real(8), dimension(:,:), allocatable     :: alu
    integer, dimension(:), allocatable       :: kp
    real(8), dimension(size(at_data,1),0:im) :: ag_data
    real(8), dimension(0:km,0:km)            :: tt_data
    real(8), dimension(0:km,0:im)            :: tg_data
    real(8), dimension(size(at_data,1))      :: value1, value2  ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( im /= km ) then
       call MessageNotify('E','at_BoundariesGrid_ND', 'Chebyshev truncation and number of grid points should be same.')
    endif

    if ( size(at_data,2)-1 &lt; km ) then
       call MessageNotify('E','at_BoundariesGrid_ND', 'The Chebyshev dimension of input data too small.')
    elseif ( size(at_data,2)-1 &gt; km ) then
       call MessageNotify('W','at_BoundariesGrid_DD', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(values)) then
       value1=0 
        value2=0
    else
       value1 = values(:,1) 
        value2 = values(:,2)
    endif

    if ( first ) then
       first = .false.
       allocate(alu(0:im,0:km),kp(0:im))

       tt_data = 0
       do k=0,km
          tt_data(k,k)=1.0
       enddo
       tg_data = ag_at(tt_data)
       alu = transpose(tg_data)

       tg_data = ag_at(at_dx_at(tt_data))
       alu(0,:)  = tg_data(:,0)

       call ludecomp(alu,kp)
    endif

    ag_data = ag_at(at_data)
    ag_data(:,0)  = value1
    ag_data(:,im) = value2
    at_data = lusolve(alu,kp,ag_data)

  end subroutine at_BoundariesGrid_ND_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001370" class="method-detail">
        <a name="M001370"></a>

        <div class="method-heading">


          <a href="#M001370" class="method-signature">



          <span class="method-name">at_BoundariesGrid_ND</span><span class="method-args">( t_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Neumann 型境界条件の適用(実空間での評価, 1 次元配列用) i=0 で勾配の値, i=im
で値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001370-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001370-source">
<pre>
  subroutine at_BoundariesGrid_ND_1d(t_data,values)
    !
    ! Neumann 型境界条件の適用(実空間での評価, 1 次元配列用)
    ! i=0 で勾配の値, i=im で値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: t_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), dimension(2), intent(in), optional  :: values
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: at_work
    real(8), dimension(1,2)                      :: vwork           ! 境界値

    if (.not. present(values)) then
       vwork(1,1)=0 
        vwork(1,2)=0
    else
       vwork(1,:) = values
    endif

    at_work(1,:)=t_data
    call at_BoundariesGrid_ND_2d(at_work,vwork)
    t_data=at_work(1,:)

  end subroutine at_BoundariesGrid_ND_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001373" class="method-detail">
        <a name="M001373"></a>

        <div class="method-heading">


          <a href="#M001373" class="method-signature">



          <span class="method-name">at_BoundariesGrid_NN</span><span class="method-args">( at_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m,2)

</td></tr>
</table>
</td></tr>
</table>
<p>
Neumann 型境界条件の適用(実空間での評価, 2 次元配列用)
両境界で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001373-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001373-source">
<pre>
  subroutine at_BoundariesGrid_NN_2d(at_data,values)
    !
    ! Neumann 型境界条件の適用(実空間での評価, 2 次元配列用)
    ! 両境界で勾配の値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: at_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:,:), intent(in), optional  :: values  
    !(in) 境界値(m,2)

    real(8), dimension(:,:), allocatable     :: alu
    integer, dimension(:), allocatable       :: kp
    real(8), dimension(size(at_data,1),0:im) :: ag_data
    real(8), dimension(0:km,0:km)            :: tt_data
    real(8), dimension(0:km,0:im)            :: tg_data
    real(8), dimension(size(at_data,1))      :: value1, value2  ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( im /= km ) then
       call MessageNotify('E','at_BoundariesGrid_NN', 'Chebyshev truncation and number of grid points should be same.')
    endif

    if ( size(at_data,2)-1 &lt; km ) then
       call MessageNotify('E','at_BoundariesGrid_NN', 'The Chebyshev dimension of input data too small.')
    elseif ( size(at_data,2)-1 &gt; km ) then
       call MessageNotify('W','at_BoundariesGrid_NN', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(values)) then
       value1=0 
        value2=0
    else
       value1 = values(:,1) 
        value2 = values(:,2)
    endif

    if ( first ) then
       first = .false.
       allocate(alu(0:im,0:km),kp(0:im))

       tt_data = 0
       do k=0,km
          tt_data(k,k)=1.0
       enddo
       tg_data = ag_at(tt_data)
       alu = transpose(tg_data)

       tg_data = ag_at(at_dx_at(tt_data))
       alu(0,:)  = tg_data(:,0)
       alu(im,:) = tg_data(:,im)

       call ludecomp(alu,kp)
    endif

    ag_data = ag_at(at_data)
    ag_data(:,0)  = value1
    ag_data(:,im) = value2
    at_data = lusolve(alu,kp,ag_data)

  end subroutine at_BoundariesGrid_NN_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001372" class="method-detail">
        <a name="M001372"></a>

        <div class="method-heading">


          <a href="#M001372" class="method-signature">



          <span class="method-name">at_BoundariesGrid_NN</span><span class="method-args">( t_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Neumann 型境界条件の適用(実空間での評価, 1 次元配列用)
両境界で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001372-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001372-source">
<pre>
  subroutine at_BoundariesGrid_NN_1d(t_data,values)
    !
    ! Neumann 型境界条件の適用(実空間での評価, 1 次元配列用)
    ! 両境界で勾配の値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: t_data  
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), dimension(2), intent(in), optional  :: values  
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: at_work
    real(8), dimension(1,2)                      :: vwork           ! 境界値

    if (.not. present(values)) then
       vwork(1,1)=0 
        vwork(1,2)=0
    else
       vwork(1,:) = values
    endif

    at_work(1,:)=t_data
    call at_BoundariesGrid_NN_2d(at_work,vwork)
    t_data=at_work(1,:)

  end subroutine at_BoundariesGrid_NN_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001359" class="method-detail">
        <a name="M001359"></a>

        <div class="method-heading">


          <a href="#M001359" class="method-signature">



          <span class="method-name">at_BoundariesTau_DD</span><span class="method-args">( at_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> データ(m,0:km) (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m,2)

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 2 次元配列用) 両境界での値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001359-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001359-source">
<pre>
  subroutine at_BoundariesTau_DD_2d(at_data,values)
    !
    ! Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
    ! 両境界での値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: at_data ! データ(m,0:km)
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:,:), intent(in), optional  :: values
    !(in) 境界値(m,2)

    real(8), dimension(:,:), allocatable  :: alu
    integer, dimension(:), allocatable    :: kp
    real(8), dimension(0:km,0:km)         :: tt_data
    real(8), dimension(0:km,0:im)         :: tg_data
    real(8), dimension(size(at_data,1))    :: value1, value2           ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( size(at_data,2)-1 &lt; km ) then
       call MessageNotify('E','at_BoundariesTau_DD', 'The Chebyshev dimension of input data too small.')
    elseif ( size(at_data,2)-1 &gt; km ) then
       call MessageNotify('W','at_BoundariesTau_DD', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(values)) then
       value1=0 
        value2=0
    else
       value1 = values(:,1) 
        value2 = values(:,2)
    endif

    if ( first ) then
       first = .false.

       allocate(alu(0:km,0:km),kp(0:km))

       tt_data=0
       do k=0,km
          tt_data(k,k)=1
       enddo
       alu = tt_data

       tg_data = ag_at(tt_data)
       alu(km-1,:) = tg_data(:,0)
       alu(km,:)   = tg_data(:,im)

       call ludecomp(alu,kp)
    endif

    at_data(:,km-1) = value1
    at_data(:,km)   = value2
    at_data = lusolve(alu,kp,at_data)

  end subroutine at_BoundariesTau_DD_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001358" class="method-detail">
        <a name="M001358"></a>

        <div class="method-heading">


          <a href="#M001358" class="method-signature">



          <span class="method-name">at_BoundariesTau_DD</span><span class="method-args">( t_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 1 次元配列用) 両境界での値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001358-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001358-source">
<pre>
  subroutine at_BoundariesTau_DD_1d(t_data,values)
    !
    ! Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
    ! 両境界での値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: t_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), dimension(2), intent(in), optional  :: values
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: at_work
    real(8), dimension(1,2)                      :: vwork           ! 境界値

    if (.not. present(values)) then
       vwork(1,1)=0 
        vwork(1,2)=0
    else
       vwork(1,:) = values
    endif

    at_work(1,:)=t_data
    call at_BoundariesTau_DD_2d(at_work,vwork)
    t_data=at_work(1,:)

  end subroutine at_BoundariesTau_DD_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001361" class="method-detail">
        <a name="M001361"></a>

        <div class="method-heading">


          <a href="#M001361" class="method-signature">



          <span class="method-name">at_BoundariesTau_DN</span><span class="method-args">( at_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m,2)

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet/Neumann 型境界条件の適用(タウ法, 2 次元配列用) i=0 で値, i=im
で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001361-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001361-source">
<pre>
  subroutine at_BoundariesTau_DN_2d(at_data,values)
    !
    ! Dirichlet/Neumann 型境界条件の適用(タウ法, 2 次元配列用)
    ! i=0 で値, i=im で勾配の値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: at_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:,:), intent(in), optional  :: values
    !(in) 境界値(m,2)

    real(8), dimension(:,:), allocatable  :: alu
    integer, dimension(:), allocatable    :: kp
    real(8), dimension(0:km,0:km)         :: tt_data
    real(8), dimension(0:km,0:im)         :: tg_data
    real(8), dimension(size(at_data,1))    :: value1, value2           ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( size(at_data,2)-1 &lt; km ) then
       call MessageNotify('E','at_BoundariesTau_DN', 'The Chebyshev dimension of input data too small.')
    elseif ( size(at_data,2)-1 &gt; km ) then
       call MessageNotify('W','at_BoundariesTau_DN', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(values)) then
       value1=0 
        value2=0
    else
       value1 = values(:,1) 
        value2 = values(:,2)
    endif

    if ( first ) then
       first = .false.

       allocate(alu(0:km,0:km),kp(0:km))

       tt_data = 0
       do k=0,km
          tt_data(k,k)=1
       enddo
       alu = tt_data

       tg_data = ag_at(tt_data)
       alu(km-1,:) = tg_data(:,0)
       tg_data = ag_at(at_Dx_at(tt_data))
       alu(km,:)   = tg_data(:,im)

       call ludecomp(alu,kp)
    endif

    at_data(:,km-1) = value1
    at_data(:,km)   = value2
    at_data = lusolve(alu,kp,at_data)

  end subroutine at_BoundariesTau_DN_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001360" class="method-detail">
        <a name="M001360"></a>

        <div class="method-heading">


          <a href="#M001360" class="method-signature">



          <span class="method-name">at_BoundariesTau_DN</span><span class="method-args">( t_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet/Neumann 型境界条件の適用(タウ法, 1 次元配列用) i=0 で値, i=im
で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001360-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001360-source">
<pre>
  subroutine at_BoundariesTau_DN_1d(t_data,values)
    !
    ! Dirichlet/Neumann 型境界条件の適用(タウ法, 1 次元配列用)
    ! i=0 で値, i=im で勾配の値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: t_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), dimension(2), intent(in), optional  :: values 
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: at_work
    real(8), dimension(1,2)                      :: vwork           ! 境界値

    if (.not. present(values)) then
       vwork(1,1)=0 
        vwork(1,2)=0
    else
       vwork(1,:) = values
    endif

    at_work(1,:)=t_data
    call at_BoundariesTau_DN_2d(at_work,vwork)
    t_data=at_work(1,:)

  end subroutine at_BoundariesTau_DN_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001363" class="method-detail">
        <a name="M001363"></a>

        <div class="method-heading">


          <a href="#M001363" class="method-signature">



          <span class="method-name">at_BoundariesTau_ND</span><span class="method-args">( at_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m,2)

</td></tr>
</table>
</td></tr>
</table>
<p>
Neumann/Dirichlet 型境界条件の適用(タウ法, 2 次元配列用) i=0 で勾配の値,
i=im で値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001363-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001363-source">
<pre>
  subroutine at_BoundariesTau_ND_2d(at_data,values)
    !
    ! Neumann/Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
    ! i=0 で勾配の値, i=im で値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: at_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:,:), intent(in), optional  :: values
    !(in) 境界値(m,2)

    real(8), dimension(:,:), allocatable  :: alu
    integer, dimension(:), allocatable    :: kp
    real(8), dimension(0:km,0:km)         :: tt_data
    real(8), dimension(0:km,0:im)         :: tg_data
    real(8), dimension(size(at_data,1))    :: value1, value2           ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( size(at_data,2)-1 &lt; km ) then
       call MessageNotify('E','at_BoundariesTau_ND', 'The Chebyshev dimension of input data too small.')
    elseif ( size(at_data,2)-1 &gt; km ) then
       call MessageNotify('W','at_BoundariesTau_ND', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(values)) then
       value1=0 
        value2=0
    else
       value1 = values(:,1) 
        value2 = values(:,2)
    endif

    if ( first ) then
       first = .false.

       allocate(alu(0:km,0:km),kp(0:km))

       tt_data = 0
       do k=0,km
          tt_data(k,k)=1
       enddo
       alu = tt_data

       tg_data = ag_at(at_Dx_at(tt_data))
       alu(km-1,:) = tg_data(:,0)
       tg_data = ag_at(tt_data)
       alu(km,:)   = tg_data(:,im)

       call ludecomp(alu,kp)
    endif

    at_data(:,km-1) = value1
    at_data(:,km)   = value2
    at_data = lusolve(alu,kp,at_data)

  end subroutine at_BoundariesTau_ND_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001362" class="method-detail">
        <a name="M001362"></a>

        <div class="method-heading">


          <a href="#M001362" class="method-signature">



          <span class="method-name">at_BoundariesTau_ND</span><span class="method-args">( t_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Neumann/Dirichlet 型境界条件の適用(タウ法, 1 次元配列用) i=0 で勾配の値,
i=im で値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001362-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001362-source">
<pre>
  subroutine at_BoundariesTau_ND_1d(t_data,values)
    !
    ! Neumann/Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
    ! i=0 で勾配の値, i=im で値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: t_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), dimension(2), intent(in), optional  :: values
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: at_work
    real(8), dimension(1,2)                      :: vwork           ! 境界値

    if (.not. present(values)) then
       vwork(1,1)=0 
        vwork(1,2)=0
    else
       vwork(1,:) = values
    endif

    at_work(1,:)=t_data
    call at_BoundariesTau_ND_2d(at_work,vwork)
    t_data=at_work(1,:)

  end subroutine at_BoundariesTau_ND_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001365" class="method-detail">
        <a name="M001365"></a>

        <div class="method-heading">


          <a href="#M001365" class="method-signature">



          <span class="method-name">at_BoundariesTau_NN</span><span class="method-args">( at_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m,2)

</td></tr>
</table>
</td></tr>
</table>
<p>
Neumann/Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
両境界で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001365-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001365-source">
<pre>
  subroutine at_BoundariesTau_NN_2d(at_data,values)
    !
    ! Neumann/Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
    ! 両境界で勾配の値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: at_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:,:), intent(in), optional  :: values
    !(in) 境界値(m,2)

    real(8), dimension(:,:), allocatable  :: alu
    integer, dimension(:), allocatable    :: kp
    real(8), dimension(0:km,0:km)         :: tt_data
    real(8), dimension(0:km,0:im)         :: tg_data
    real(8), dimension(size(at_data,1))    :: value1, value2           ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( size(at_data,2)-1 &lt; km ) then
       call MessageNotify('E','at_BoundariesTau_NN', 'The Chebyshev dimension of input data too small.')
    elseif ( size(at_data,2)-1 &gt; km ) then
       call MessageNotify('W','at_BoundariesTau_NN', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(values)) then
       value1=0 
        value2=0
    else
       value1 = values(:,1) 
        value2 = values(:,2)
    endif

    if ( first ) then
       first = .false.

       allocate(alu(0:km,0:km),kp(0:km))

       tt_data = 0
       do k=0,km
          tt_data(k,k)=1
       enddo
       alu = tt_data

       tg_data = ag_at(at_Dx_at(tt_data))
       alu(km-1,:) = tg_data(:,0)
       alu(km,:)   = tg_data(:,im)

       call ludecomp(alu,kp)
    endif

    at_data(:,km-1) = value1
    at_data(:,km)   = value2
    at_data = lusolve(alu,kp,at_data)

  end subroutine at_BoundariesTau_NN_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001364" class="method-detail">
        <a name="M001364"></a>

        <div class="method-heading">


          <a href="#M001364" class="method-signature">



          <span class="method-name">at_BoundariesTau_NN</span><span class="method-args">( t_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Neumann/Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
両境界で勾配の値を与える.
</p>
<p>
このサブルーチンを直接使うことを勧めない. 共通インターフェース <a
href="at_module.html#M001356">at_Boundaries_NN</a> を用いること.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001364-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001364-source">
<pre>
  subroutine at_BoundariesTau_NN_1d(t_data,values)
    !
    ! Neumann/Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
    ! 両境界で勾配の値を与える.
    !
    ! このサブルーチンを直接使うことを勧めない. 
    ! 共通インターフェース at_Boundaries_NN を用いること. 
    !
    real(8), dimension(0:km),intent(inout)       :: t_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), dimension(2), intent(in), optional  :: values
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: at_work
    real(8), dimension(1,2)                      :: vwork           ! 境界値

    if (.not. present(values)) then
       vwork(1,1)=0 
        vwork(1,2)=0
    else
       vwork(1,:) = values
    endif

    at_work(1,:)=t_data
    call at_BoundariesTau_NN_2d(at_work,vwork)
    t_data=at_work(1,:)

  end subroutine at_BoundariesTau_NN_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001351" class="method-detail">
        <a name="M001351"></a>

        <div class="method-heading">


          <a href="#M001351" class="method-signature">



          <span class="method-name">at_Boundaries_DD</span><span class="method-args">( at_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> データ(m,0:km) (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m,2)

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 2 次元配列用) 両境界での値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001351-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001351-source">
<pre>
  subroutine at_BoundariesTau_DD_2d(at_data,values)
    !
    ! Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
    ! 両境界での値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: at_data ! データ(m,0:km)
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:,:), intent(in), optional  :: values
    !(in) 境界値(m,2)

    real(8), dimension(:,:), allocatable  :: alu
    integer, dimension(:), allocatable    :: kp
    real(8), dimension(0:km,0:km)         :: tt_data
    real(8), dimension(0:km,0:im)         :: tg_data
    real(8), dimension(size(at_data,1))    :: value1, value2           ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( size(at_data,2)-1 &lt; km ) then
       call MessageNotify('E','at_BoundariesTau_DD', 'The Chebyshev dimension of input data too small.')
    elseif ( size(at_data,2)-1 &gt; km ) then
       call MessageNotify('W','at_BoundariesTau_DD', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(values)) then
       value1=0 
        value2=0
    else
       value1 = values(:,1) 
        value2 = values(:,2)
    endif

    if ( first ) then
       first = .false.

       allocate(alu(0:km,0:km),kp(0:km))

       tt_data=0
       do k=0,km
          tt_data(k,k)=1
       enddo
       alu = tt_data

       tg_data = ag_at(tt_data)
       alu(km-1,:) = tg_data(:,0)
       alu(km,:)   = tg_data(:,im)

       call ludecomp(alu,kp)
    endif

    at_data(:,km-1) = value1
    at_data(:,km)   = value2
    at_data = lusolve(alu,kp,at_data)

  end subroutine at_BoundariesTau_DD_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001350" class="method-detail">
        <a name="M001350"></a>

        <div class="method-heading">


          <a href="#M001350" class="method-signature">



          <span class="method-name">at_Boundaries_DD</span><span class="method-args">( t_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 1 次元配列用) 両境界での値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001350-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001350-source">
<pre>
  subroutine at_BoundariesTau_DD_1d(t_data,values)
    !
    ! Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
    ! 両境界での値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: t_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), dimension(2), intent(in), optional  :: values
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: at_work
    real(8), dimension(1,2)                      :: vwork           ! 境界値

    if (.not. present(values)) then
       vwork(1,1)=0 
        vwork(1,2)=0
    else
       vwork(1,:) = values
    endif

    at_work(1,:)=t_data
    call at_BoundariesTau_DD_2d(at_work,vwork)
    t_data=at_work(1,:)

  end subroutine at_BoundariesTau_DD_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001353" class="method-detail">
        <a name="M001353"></a>

        <div class="method-heading">


          <a href="#M001353" class="method-signature">



          <span class="method-name">at_Boundaries_DN</span><span class="method-args">( at_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m,2)

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet/Neumann 型境界条件の適用(タウ法, 2 次元配列用) i=0 で値, i=im
で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001353-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001353-source">
<pre>
  subroutine at_BoundariesTau_DN_2d(at_data,values)
    !
    ! Dirichlet/Neumann 型境界条件の適用(タウ法, 2 次元配列用)
    ! i=0 で値, i=im で勾配の値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: at_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:,:), intent(in), optional  :: values
    !(in) 境界値(m,2)

    real(8), dimension(:,:), allocatable  :: alu
    integer, dimension(:), allocatable    :: kp
    real(8), dimension(0:km,0:km)         :: tt_data
    real(8), dimension(0:km,0:im)         :: tg_data
    real(8), dimension(size(at_data,1))    :: value1, value2           ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( size(at_data,2)-1 &lt; km ) then
       call MessageNotify('E','at_BoundariesTau_DN', 'The Chebyshev dimension of input data too small.')
    elseif ( size(at_data,2)-1 &gt; km ) then
       call MessageNotify('W','at_BoundariesTau_DN', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(values)) then
       value1=0 
        value2=0
    else
       value1 = values(:,1) 
        value2 = values(:,2)
    endif

    if ( first ) then
       first = .false.

       allocate(alu(0:km,0:km),kp(0:km))

       tt_data = 0
       do k=0,km
          tt_data(k,k)=1
       enddo
       alu = tt_data

       tg_data = ag_at(tt_data)
       alu(km-1,:) = tg_data(:,0)
       tg_data = ag_at(at_Dx_at(tt_data))
       alu(km,:)   = tg_data(:,im)

       call ludecomp(alu,kp)
    endif

    at_data(:,km-1) = value1
    at_data(:,km)   = value2
    at_data = lusolve(alu,kp,at_data)

  end subroutine at_BoundariesTau_DN_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001352" class="method-detail">
        <a name="M001352"></a>

        <div class="method-heading">


          <a href="#M001352" class="method-signature">



          <span class="method-name">at_Boundaries_DN</span><span class="method-args">( t_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet/Neumann 型境界条件の適用(タウ法, 1 次元配列用) i=0 で値, i=im
で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001352-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001352-source">
<pre>
  subroutine at_BoundariesTau_DN_1d(t_data,values)
    !
    ! Dirichlet/Neumann 型境界条件の適用(タウ法, 1 次元配列用)
    ! i=0 で値, i=im で勾配の値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: t_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), dimension(2), intent(in), optional  :: values 
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: at_work
    real(8), dimension(1,2)                      :: vwork           ! 境界値

    if (.not. present(values)) then
       vwork(1,1)=0 
        vwork(1,2)=0
    else
       vwork(1,:) = values
    endif

    at_work(1,:)=t_data
    call at_BoundariesTau_DN_2d(at_work,vwork)
    t_data=at_work(1,:)

  end subroutine at_BoundariesTau_DN_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001355" class="method-detail">
        <a name="M001355"></a>

        <div class="method-heading">


          <a href="#M001355" class="method-signature">



          <span class="method-name">at_Boundaries_ND</span><span class="method-args">( at_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m,2)

</td></tr>
</table>
</td></tr>
</table>
<p>
Neumann/Dirichlet 型境界条件の適用(タウ法, 2 次元配列用) i=0 で勾配の値,
i=im で値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001355-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001355-source">
<pre>
  subroutine at_BoundariesTau_ND_2d(at_data,values)
    !
    ! Neumann/Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
    ! i=0 で勾配の値, i=im で値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: at_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:,:), intent(in), optional  :: values
    !(in) 境界値(m,2)

    real(8), dimension(:,:), allocatable  :: alu
    integer, dimension(:), allocatable    :: kp
    real(8), dimension(0:km,0:km)         :: tt_data
    real(8), dimension(0:km,0:im)         :: tg_data
    real(8), dimension(size(at_data,1))    :: value1, value2           ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( size(at_data,2)-1 &lt; km ) then
       call MessageNotify('E','at_BoundariesTau_ND', 'The Chebyshev dimension of input data too small.')
    elseif ( size(at_data,2)-1 &gt; km ) then
       call MessageNotify('W','at_BoundariesTau_ND', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(values)) then
       value1=0 
        value2=0
    else
       value1 = values(:,1) 
        value2 = values(:,2)
    endif

    if ( first ) then
       first = .false.

       allocate(alu(0:km,0:km),kp(0:km))

       tt_data = 0
       do k=0,km
          tt_data(k,k)=1
       enddo
       alu = tt_data

       tg_data = ag_at(at_Dx_at(tt_data))
       alu(km-1,:) = tg_data(:,0)
       tg_data = ag_at(tt_data)
       alu(km,:)   = tg_data(:,im)

       call ludecomp(alu,kp)
    endif

    at_data(:,km-1) = value1
    at_data(:,km)   = value2
    at_data = lusolve(alu,kp,at_data)

  end subroutine at_BoundariesTau_ND_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001354" class="method-detail">
        <a name="M001354"></a>

        <div class="method-heading">


          <a href="#M001354" class="method-signature">



          <span class="method-name">at_Boundaries_ND</span><span class="method-args">( t_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Neumann/Dirichlet 型境界条件の適用(タウ法, 1 次元配列用) i=0 で勾配の値,
i=im で値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001354-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001354-source">
<pre>
  subroutine at_BoundariesTau_ND_1d(t_data,values)
    !
    ! Neumann/Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
    ! i=0 で勾配の値, i=im で値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: t_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), dimension(2), intent(in), optional  :: values
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: at_work
    real(8), dimension(1,2)                      :: vwork           ! 境界値

    if (.not. present(values)) then
       vwork(1,1)=0 
        vwork(1,2)=0
    else
       vwork(1,:) = values
    endif

    at_work(1,:)=t_data
    call at_BoundariesTau_ND_2d(at_work,vwork)
    t_data=at_work(1,:)

  end subroutine at_BoundariesTau_ND_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001357" class="method-detail">
        <a name="M001357"></a>

        <div class="method-heading">


          <a href="#M001357" class="method-signature">



          <span class="method-name">at_Boundaries_NN</span><span class="method-args">( at_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m,2)

</td></tr>
</table>
</td></tr>
</table>
<p>
Neumann/Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
両境界で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001357-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001357-source">
<pre>
  subroutine at_BoundariesTau_NN_2d(at_data,values)
    !
    ! Neumann/Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
    ! 両境界で勾配の値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: at_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:,:), intent(in), optional  :: values
    !(in) 境界値(m,2)

    real(8), dimension(:,:), allocatable  :: alu
    integer, dimension(:), allocatable    :: kp
    real(8), dimension(0:km,0:km)         :: tt_data
    real(8), dimension(0:km,0:im)         :: tg_data
    real(8), dimension(size(at_data,1))    :: value1, value2           ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( size(at_data,2)-1 &lt; km ) then
       call MessageNotify('E','at_BoundariesTau_NN', 'The Chebyshev dimension of input data too small.')
    elseif ( size(at_data,2)-1 &gt; km ) then
       call MessageNotify('W','at_BoundariesTau_NN', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(values)) then
       value1=0 
        value2=0
    else
       value1 = values(:,1) 
        value2 = values(:,2)
    endif

    if ( first ) then
       first = .false.

       allocate(alu(0:km,0:km),kp(0:km))

       tt_data = 0
       do k=0,km
          tt_data(k,k)=1
       enddo
       alu = tt_data

       tg_data = ag_at(at_Dx_at(tt_data))
       alu(km-1,:) = tg_data(:,0)
       alu(km,:)   = tg_data(:,im)

       call ludecomp(alu,kp)
    endif

    at_data(:,km-1) = value1
    at_data(:,km)   = value2
    at_data = lusolve(alu,kp,at_data)

  end subroutine at_BoundariesTau_NN_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001356" class="method-detail">
        <a name="M001356"></a>

        <div class="method-heading">


          <a href="#M001356" class="method-signature">



          <span class="method-name">at_Boundaries_NN</span><span class="method-args">( t_data, [values] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Neumann/Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
両境界で勾配の値を与える.
</p>
<p>
このサブルーチンを直接使うことを勧めない. 共通インターフェース <a
href="at_module.html#M001356">at_Boundaries_NN</a> を用いること.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001356-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001356-source">
<pre>
  subroutine at_BoundariesTau_NN_1d(t_data,values)
    !
    ! Neumann/Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
    ! 両境界で勾配の値を与える.
    !
    ! このサブルーチンを直接使うことを勧めない. 
    ! 共通インターフェース at_Boundaries_NN を用いること. 
    !
    real(8), dimension(0:km),intent(inout)       :: t_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), dimension(2), intent(in), optional  :: values
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: at_work
    real(8), dimension(1,2)                      :: vwork           ! 境界値

    if (.not. present(values)) then
       vwork(1,1)=0 
        vwork(1,2)=0
    else
       vwork(1,:) = values
    endif

    at_work(1,:)=t_data
    call at_BoundariesTau_NN_2d(at_work,vwork)
    t_data=at_work(1,:)

  end subroutine at_BoundariesTau_NN_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001342" class="method-detail">
        <a name="M001342"></a>

        <div class="method-heading">


          <a href="#M001342" class="method-signature">



          <span class="method-name">at_Dx_at</span><span class="method-args">( at_data ) result(at_Dx_at)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001342">at_Dx_at</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(at_data,1),0:size(at_data,2)-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの X 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力チェビシェフデータに X 微分を作用する(2 次元配列用).
</p>
<p>
チェビシェフデータの X 微分とは, 対応する格子点データに X 微分を
作用させたデータのチェビシェフ変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001342-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001342-source">
<pre>
  function at_Dx_at(at_data)
    !
    ! 入力チェビシェフデータに X 微分を作用する(2 次元配列用).
    !
    ! チェビシェフデータの X 微分とは, 対応する格子点データに X 微分を
    ! 作用させたデータのチェビシェフ変換のことである.
    !
    !
    real(8), dimension(:,0:), intent(in)                    :: at_data
    !(in) 入力チェビシェフデータ

    real(8), dimension(size(at_data,1),0:size(at_data,2)-1) :: at_Dx_at
    !(out) チェビシェフデータの X 微分

    integer :: m, k
    integer :: nm, kmax

    nm=size(at_data,1)
    kmax=size(at_data,2)-1
    if ( kmax  &lt; km ) then
       call MessageNotify('W','at_Dx_at', 'The Chebyshev dimension of input data too small.')
    elseif ( kmax &gt; km ) then
       call MessageNotify('E','at_Dx_at', 'The Chebyshev dimension of input data too large.')
    endif

    if ( kmax == im ) then
       do m=1,nm
          at_Dx_at(m,kmax)   = 0. 
          at_Dx_at(m,kmax-1) = 2 * km * at_data(m,kmax) /2
       enddo
    else
       do m=1,nm
          at_Dx_at(m,kmax)   = 0. 
          at_Dx_at(m,kmax-1) = 2 * km * at_data(m,kmax) 
          ! スタートはグリッド対応最大波数未満. Factor 1/2 不要
       enddo
    endif

    do k=kmax-2,0,-1
       do m=1,nm
          at_Dx_at(m,k) = at_Dx_at(m,k+2) + 2*(k+1)*at_data(m,k+1)
       enddo
    enddo

    do k=0,kmax
       do m=1,nm
          at_Dx_at(m,k) = 2/xl * at_Dx_at(m,k)
       enddo
    enddo

  end function at_Dx_at
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001337" class="method-detail">
        <a name="M001337"></a>

        <div class="method-heading">


          <a href="#M001337" class="method-signature">



          <span class="method-name">at_Initial</span><span class="method-args">( i, k, xmin, xmax ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>i  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>k  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 切断波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xmin  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 座標の範囲

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xmax  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 座標の範囲

</td></tr>
</table>
</td></tr>
</table>
<p>
チェビシェフ変換の格子点数, 波数, 領域の大きさを設定する.
</p>
<p>
他の関数や変数を呼ぶ前に, 最初にこのサブルーチンを呼んで
初期設定をしなければならない.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001337-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001337-source">
<pre>
  subroutine at_Initial(i,k,xmin,xmax)
    !
    ! チェビシェフ変換の格子点数, 波数, 領域の大きさを設定する.
    !
    ! 他の関数や変数を呼ぶ前に, 最初にこのサブルーチンを呼んで
    ! 初期設定をしなければならない.
    !
    integer,intent(in) :: i              !(in) 格子点数
    integer,intent(in) :: k              !(in) 切断波数
    real(8),intent(in) :: xmin, xmax     !(in) 座標の範囲

    integer :: ii,kk

    im=i 
     km=k 
    xl = xmax-xmin

    if ( im &lt;= 0 .or. km &lt;= 0 ) then
       call MessageNotify('E','at_initial', 'Number of grid points and waves should be positive')
    elseif ( mod(im,2) /= 0 ) then
       call MessageNotify('E','at_initial','Number of grid points should be even')
    elseif ( km &gt; im ) then
       call MessageNotify('E','at_initial','KM shoud be less equal IM')
    endif

    if ( allocated(t) ) deallocate(t)
    allocate(t(3*im))
    call fttcti(im,it,t)

    if ( allocated(g_X) ) deallocate(g_X)
    allocate(g_X(0:im))
    do ii=0,im
       g_X(ii) = (xmax+xmin)/2 + xl/2 * cos(pi*ii/im)
    enddo

    if ( allocated(g_X_Weight) ) deallocate(g_X_Weight)
    allocate(g_X_Weight(0:im))
    do ii=0,im
       g_X_Weight(ii) = 1.0
       do kk=2,km,2
          g_X_Weight(ii) = g_X_Weight(ii) + 2/(1D0-kk**2) * cos(kk*ii*pi/im)
       enddo
       if ( (km == im) .and. (mod(im,2)==0) ) then  ! 最後の和は factor 1/2.
          g_X_Weight(ii) = g_X_Weight(ii) - 1/(1D0-km**2)* cos(km*ii*pi/im)
       endif
       g_X_Weight(ii) = 2D0/im * g_X_Weight(ii) * xl/2
    enddo
    g_X_Weight(0)  = g_X_Weight(0) / 2
    g_X_Weight(im) = g_X_Weight(im) / 2

    call MessageNotify('M','at_initial','at_module (2009/01/09) is initialized')
  end subroutine at_Initial
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001340" class="method-detail">
        <a name="M001340"></a>

        <div class="method-heading">


          <a href="#M001340" class="method-signature">



          <span class="method-name">at_ag</span><span class="method-args">( ag_data ) result(at_ag)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001340">at_ag</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(ag_data,1),0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ag_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからチェビシェフデータへ変換する(2 次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001340-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001340-source">
<pre>
  function at_ag(ag_data)
    !
    ! 格子データからチェビシェフデータへ変換する(2 次元配列用).
    !
    real(8), dimension(:,:), intent(in)      :: ag_data
    !(in) 格子点データ

    real(8), dimension(size(ag_data,1),0:km) :: at_ag
    !(out) チェビシェフデータ

    real(8), dimension(size(ag_data,1)*im)   :: y
    real(8), dimension(size(ag_data,1),0:im) :: ag_work
    integer :: m

    m = size(ag_data,1)
    if ( size(ag_data,2)-1 &lt; im ) then
       call MessageNotify('E','at_ag', 'The Grid points of input data too small.')
    elseif ( size(ag_data,2)-1 &gt; im ) then
       call MessageNotify('W','at_ag', 'The Grid points of input data too large.')
    endif
    ag_work = ag_data

    call fttctf(m,im,ag_work,y,it,t)
    at_ag = ag_work(:,0:km)

  end function at_ag
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001335" class="method-detail">
        <a name="M001335"></a>

        <div class="method-heading">




          <span class="method-name">g_X</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001335">g_X</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点座標 km 次のチェビシェフ多項式の零点から定まる格子点

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001336" class="method-detail">
        <a name="M001336"></a>

        <div class="method-heading">




          <span class="method-name">g_X_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001336">g_X_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点重み座標 各格子点における積分のための重みが格納してある

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001339" class="method-detail">
        <a name="M001339"></a>

        <div class="method-heading">


          <a href="#M001339" class="method-signature">



          <span class="method-name">g_t</span><span class="method-args">( t_data ) result(g_t)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001339">g_t</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
チェビシェフデータから格子データへ変換する(1 次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001339-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001339-source">
<pre>
  function g_t(t_data)
    !
    ! チェビシェフデータから格子データへ変換する(1 次元配列用).
    !
    real(8), dimension(:), intent(in)  :: t_data
    !(in) チェビシェフデータ

    real(8), dimension(0:im)           :: g_t
    !(out) 格子点データ

    real(8), dimension(1,size(t_data)) :: t_work
    ! 作業用配列
    real(8), dimension(1,0:im)         :: g_work
    ! 作業用配列

    t_work(1,:) = t_data  
    g_work = ag_at(t_work)
    g_t = g_work(1,:)

  end function g_t
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001343" class="method-detail">
        <a name="M001343"></a>

        <div class="method-heading">


          <a href="#M001343" class="method-signature">



          <span class="method-name">t_Dx_t</span><span class="method-args">( t_data ) result(t_Dx_t)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001343">t_Dx_t</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(t_data))</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの X 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力チェビシェフデータに X 微分を作用する(1 次元配列用).
</p>
<p>
チェビシェフデータの X 微分とは, 対応する格子点データに X 微分を
作用させたデータのチェビシェフ変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001343-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001343-source">
<pre>
  function t_Dx_t(t_data)
    !
    ! 入力チェビシェフデータに X 微分を作用する(1 次元配列用).
    !
    ! チェビシェフデータの X 微分とは, 対応する格子点データに X 微分を
    ! 作用させたデータのチェビシェフ変換のことである.
    !
    !
    real(8), dimension(:), intent(in)   :: t_data
    !(in) 入力チェビシェフデータ

    real(8), dimension(size(t_data))    :: t_Dx_t
    !(out) チェビシェフデータの X 微分

    real(8), dimension(1,size(t_data))  :: at_work
    ! 作業用配列
    
    at_work(1,:) = t_data
    at_work = at_Dx_at(at_work)
    t_Dx_t = at_work(1,:)

  end function t_Dx_t
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001341" class="method-detail">
        <a name="M001341"></a>

        <div class="method-heading">


          <a href="#M001341" class="method-signature">



          <span class="method-name">t_g</span><span class="method-args">( g_data ) result(t_g)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="at_module.html#M001341">t_g</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>g_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
台形格子 -&gt; スペクトル
</p>
<p>
格子データからチェビシェフデータへ変換する(1 次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001341-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001341-source">
<pre>
  function t_g(g_data)  ! 台形格子 -&gt; スペクトル
    !
    ! 格子データからチェビシェフデータへ変換する(1 次元配列用).
    !
    real(8), dimension(:), intent(in)     :: g_data
    !(in) 格子点データ

    real(8), dimension(0:km)              :: t_g
    !(out) チェビシェフデータ

    real(8), dimension(1,size(g_data)) :: ag_work
    real(8), dimension(1,0:km)         :: at_work

    ag_work(1,:) = g_data
    at_work = at_ag(ag_work)
    t_g = at_work(1,:)
    
  end function t_g
</pre>
          </div>

        </div>
      </div>



    </div>



  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
