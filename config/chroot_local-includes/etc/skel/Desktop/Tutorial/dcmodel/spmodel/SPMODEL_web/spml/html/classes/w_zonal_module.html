<?xml version="1.0" encoding="euc-jp"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: w_zonal_module</title>
  <meta http-equiv="Content-Type" content="text/html; charset=euc-jp" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">w_zonal_module</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../files/src/w_zonal_module_f90.html">

                src/w_zonal_module.f90

                </a>


        <br />
            </td>
        </tr>


        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">


  <div id="contextContent">



    <div id="description">
      <h1><a href="w_zonal_module.html">w_zonal_module</a></h1>
<table>
<tr><td valign="top">Authors:</td><td>Shin-ichi Takehiro

</td></tr>
<tr><td valign="top">Version:</td><td>$Id: <a
href="../files/src/w_zonal_module_f90.html">w_zonal_module.f90</a>,v 1.6
2009-02-28 21:33:47 uwabami Exp $

</td></tr>
<tr><td valign="top">Copyright&amp;License:</td><td>See <a href="../../COPYRIGHT">COPYRIGHT</a>

</td></tr>
</table>
<h2>概要</h2>
<p>
spml/w_zonal_module モジュールは球面上での経度方向に一様な帯状的 1
次元流体運動をルジャンドル多項式を用いたスペクトル法によって
数値計算するための Fortran90 関数を提供する.
</p>
<p>
内部で <a href="l_module.html">l_module</a> を用いている.
最下部ではルジャンドル多項式変換 のエンジンとして ISPACK の Fortran77
サブルーチンを用いている.
</p>
<p>
w_zonal_modulde で提供される関数・サブルーチンは 2 次元的流体運動を扱う <a
href="w_module.html">w_module</a>
モジュールで用いられているものと名前およびインターフェースが
共通になるように設計してある. したがって, <a
href="w_module.html">w_module</a> を用いて構成された 2
次元モデルを帯状方向に一様な 1 次元軸対称モデルへと改造するには
次の手順が必要となる.
</p>
<ol>
<li>use 文での <a href="wt_module.html">wt_module</a> の引用を <a
href="w_zonal_module.html">w_zonal_module</a> に変更する.

</li>
<li>配列の大きさを経度方向格子点数 im -&gt; 1 に, 水平波数を (nm+1)**2 -&gt;
nm+1 に変更する.

</li>
<li>DO 文で水平波数に関してループを回しているところを (nm+1)**2 -&gt; nm+1
に変更する.

</li>
<li>gtool 出力の次元変数変更する.

</li>
</ol>
<h2>関数・変数の名前と型について</h2>
<h3>命名法</h3>
<ul>
<li>関数名の先頭 (w_, nm_, n_, xy_, x_, y_) は, 返す値の形を示している.

<table>
<tr><td valign="top">w_   :</td><td>スペクトルデータ

</td></tr>
<tr><td valign="top">xy_  :</td><td>2 次元格子点データ

</td></tr>
<tr><td valign="top">nm_  :</td><td>スペクトルデータの並んだ 3 次元配列(スペクトルデータの並びは 全波数 n,
帯状波数 m で指定される 2 次元配列)

</td></tr>
<tr><td valign="top">n_   :</td><td>スペクトルデータの並んだ 2 次元配列 (スペクトルデータの並びは 全波数 n
で指定される 1 次元配列)

</td></tr>
<tr><td valign="top">x_   :</td><td>経度方向 1 次元格子点データ

</td></tr>
<tr><td valign="top">y_   :</td><td>緯度方向 1 次元格子点データ

</td></tr>
</table>
</li>
<li>関数名の間の文字列(DLon, GradLat, GradLat, DivLon, DivLat, Lapla, LaplaInv,
Jacobian)は, その関数の作用を表している.

</li>
<li>関数名の最後 (_w_w, _w, _xy, _x, _y) は, 入力変数の形スペクトルデータ
および格子点データであることを示している.

<table>
<tr><td valign="top">_w   :</td><td>スペクトルデータ

</td></tr>
<tr><td valign="top">_w_w :</td><td>2 つのスペクトルデータ

</td></tr>
<tr><td valign="top">_xy  :</td><td>2 次元格子点データ

</td></tr>
<tr><td valign="top">_x   :</td><td>経度方向 1 次元格子点データ

</td></tr>
<tr><td valign="top">_y   :</td><td>緯度方向 1 次元格子点データ

</td></tr>
</table>
</li>
</ul>
<h3>各データの種類の説明</h3>
<ul>
<li>xy : 2 次元格子点データ.

<ul>
<li>変数の種類と次元は real(8), dimension(0:im-1,1:jm).

</li>
<li>im, jm はそれぞれ経度, 緯度座標の格子点数であり, サブルーチン <a
href="w_zonal_module.html#M001871">w_Initial</a>
にてあらかじめ設定しておく.

</li>
</ul>
</li>
<li>w : スペクトルデータ.

<ul>
<li>変数の種類と次元は real(8), dimension(nm+1).

</li>
<li>nm はルジャンドル多項式の最大次数であり, サブルーチン <a
href="w_zonal_module.html#M001871">w_Initial</a> にて
あらかじめ設定しておく. <a href="w_module.html">w_module</a>
と配列の大きさが異なることに注意.

</li>
</ul>
</li>
<li>nm : スペクトルデータの並んだ 2 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(0:nm,-nm:nm). 第 1 次元が水平全波数,
第 2 次元が帯状波数(ダミー)を表す.

</li>
<li>nm はルジャンドル多項式の最大次数であり, サブルーチン <a
href="w_zonal_module.html#M001871">w_Initial</a> にて
あらかじめ設定しておく.

</li>
</ul>
</li>
<li>n : スペクトルデータの並んだ 1 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(0:nm).

</li>
<li>第 1 次元が水平全波数を表す. nm は球面調和函数の最大全波数であり,
サブルーチン <a href="w_zonal_module.html#M001871">w_Initial</a>
にてあらかじめ設定しておく.

</li>
</ul>
</li>
<li>x, y : 経度, 緯度方向 1 次元格子点データ.

<ul>
<li>変数の種類と次元はそれぞれ real(8), dimension(0:im-1) および real(8),
dimension(1:jm).

</li>
</ul>
</li>
<li>w_ で始まる関数が返す値はスペクトルデータに同じ.

</li>
<li>xy_ で始まる関数が返す値は 2 次元格子点データに同じ.

</li>
<li>x_, y_ で始まる関数が返す値は 1 次元格子点データに同じ.

</li>
<li>スペクトルデータに対する微分等の作用とは, 対応する格子点データに
微分などを作用させたデータをスペクトル変換したものことである.

</li>
</ul>
<h2>変数・手続き群の要約</h2>
<h4>初期化</h4>
<table>
<tr><td valign="top"><a href="w_zonal_module.html#M001871">w_Initial</a> :</td><td>スペクトル変換の格子点数, 波数, 領域の大きさの設定

</td></tr>
</table>
<h4>座標変数</h4>
<table>
<tr><td valign="top"><a href="w_zonal_module.html#M001864">x_Lon</a>, <a href="w_zonal_module.html#M001904">y_Lat</a>     :</td><td>格子点座標(緯度, 経度座標)を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001865">x_Lon_Weight</a>, <a href="w_zonal_module.html#M001905">y_Lat_Weight</a> :</td><td>重み座標を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001866">xy_Lon</a>, <a href="w_zonal_module.html#M001867">xy_Lat</a>   :</td><td>格子点データの経度・緯度座標(X,Y) (格子点データ型 2 次元配列)

</td></tr>
</table>
<h4>基本変換</h4>
<table>
<tr><td valign="top"><a href="w_zonal_module.html#M001872">xy_w</a> :</td><td>スペクトルデータから格子データへの変換

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001873">w_xy</a> :</td><td>格子データからスペクトルデータへの変換

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001898">l_nm</a>, <a href="w_zonal_module.html#M001902">nm_l</a> :</td><td>スペクトルデータの格納位置と全波数・帯状波数の変換

</td></tr>
</table>
<h4>微分</h4>
<table>
<tr><td valign="top"><a href="w_zonal_module.html#M001906">w_Lapla_w</a>       :</td><td>スペクトルデータにラプラシアンを作用させる

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001868">rn</a>              :</td><td>スペクトルデータのラプラシアンを計算するための係数.

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001869">irm</a>             :</td><td>経度微分演算用配列

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001907">w_LaplaInv_w</a>    :</td><td>スペクトルデータにラプラシアンの逆変換を作用させる

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001874">w_DLon_w</a>        :</td><td>スペクトルデータに経度微分∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001875">xy_GradLon_w</a>    :</td><td>スペクトルデータに 勾配型経度微分 1/cosφ・∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001876">xy_GradLat_w</a>    :</td><td>スペクトルデータに勾配型緯度微分∂/∂φを作用させる

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001877">w_DivLon_xy</a>     :</td><td>格子データに 発散型経度微分 1/cosφ・∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001878">w_DivLat_xy</a>     :</td><td>格子データに 発散型緯度微分 1/cosφ・∂(g cosφ)/∂φを作用させる

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001879">w_Div_xy_xy</a>     :</td><td>ベクトル成分である 2 つの格子データに発散を作用させる

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001880">w_Jacobian_w_w</a>  :</td><td>2 つのスペクトルデータからヤコビアンを計算する

</td></tr>
</table>
<h4>微分(λ,μ=sinφ 座標)</h4>
<table>
<tr><td valign="top"><a href="w_zonal_module.html#M001881">xy_GradLambda_w</a> :</td><td>スペクトルデータに勾配型経度微分∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001882">xy_GradMu_w</a>     :</td><td>スペクトルデータに 勾配型緯度微分 (1-μ^2)∂/∂μを作用させる

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001883">w_DivLambda_xy</a>  :</td><td>格子データに 発散型経度微分 1/(1-μ^2)・∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001884">w_DivMu_xy</a>      :</td><td>格子データに発散型緯度微分∂/∂μを作用させる

</td></tr>
</table>
<h4>補間</h4>
<table>
<tr><td valign="top"><a href="w_zonal_module.html#M001885">Interpolate_w</a> :</td><td>スペクトルデータから任意の点での値を求める.

</td></tr>
</table>
<h4>積分・平均</h4>
<table>
<tr><td valign="top"><a href="w_zonal_module.html#M001889">IntLonLat_xy</a>, <a href="w_zonal_module.html#M001893">AvrLonLat_xy</a> :</td><td>2 次元格子点データの全領域積分および平均

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001888">y_IntLon_xy</a>, <a href="w_zonal_module.html#M001892">y_AvrLon_xy</a>   :</td><td>2 次元格子点データの経度方向積分および平均

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001886">IntLon_x</a>, <a href="w_zonal_module.html#M001890">AvrLon_x</a>         :</td><td>1 次元(X)格子点データの経度方向積分および平均

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001887">x_IntLat_xy</a>, <a href="w_zonal_module.html#M001891">x_AvrLat_xy</a>   :</td><td>2 次元格子点データの緯度方向積分および平均

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001908">IntLat_y</a>, <a href="w_zonal_module.html#M001909">AvrLat_y</a>         :</td><td>1 次元(Y)格子点データの緯度方向積分および平均

</td></tr>
</table>
<h4>スペクトル解析</h4>
<table>
<tr><td valign="top"><a href="w_zonal_module.html#M001894">nm_EnergyFromStreamfunc_w</a>  :</td><td>流線関数からエネルギースペクトルを 計算する (水平全波数 n, 帯状波数 m 空間)

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001895">n_EnergyFromStreamfunc_w</a>   :</td><td>流線関数からエネルギースペクトルを 計算する (水平全波数 n 空間)

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001896">nm_EnstrophyFromStreamfunc_w</a>  :</td><td>流線関数からエンストロフィースペクトルを 計算する (水平全波数 n, 帯状波数 m
空間)

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001897">n_EnstrophyFromStreamfunc_w</a>   :</td><td>流線関数からエンストロフィースペクトルを 計算する (水平全波数 n 空間)

</td></tr>
<tr><td valign="top"><a href="w_zonal_module.html#M001870">w_spectrum_VMiss</a>              :</td><td>欠損値

</td></tr>
</table>

    </div>





   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M001909">AvrLat_y</a>&nbsp;&nbsp;

        <a href="#M001893">AvrLonLat_xy</a>&nbsp;&nbsp;

        <a href="#M001890">AvrLon_x</a>&nbsp;&nbsp;

        <a href="#M001908">IntLat_y</a>&nbsp;&nbsp;

        <a href="#M001889">IntLonLat_xy</a>&nbsp;&nbsp;

        <a href="#M001886">IntLon_x</a>&nbsp;&nbsp;

        <a href="#M001885">Interpolate_w</a>&nbsp;&nbsp;

        <a href="#M001869">irm</a>&nbsp;&nbsp;

        <a href="#M001898">l_nm</a>&nbsp;&nbsp;

        <a href="#M001899">l_nm</a>&nbsp;&nbsp;

        <a href="#M001900">l_nm</a>&nbsp;&nbsp;

        <a href="#M001901">l_nm</a>&nbsp;&nbsp;

        <a href="#M001895">n_EnergyFromStreamfunc_w</a>&nbsp;&nbsp;

        <a href="#M001897">n_EnstrophyFromStreamfunc_w</a>&nbsp;&nbsp;

        <a href="#M001894">nm_EnergyFromStreamfunc_w</a>&nbsp;&nbsp;

        <a href="#M001896">nm_EnstrophyFromStreamfunc_w</a>&nbsp;&nbsp;

        <a href="#M001902">nm_l</a>&nbsp;&nbsp;

        <a href="#M001903">nm_l</a>&nbsp;&nbsp;

        <a href="#M001868">rn</a>&nbsp;&nbsp;

        <a href="#M001874">w_DLon_w</a>&nbsp;&nbsp;

        <a href="#M001883">w_DivLambda_xy</a>&nbsp;&nbsp;

        <a href="#M001878">w_DivLat_xy</a>&nbsp;&nbsp;

        <a href="#M001877">w_DivLon_xy</a>&nbsp;&nbsp;

        <a href="#M001884">w_DivMu_xy</a>&nbsp;&nbsp;

        <a href="#M001879">w_Div_xy_xy</a>&nbsp;&nbsp;

        <a href="#M001880">w_Jacobian_w_w</a>&nbsp;&nbsp;

        <a href="#M001907">w_LaplaInv_w</a>&nbsp;&nbsp;

        <a href="#M001906">w_Lapla_w</a>&nbsp;&nbsp;

        <a href="#M001871">w_initial</a>&nbsp;&nbsp;

        <a href="#M001870">w_spectrum_VMiss</a>&nbsp;&nbsp;

        <a href="#M001873">w_xy</a>&nbsp;&nbsp;

        <a href="#M001891">x_AvrLat_xy</a>&nbsp;&nbsp;

        <a href="#M001887">x_IntLat_xy</a>&nbsp;&nbsp;

        <a href="#M001864">x_Lon</a>&nbsp;&nbsp;

        <a href="#M001865">x_Lon_Weight</a>&nbsp;&nbsp;

        <a href="#M001881">xy_GradLambda_w</a>&nbsp;&nbsp;

        <a href="#M001876">xy_GradLat_w</a>&nbsp;&nbsp;

        <a href="#M001875">xy_GradLon_w</a>&nbsp;&nbsp;

        <a href="#M001882">xy_GradMu_w</a>&nbsp;&nbsp;

        <a href="#M001867">xy_Lat</a>&nbsp;&nbsp;

        <a href="#M001866">xy_Lon</a>&nbsp;&nbsp;

        <a href="#M001872">xy_w</a>&nbsp;&nbsp;

        <a href="#M001892">y_AvrLon_xy</a>&nbsp;&nbsp;

        <a href="#M001888">y_IntLon_xy</a>&nbsp;&nbsp;

        <a href="#M001904">y_Lat</a>&nbsp;&nbsp;

        <a href="#M001905">y_Lat_Weight</a>&nbsp;&nbsp;
      </div>
    </div>


  </div>


    <!-- if includes -->

    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">

        <span class="include-name">dc_message</span>

        <span class="include-name"><a href="l_module.html">l_module</a></span>
      </div>
    </div>



    <div id="section">










      


    <!-- if method_list -->

    <div id="methods">


      <h3 class="section-bar">Public Instance methods</h3>


      <div id="method-M001909" class="method-detail">
        <a name="M001909"></a>

        <div class="method-heading">




          <span class="method-name">AvrLat_y</span><span class="method-args">( y_data ) result(AvrLat_y)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001909">AvrLat_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y_data(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(Y)格子点データの緯度(Y)方向平均.
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, y_Y_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="l_module.html#M000657">l_module#AvrLat_y</a>
</p>


        </div>
      </div>


      <div id="method-M001893" class="method-detail">
        <a name="M001893"></a>

        <div class="method-heading">


          <a href="#M001893" class="method-signature">



          <span class="method-name">AvrLonLat_xy</span><span class="method-args">( xy_data ) result(AvrLonLat_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001893">AvrLonLat_xy</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの全領域平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた 総和を計算し,
x_X_Weight*y_Y_Weight の総和で割ることで平均している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001893-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001893-source">
<pre>
    function AvrLonLat_xy(xy_data)
      !
      ! 2 次元緯度経度格子点データの全領域平均(1 層用).
      !
      ! 実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた
      ! 総和を計算し, x_X_Weight*y_Y_Weight の総和で割ることで平均している. 
      !
      real(8), intent(in)   :: xy_data(0:im-1,1:jm)
      !(in) 2 次元経度緯度格子点データ

      real(8) :: AvrLonLat_xy
      !(out) 平均値

      AvrLonLat_xy = AvrLon_x(x_AvrLat_xy(xy_data))

    end function AvrLonLat_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001890" class="method-detail">
        <a name="M001890"></a>

        <div class="method-heading">


          <a href="#M001890" class="method-signature">



          <span class="method-name">AvrLon_x</span><span class="method-args">( x_data ) result(AvrLon_x)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001890">AvrLon_x</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>x_data(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(X)格子点データの経度(X)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, x_X_Weight
の総和で割ることで平均している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001890-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001890-source">
<pre>
    function AvrLon_x(x_data)
      !
      ! 1 次元(X)格子点データの経度(X)方向平均(1 層用).
      !
      ! 実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, 
      ! x_X_Weight の総和で割ることで平均している. 
      !
      real(8), intent(in) :: x_data(0:im-1)
      !(in)  1 次元経度(X)格子点データ
      real(8)             :: AvrLon_x       
      !(out) 平均値

      AvrLon_x = IntLon_x(x_data)/sum(x_Lon_weight)

    end function AvrLon_x
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001908" class="method-detail">
        <a name="M001908"></a>

        <div class="method-heading">




          <span class="method-name">IntLat_y</span><span class="method-args">( y_data ) result(IntLat_y)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001908">IntLat_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y_data(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元緯度(Y)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元緯度(Y)格子点データの Y 方向積分.
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="l_module.html#M000656">l_module#IntLat_y</a>
</p>


        </div>
      </div>


      <div id="method-M001889" class="method-detail">
        <a name="M001889"></a>

        <div class="method-heading">


          <a href="#M001889" class="method-signature">



          <span class="method-name">IntLonLat_xy</span><span class="method-args">( xy_data ) result(IntLonLat_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001889">IntLonLat_xy</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの全領域積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた
総和を計算している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001889-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001889-source">
<pre>
    function IntLonLat_xy(xy_data)
      !
      ! 2 次元緯度経度格子点データの全領域積分(1 層用). 
      !
      ! 実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた
      ! 総和を計算している. 
      !
      real(8), intent(in)   :: xy_data(0:im-1,1:jm)         
      !(in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

      real(8) :: IntLonLat_xy                         
      !(out) 積分値

      IntLonLat_xy = IntLon_x(x_IntLat_xy(xy_data))

    end function IntLonLat_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001886" class="method-detail">
        <a name="M001886"></a>

        <div class="method-heading">


          <a href="#M001886" class="method-signature">



          <span class="method-name">IntLon_x</span><span class="method-args">( x_data ) result(IntLon_x)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001886">IntLon_x</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>x_data(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元経度(X)格子点データの X 方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001886-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001886-source">
<pre>
    function IntLon_x(x_data)
      !
      ! 1 次元経度(X)格子点データの X 方向積分(1 層用).
      !
      ! 実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している.
      !
      real(8), intent(in) :: x_data(0:im-1)   !(in)  1 次元経度(X)格子点データ
      real(8)             :: IntLon_x         !(out) 積分値

      IntLon_x = sum(x_data * x_Lon_weight)

    end function IntLon_x
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001885" class="method-detail">
        <a name="M001885"></a>

        <div class="method-heading">


          <a href="#M001885" class="method-signature">



          <span class="method-name">Interpolate_w</span><span class="method-args">( w_data, alon, alat ) result(Interpolate_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001885">Interpolate_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間した値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>alon  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間する位置(経度)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>alat  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間する位置(緯度)

</td></tr>
</table>
</td></tr>
</table>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001885-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001885-source">
<pre>
    function Interpolate_w(w_data,alon,alat)
      real(8), intent(IN) :: w_data(nm+1)   ! スペクトルデータ
      real(8), intent(IN) :: alon           ! 補間する位置(経度)
      real(8), intent(IN) :: alat           ! 補間する位置(緯度)
      real(8)             :: Interpolate_w  ! 補間した値
      
      Interpolate_w = Interpolate_alat_w(w_data,alat)

    end function Interpolate_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001869" class="method-detail">
        <a name="M001869"></a>

        <div class="method-heading">




          <span class="method-name">irm</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001869">irm</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, allocatable</tt>

</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001898" class="method-detail">
        <a name="M001898"></a>

        <div class="method-heading">


          <a href="#M001898" class="method-signature">



          <span class="method-name">l_nm</span><span class="method-args">( n, m ) result(l_nm_array00)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array00  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>n  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>m  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m,ダミー)からそのスペクトルデータの格納位置を返す.
</p>
<p>
引数 n,m がともに整数値の場合, 整数値を返す.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001898-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001898-source">
<pre>
    function l_nm_array00(n,m)
      !
      ! 全波数(n)と東西波数(m,ダミー)からそのスペクトルデータの格納位置を返す.
      ! 
      ! 引数 n,m がともに整数値の場合, 整数値を返す. 
      !
      integer               :: l_nm_array00   
      !(out) スペクトルデータの格納位置 

      integer, intent(in)   :: n     !(in) 全波数
      integer, intent(in)   :: m     !(in) 帯状波数           

      if ( m /= 0 ) then
         call MessageNotify('E','l_nm_array00', 'zonal wavenumber should be zero in w_zonal_module')
      end if

      l_nm_array00 = n+1

    end function l_nm_array00
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001899" class="method-detail">
        <a name="M001899"></a>

        <div class="method-heading">


          <a href="#M001899" class="method-signature">



          <span class="method-name">l_nm</span><span class="method-args">( n, marray ) result(l_nm_array01)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array01(size(marray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>n  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>marray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置
</p>
<p>
全波数(n)と東西波数(m, ダミー)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1 引数 n が整数, 第 2 引数 marray が整数 1 次元配列の場合, marray
と同じ大きさの 1 次元整数配列を返す.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001899-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001899-source">
<pre>
    function l_nm_array01(n,marray)           ! スペクトルデータの格納位置 
      !
      ! 全波数(n)と東西波数(m, ダミー)からそのスペクトルデータの格納位置を返す.
      ! 
      ! 第 1 引数 n が整数, 第 2 引数 marray が整数 1 次元配列の場合, 
      ! marray と同じ大きさの 1 次元整数配列を返す. 
      !
      integer, intent(in)  :: n               !(in) 全波数
      integer, intent(in)  :: marray(:)       !(in) 帯状波数
      integer              :: l_nm_array01(size(marray))
      !(out) スペクトルデータ位置

      integer              :: i 

      do i=1, size(marray)
         l_nm_array01(i) = l_nm_array00(n,marray(i))
      enddo
    end function l_nm_array01
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001900" class="method-detail">
        <a name="M001900"></a>

        <div class="method-heading">


          <a href="#M001900" class="method-signature">



          <span class="method-name">l_nm</span><span class="method-args">( narray, m ) result(l_nm_array10)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array10(size(narray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>narray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>m  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m,ダミー)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1 引数 narray が整数 1 次元配列, 第 2 引数 m が整数の場合, narray
と同じ大きさの 1 次元整数配列を返す.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001900-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001900-source">
<pre>
    function l_nm_array10(narray,m)
      !
      ! 全波数(n)と東西波数(m,ダミー)からそのスペクトルデータの格納位置を返す.
      ! 
      ! 第 1 引数 narray が整数 1 次元配列, 第 2 引数  m が整数の場合, 
      ! narray と同じ大きさの 1 次元整数配列を返す. 
      !
      integer, intent(in)  :: narray(:)           !(in) 全波数  
      integer, intent(in)  :: m                   !(in) 帯状波数
      integer              :: l_nm_array10(size(narray))
      !(out) スペクトルデータ位置

      integer              :: i 

      do i=1, size(narray)
         l_nm_array10(i) = l_nm_array00(narray(i),m)
      enddo
    end function l_nm_array10
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001901" class="method-detail">
        <a name="M001901"></a>

        <div class="method-heading">


          <a href="#M001901" class="method-signature">



          <span class="method-name">l_nm</span><span class="method-args">( narray, marray ) result(l_nm_array11)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array11(size(narray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>narray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>marray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1,2 引数 narray, marray がともに整数 1 次元配列の場合, narray, marray
と同じ大きさの 1 次元整数配列を返す. narray, marray
は同じ大きさでなければならない.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001901-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001901-source">
<pre>
    function l_nm_array11(narray,marray)
      !
      ! 全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
      ! 
      ! 第 1,2 引数 narray, marray がともに整数 1 次元配列の場合, 
      ! narray, marray と同じ大きさの 1 次元整数配列を返す. 
      ! narray, marray は同じ大きさでなければならない. 
      !
      integer, intent(in)  :: narray(:)          !(in) 全波数  
      integer, intent(in)  :: marray(:)          !(in) 帯状波数
      integer              :: l_nm_array11(size(narray))
      !(out) スペクトルデータ位置

      integer              :: i 

      if ( size(narray) .ne. size(marray) ) then
         call MessageNotify('E','l_nm_array11', 'dimensions of input arrays  n and m are different.')
      endif

      do i=1, size(narray)
         l_nm_array11(i) = l_nm_array00(narray(i),marray(i))
      enddo
    end function l_nm_array11
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001895" class="method-detail">
        <a name="M001895"></a>

        <div class="method-heading">


          <a href="#M001895" class="method-signature">



          <span class="method-name">n_EnergyFromStreamfunc_w</span><span class="method-args">( w_Strfunc ) result(n_EnergyFromStreamfunc_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001895">n_EnergyFromStreamfunc_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトル (水平全波数 n 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_Strfunc(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータから各全波数のエネルギー成分(スペクトル)を
計算する(1 層用).
</p>
<pre>
 * 全波数 n の流線関数のスペクトル成分ψ(n,m) から
   エネルギースペクトルはΣ[m=-nm]^nm(1/2)n(n+1)ψ(n,m)^2
   と計算される.

 * 全てのエネルギースペクトル成分の和に 4πをかけたものが
   球面上での全エネルギーに等しい.
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001895-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001895-source">
<pre>
    function n_EnergyFromStreamfunc_w(w_Strfunc)
      !
      ! 流線関数のスペクトルデータから各全波数のエネルギー成分(スペクトル)を
      ! 計算する(1 層用).
      !
      !  * 全波数 n の流線関数のスペクトル成分ψ(n,m) から
      !    エネルギースペクトルはΣ[m=-nm]^nm(1/2)n(n+1)ψ(n,m)^2 
      !    と計算される.
      !
      !  * 全てのエネルギースペクトル成分の和に 4πをかけたものが
      !    球面上での全エネルギーに等しい.
      !

      real(8), intent(in)      :: w_Strfunc(:)
      !(in) 流線関数(スペクトルデータ)

      real(8), dimension(0:nm) :: n_EnergyFromStreamfunc_w
      !(out) エネルギースペクトル (水平全波数 n 空間) 

      integer :: n

      do n=0,nm
         n_EnergyFromStreamfunc_w(n) = 0.5 * n*(n+1) * w_StrFunc(l_nm(n,0))**2
      enddo

    end function n_EnergyFromStreamfunc_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001897" class="method-detail">
        <a name="M001897"></a>

        <div class="method-heading">


          <a href="#M001897" class="method-signature">



          <span class="method-name">n_EnstrophyFromStreamfunc_w</span><span class="method-args">( w_Strfunc ) result(n_EnstrophyFromStreamfunc_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001897">n_EnstrophyFromStreamfunc_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エンストロフィースペクトル(水平全波数 n 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_Strfunc(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータから各全波数のエネルギー成分(スペクトル)を
計算する(1 層用)
</p>
<ul>
<li>全波数 n の流線関数のスペクトル成分ψ(n,m) からエンストロフィー
スペクトルはΣ[m=-nm]^nm(1/2)n^2(n+1)^2ψ(n,m)^2 と計算される.

</li>
<li>全てのエネルギースペクトル成分の和に 4π/R^2 をかけたものが
球面上での全エンストフィーに等しい.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001897-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001897-source">
<pre>
    function n_EnstrophyFromStreamfunc_w(w_Strfunc)
      !
      ! 流線関数のスペクトルデータから各全波数のエネルギー成分(スペクトル)を
      ! 計算する(1 層用)
      !
      ! * 全波数 n の流線関数のスペクトル成分ψ(n,m) からエンストロフィー
      !   スペクトルはΣ[m=-nm]^nm(1/2)n^2(n+1)^2ψ(n,m)^2 と計算される.
      !    
      ! * 全てのエネルギースペクトル成分の和に 4π/R^2 をかけたものが
      !   球面上での全エンストフィーに等しい.
      !
      real(8), intent(in)      :: w_Strfunc(:)
      !(in) 流線関数(スペクトルデータ)

      real(8), dimension(0:nm) :: n_EnstrophyFromStreamfunc_w  
      !(out) エンストロフィースペクトル(水平全波数 n 空間)

      integer :: n

      do n=0,nm
         n_EnstrophyFromStreamfunc_w(n) = 0.5 * n**2 * (n+1)**2 * w_StrFunc(l_nm(n,0))**2
      enddo
    end function n_EnstrophyFromStreamfunc_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001894" class="method-detail">
        <a name="M001894"></a>

        <div class="method-heading">


          <a href="#M001894" class="method-signature">



          <span class="method-name">nm_EnergyFromStreamfunc_w</span><span class="method-args">( w_Strfunc ) result(nm_EnergyFromStreamfunc_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001894">nm_EnergyFromStreamfunc_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,-nm:nm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトル(水平全波数 n, 帯状波数 m 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_Strfunc(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータからエネルギーの球面調和函数成分
(スペクトル)を計算する(1 層用).
</p>
<pre>
 * 全波数 n, 帯状波数 m の流線関数のスペクトル成分ψ(n,m) から
   エネルギースペクトルは (1/2)n(n+1)ψ(n,m)^2 と計算される.

 * 全てのエネルギースペクトル成分の和に4πをかけたものが球面上での
   全エネルギーに等しい.

 * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
   欠損値の値はモジュール変数 w_spectrum_VMiss によって設定できる
   (初期値は -999.0)
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001894-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001894-source">
<pre>
    function nm_EnergyFromStreamfunc_w(w_Strfunc)
      ! 
      ! 流線関数のスペクトルデータからエネルギーの球面調和函数成分
      ! (スペクトル)を計算する(1 層用).
      !
      !  * 全波数 n, 帯状波数 m の流線関数のスペクトル成分ψ(n,m) から
      !    エネルギースペクトルは (1/2)n(n+1)ψ(n,m)^2 と計算される.
      !
      !  * 全てのエネルギースペクトル成分の和に4πをかけたものが球面上での
      !    全エネルギーに等しい.
      !
      !  * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
      !    欠損値の値はモジュール変数 w_spectrum_VMiss によって設定できる
      !    (初期値は -999.0)
      !
      real(8), intent(in)   :: w_Strfunc(:)
      !(in) 流線関数(スペクトルデータ)

      real(8), dimension(0:nm,-nm:nm) :: nm_EnergyFromStreamfunc_w
      !(out) エネルギースペクトル(水平全波数 n, 帯状波数 m 空間)

      integer :: n, m

      nm_EnergyFromStreamfunc_w = w_spectrum_VMiss

      do n=0,nm
         do m=1,n
            nm_EnergyFromStreamfunc_w(n,m)  = 0.0D0
            nm_EnergyFromStreamfunc_w(n,-m) = 0.0D0
         enddo
         nm_EnergyFromStreamfunc_w(n,0) = 0.5 * n*(n+1) * w_Strfunc(l_nm(n,0))**2
      enddo
    end function nm_EnergyFromStreamfunc_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001896" class="method-detail">
        <a name="M001896"></a>

        <div class="method-heading">


          <a href="#M001896" class="method-signature">



          <span class="method-name">nm_EnstrophyFromStreamfunc_w</span><span class="method-args">( w_Strfunc ) result(nm_EnstrophyFromStreamfunc_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001896">nm_EnstrophyFromStreamfunc_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,-nm:nm)</tt>

<table>
<tr><td valign="top"> :</td><td> エンストロフィースペクトル (水平全波数 n, 帯状波数 m 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_Strfunc(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータからエンストロフィーの球面調和函数成分
(スペクトル)を計算する(1 層用).
</p>
<ul>
<li>全波数 n, 帯状波数 m の流線関数のスペクトル成分ψ(n,m) から

<pre>
 エンストロフィースペクトルは (1/2)n^2(n+1)^2ψ(n,m)^2 と計算される.
</pre>
</li>
<li>全てのエンストロフィースペクトル成分の和に4π/R^2をかけたものが
球面上での全エンストロフィーに等しい. ここで R は球面の半径である.

</li>
<li>データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
欠損値の値はモジュール変数 <a
href="w_zonal_module.html#M001870">w_spectrum_VMiss</a> によって設定できる
(初期値は -999.0)

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001896-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001896-source">
<pre>
    function nm_EnstrophyFromStreamfunc_w(w_Strfunc)
      !
      ! 流線関数のスペクトルデータからエンストロフィーの球面調和函数成分
      ! (スペクトル)を計算する(1 層用). 
      !
      ! * 全波数 n, 帯状波数 m の流線関数のスペクトル成分ψ(n,m) から
      !    エンストロフィースペクトルは (1/2)n^2(n+1)^2ψ(n,m)^2 と計算される.
      !
      ! * 全てのエンストロフィースペクトル成分の和に4π/R^2をかけたものが
      !   球面上での全エンストロフィーに等しい. ここで R は球面の半径である.
      !
      ! * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
      !   欠損値の値はモジュール変数 w_spectrum_VMiss によって設定できる
      !   (初期値は -999.0)
      !
      real(8), intent(in)   :: w_Strfunc(:)
      !(in) 流線関数(スペクトルデータ)

      real(8), dimension(0:nm,-nm:nm) :: nm_EnstrophyFromStreamfunc_w
      ! エンストロフィースペクトル (水平全波数 n, 帯状波数 m 空間)

      integer :: n, m

      nm_EnstrophyFromStreamfunc_w = w_spectrum_VMiss

      do n=0,nm
         do m=1,n
            nm_EnstrophyFromStreamfunc_w(n,m) = 0.0
            nm_EnstrophyFromStreamfunc_w(n,-m) = 0.0
         enddo
         nm_EnstrophyFromStreamfunc_w(n,0) = 0.5 * n**2 * (n+1)**2 * w_Strfunc(l_nm(n,0))**2
      enddo

    end function nm_EnstrophyFromStreamfunc_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001902" class="method-detail">
        <a name="M001902"></a>

        <div class="method-heading">


          <a href="#M001902" class="method-signature">



          <span class="method-name">nm_l</span><span class="method-args">( l ) result(nm_l_int)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>nm_l_int(2)  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全波数, 帯状波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>l  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置(l)から全波数(n)と東西波数(m)を返す.
</p>
<p>
引数 l が整数値の場合, 対応する全波数と帯状波数を 長さ 2 の 1
次元整数値を返す. <a href="w_zonal_module.html#M001902">nm_l</a>(1)
が全波数, <a href="w_zonal_module.html#M001902">nm_l</a>(2)
が帯状波数である.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001902-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001902-source">
<pre>
    function nm_l_int(l)
      ! 
      ! スペクトルデータの格納位置(l)から全波数(n)と東西波数(m)を返す.
      !
      ! 引数 l が整数値の場合, 対応する全波数と帯状波数を
      ! 長さ 2 の 1 次元整数値を返す. 
      ! nm_l(1) が全波数, nm_l(2) が帯状波数である. 
      !
      integer               :: nm_l_int(2)  !(out) 全波数, 帯状波数
      integer, intent(in)   :: l            !(in) スペクトルデータの格納位置
      
      nm_l_int(1) = l-1
      nm_l_int(2) = 0
    end function nm_l_int
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001903" class="method-detail">
        <a name="M001903"></a>

        <div class="method-heading">


          <a href="#M001903" class="method-signature">



          <span class="method-name">nm_l</span><span class="method-args">( larray ) result(nm_l_array)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>nm_l_array(size(larray),2)  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>larray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全波数, 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置(l)から全波数(n)と東西波数(m)を返す.
</p>
<p>
引数 larray が整数 1 次元配列の場合, larray に対応する n, m を格納した 2
次元整数配列を返す. nm_l_array(:,1) が全波数, nm_l_array(:,2)
が帯状波数である.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001903-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001903-source">
<pre>
    function nm_l_array(larray)
      ! 
      ! スペクトルデータの格納位置(l)から全波数(n)と東西波数(m)を返す.
      !
      ! 引数 larray が整数 1 次元配列の場合, 
      ! larray に対応する n, m を格納した 2 次元整数配列を返す. 
      ! nm_l_array(:,1) が全波数, nm_l_array(:,2) が帯状波数である. 
      !
      integer, intent(in)  :: larray(:)
      !(out) 全波数, 帯状波数

      integer              :: nm_l_array(size(larray),2)
      !(in) スペクトルデータの格納位置

      integer              :: i

      do i=1, size(larray)
         nm_l_array(i,:) = nm_l_int(larray(i))
      enddo
    end function nm_l_array
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001868" class="method-detail">
        <a name="M001868"></a>

        <div class="method-heading">




          <span class="method-name">rn</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001868">rn</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001874" class="method-detail">
        <a name="M001874"></a>

        <div class="method-heading">


          <a href="#M001874" class="method-signature">



          <span class="method-name">w_DLon_w</span><span class="method-args">( w_data ) result(w_DLon_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001874">w_DLon_w</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの経度微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに経度微分 ∂/∂λ を作用させる(1 層用).
</p>
<p>
スペクトルデータの経度微分とは, 対応する格子点データに
経度微分∂/∂λを作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001874-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001874-source">
<pre>
    function w_DLon_w(w_data)
      !
      ! スペクトルデータに経度微分 ∂/∂λ を作用させる(1 層用).
      !
      ! スペクトルデータの経度微分とは, 対応する格子点データに
      ! 経度微分∂/∂λを作用させたデータのスペクトル変換のことである.
      ! 
      real(8)              :: w_DLon_w(nm+1)
      !(out) スペクトルデータの経度微分

      real(8), intent(in)  :: w_data(nm+1)
      !(in) 入力スペクトルデータ

      w_DLon_w = 0.0D0

    end function w_DLon_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001883" class="method-detail">
        <a name="M001883"></a>

        <div class="method-heading">


          <a href="#M001883" class="method-signature">



          <span class="method-name">w_DivLambda_xy</span><span class="method-args">( xy_data ) result(w_DivLambda_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001883">w_DivLambda_xy</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型経度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型経度微分 1/(1-μ^2)・∂/∂λ (μ=sinφ)
を作用させてスペクトルデータに変換して返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001883-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001883-source">
<pre>
    function w_DivLambda_xy(xy_data)
      !
      ! 格子点データに発散型経度微分 1/(1-μ^2)・∂/∂λ (μ=sinφ) 
      ! を作用させてスペクトルデータに変換して返す(1 層用).
      !
      real(8)              :: w_DivLambda_xy(nm+1)
      !(out) 格子点データを発散型経度微分したスペクトルデータ

      real(8), intent(in)  :: xy_data(0:im-1,1:jm)
      !(in) 入力格子点データ

      w_DivLambda_xy = w_xy(xy_data,ipow=2,iflag=-1)

    end function w_DivLambda_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001878" class="method-detail">
        <a name="M001878"></a>

        <div class="method-heading">


          <a href="#M001878" class="method-signature">



          <span class="method-name">w_DivLat_xy</span><span class="method-args">( xy_data ) result(w_DivLat_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001878">w_DivLat_xy</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型緯度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型緯度微分 1/cosφ・∂(f cosφ)/∂φ を作用させて
スペクトルデータに変換して返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001878-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001878-source">
<pre>
    function w_DivLat_xy(xy_data)
      !
      ! 格子点データに発散型緯度微分 1/cosφ・∂(f cosφ)/∂φ を作用させて
      ! スペクトルデータに変換して返す(1 層用).
      !
      real(8)              :: w_DivLat_xy(nm+1)
      !(out) 格子点データを発散型緯度微分したスペクトルデータ

      real(8), intent(in)  :: xy_data(0:im-1,1:jm)
      !(in) 入力格子点データ

      w_DivLat_xy = w_xy(xy_data,ipow=1,iflag=1)

    end function w_DivLat_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001877" class="method-detail">
        <a name="M001877"></a>

        <div class="method-heading">


          <a href="#M001877" class="method-signature">



          <span class="method-name">w_DivLon_xy</span><span class="method-args">( xy_data ) result(w_DivLon_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001877">w_DivLon_xy</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型経度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型経度微分 1/cosφ・∂/∂λ を作用させて
スペクトルデータに変換して返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001877-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001877-source">
<pre>
    function w_DivLon_xy(xy_data)
      !
      ! 格子点データに発散型経度微分 1/cosφ・∂/∂λ を作用させて
      ! スペクトルデータに変換して返す(1 層用).
      !
      real(8)              :: w_DivLon_xy(nm+1)
      !(out) 格子点データを発散型経度微分したスペクトルデータ
      real(8), intent(in)  :: xy_data(0:im-1,1:jm)
      !(in) 入力格子点データ

      w_DivLon_xy = w_xy(xy_data,ipow=1,iflag=-1)

    end function w_DivLon_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001884" class="method-detail">
        <a name="M001884"></a>

        <div class="method-heading">


          <a href="#M001884" class="method-signature">



          <span class="method-name">w_DivMu_xy</span><span class="method-args">( xy_data ) result(w_DivMu_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001884">w_DivMu_xy</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型緯度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型緯度微分 ∂/∂μ (μ=sinφ)を作用させて
スペクトルデータに変換して返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001884-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001884-source">
<pre>
    function w_DivMu_xy(xy_data)
      !
      ! 格子点データに発散型緯度微分 ∂/∂μ (μ=sinφ)を作用させて
      ! スペクトルデータに変換して返す(1 層用).
      !
      real(8)              :: w_DivMu_xy(nm+1)
      !(out) 格子点データを発散型緯度微分したスペクトルデータ

      real(8), intent(in)  :: xy_data(0:im-1,1:jm)
      !(in) 入力格子点データ

      w_DivMu_xy = w_xy(xy_data,ipow=2,iflag=1)

    end function w_DivMu_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001879" class="method-detail">
        <a name="M001879"></a>

        <div class="method-heading">


          <a href="#M001879" class="method-signature">



          <span class="method-name">w_Div_xy_xy</span><span class="method-args">( xy_u, xy_v ) result(w_Div_xy_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001879">w_Div_xy_xy</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 つの入力格子点データをベクトル成分とする発散のスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_u(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル経度成分の格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_v(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル緯度成分の格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 つの入力格子点データをベクトル成分とする発散を計算し,
スペクトルデータとして返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001879-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001879-source">
<pre>
    function w_Div_xy_xy(xy_u,xy_v)
      !
      ! 2 つの入力格子点データをベクトル成分とする発散を計算し, 
      ! スペクトルデータとして返す(1 層用).
      !
      real(8)              :: w_Div_xy_xy(nm+1)
      !(out) 2 つの入力格子点データをベクトル成分とする発散のスペクトルデータ

      real(8), intent(in)  :: xy_u(0:im-1,1:jm)
      !(in) ベクトル経度成分の格子点データ

      real(8), intent(in)  :: xy_v(0:im-1,1:jm)
      !(in) ベクトル緯度成分の格子点データ

      w_Div_xy_xy = w_Divlon_xy(xy_u) + w_Divlat_xy(xy_v)

    end function w_Div_xy_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001880" class="method-detail">
        <a name="M001880"></a>

        <div class="method-heading">


          <a href="#M001880" class="method-signature">



          <span class="method-name">w_Jacobian_w_w</span><span class="method-args">( w_a, w_b ) result(w_Jacobian_w_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001880">w_Jacobian_w_w</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 つのスペクトルデータのヤコビアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_a((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1つ目の入力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_b((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2つ目の入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 つのスペクトルデータにヤコビアン
</p>
<pre>
  J(f,g) = ∂f/∂λ・∂g/∂μ - ∂g/∂λ・∂f/∂μ
         = ∂f/∂λ・1/cosφ・∂g/∂φ
            - ∂g/∂λ・1/cosφ・∂f/∂φ
</pre>
<p>
を作用させる(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001880-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001880-source">
<pre>
    function w_Jacobian_w_w(w_a,w_b)
      ! 2 つのスペクトルデータにヤコビアン
      !
      !   J(f,g) = ∂f/∂λ・∂g/∂μ - ∂g/∂λ・∂f/∂μ
      !          = ∂f/∂λ・1/cosφ・∂g/∂φ
      !             - ∂g/∂λ・1/cosφ・∂f/∂φ
      !
      ! を作用させる(1 層用).

      real(8)             :: w_Jacobian_w_w(nm+1)
      !(out) 2 つのスペクトルデータのヤコビアン

      real(8), intent(in) :: w_a((nm+1)*(nm+1))
      !(in) 1つ目の入力スペクトルデータ
      
      real(8), intent(in) :: w_b((nm+1)*(nm+1))
      !(in) 2つ目の入力スペクトルデータ

      w_Jacobian_w_w = 0.0D0      

    end function w_Jacobian_w_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001907" class="method-detail">
        <a name="M001907"></a>

        <div class="method-heading">




          <span class="method-name">w_LaplaInv_w</span><span class="method-args">( l_data ) result(l_LaplaInv_l)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_LaplaInv_l(0:nm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの逆ラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>l_data(0:nm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに逆ラプラシアン
</p>
<pre>
   ▽^{-2}
     =[1/cosφ・∂/∂φ(cosφ∂/∂φ)]^{-1}
</pre>
<p>
を作用する.
</p>
<p>
スペクトルデータの逆ラプラシアンとは, 対応する格子点データに
逆ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="l_module.html#M000651">l_module#l_LaplaInv_l</a>
</p>


        </div>
      </div>


      <div id="method-M001906" class="method-detail">
        <a name="M001906"></a>

        <div class="method-heading">




          <span class="method-name">w_Lapla_w</span><span class="method-args">( l_data ) result(l_Lapla_l)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_Lapla_l(0:nm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 入力スペクトルデータのラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>l_data(0:nm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータにラプラシアン
</p>
<pre>
   ▽^2 = 1/cosφ・∂/∂φ(cosφ∂/∂φ)
</pre>
<p>
を作用する.
</p>
<p>
スペクトルデータのラプラシアンとは, 対応する格子点データに
ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="l_module.html#M000650">l_module#l_Lapla_l</a>
</p>


        </div>
      </div>


      <div id="method-M001871" class="method-detail">
        <a name="M001871"></a>

        <div class="method-heading">


          <a href="#M001871" class="method-signature">



          <span class="method-name">w_initial</span><span class="method-args">( n_in, i_in, j_in, [np_in] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>n_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 切断波数の設定

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>i_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点数(東西)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>j_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点数(南北)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>np_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) OPENMP での最大スレッド数

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル変換の格子点数, 波数および OPENMP 使用時の
最大スレッド数を設定する.
</p>
<p>
他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで初期設定を
しなければならない.
</p>
<p>
np_in は <a href="w_module.html">w_module</a>
との互換性のためにおいているだけである. OPENMP 計算は実装されていない.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001871-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001871-source">
<pre>
    subroutine w_initial(n_in,i_in,j_in,np_in)
      !
      ! スペクトル変換の格子点数, 波数および OPENMP 使用時の
      ! 最大スレッド数を設定する.
      !
      ! 他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで初期設定を
      ! しなければならない. 
      !
      ! np_in は w_module との互換性のためにおいているだけである. 
      ! OPENMP 計算は実装されていない. 
      !
      integer,intent(in) :: i_in              !(in) 格子点数(東西)
      integer,intent(in) :: j_in              !(in) 格子点数(南北)
      integer,intent(in) :: n_in              !(in) 切断波数の設定
      integer,intent(in), optional :: np_in   !(in) OPENMP での最大スレッド数

      integer :: i, j, n

      if ( present (np_in) )then
         call MessageNotify('W','w_initial','OPENMP calculation not supported')
      endif

      if ( i_in /= 1  )then
         call MessageNotify('W','w_initial','Longitudinal dimension should be 1')
      endif

      im = i_in  
       jm = j_in  
       nm = n_in

      allocate(x_Lon(0:im-1))                ! 格子点座標格納配列(経度)
      allocate(x_Lon_Weight(0:im-1))
      allocate(xy_Lon(0:im-1,1:jm))
      allocate(xy_Lat(0:im-1,1:jm))          ! 格子点座標格納配列

      allocate(rn(0:nm,2),irm(nm+1,2))

      call l_initial(n_in,j_in)

      do i=0,im-1
         x_Lon(i)  = 2*pi/im*i               ! 経度座標
         x_Lon_Weight(i) = 2*pi/im           ! 経度座標重み
      enddo

      do j=1,jm
         xy_Lon(:,j) = x_Lon
      enddo

      do i=0,im-1
         xy_Lat(i,:) = y_Lat
      enddo

      do n=0,nm
         rn(n,1) = -n*(n+1)
      enddo

      rn(0,2) = 1.0D0
      do n=1,nm
         rn(n,2) = -1/(n*(n+1))
      enddo

      do n=1,nm+1
         irm(n,1) = n
         irm(n,2) = 0
      enddo

      call MessageNotify('M','w_initial', 'w_zonal_module (2009/01/08) is initialized')

    end subroutine w_initial
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001870" class="method-detail">
        <a name="M001870"></a>

        <div class="method-heading">




          <span class="method-name">w_spectrum_VMiss</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001870">w_spectrum_VMiss</a>  </tt></b>  <tt> = -999.000    </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 欠損値初期値

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001873" class="method-detail">
        <a name="M001873"></a>

        <div class="method-heading">


          <a href="#M001873" class="method-signature">



          <span class="method-name">w_xy</span><span class="method-args">( xy_data, [ipow], [iflag] ) result(w_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001873">w_xy</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ipow  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 変換時に同時に作用させる 1/cosφ の次数. 省略時は 0.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>iflag  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> 変換の種類

<pre>
   0 : 通常の正変換
   1 : 緯度微分 1/cosφ・∂(f cos^2φ)/∂φ を作用させた正変換
  -1 : 緯度微分を作用させた正変換
   2 : sinφを作用させた正変換
 省略時は 0.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからスペクトルデータへ(正)変換する(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001873-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001873-source">
<pre>
    function w_xy(xy_data,ipow,iflag)
      !
      ! 格子データからスペクトルデータへ(正)変換する(1 層用).
      !
      real(8)               :: w_xy(nm+1)
      !(out) スペクトルデータ

      real(8), intent(in)   :: xy_data(0:im-1,1:jm)
      !(in) 格子点データ

      integer, intent(in), optional  :: ipow
      !(in) 変換時に同時に作用させる 1/cosφ の次数. 省略時は 0.

      integer, intent(in), optional  :: iflag
      ! 変換の種類
      !    0 : 通常の正変換
      !    1 : 緯度微分 1/cosφ・∂(f cos^2φ)/∂φ を作用させた正変換
      !   -1 : 緯度微分を作用させた正変換
      !    2 : sinφを作用させた正変換
      !  省略時は 0.


      integer, parameter  :: ipow_default  = 0    ! スイッチデフォルト値
      integer, parameter  :: iflag_default = 0    ! スイッチデフォルト値

      integer ipval, ifval

      real(8)             :: xy_work(0:im-1,1:jm) ! 格子点データ作業配列

      if (present(ipow)) then
         ipval = ipow
      else
         ipval = ipow_default
      endif

      if (present(iflag)) then
         ifval = iflag
      else
         ifval = iflag_default
      endif

      xy_work = xy_data/cos(xy_Lat)**ipval

      if ( ifval == -1 ) then                         ! 経度微分は 0 
         w_xy = 0.0D0        
      else if ( ifval == 1 ) then                     ! 緯度微分
         xy_work = xy_work * cos(xy_Lat)
         w_xy = w_DivLat_y(xy_work(0,:))
      else if ( ifval == 2 ) then                     ! sinφ をかけた正変換
         xy_work = xy_work * sin(xy_Lat)
         w_xy = w_y(xy_work(0,:))
      else
         w_xy = w_y(xy_work(0,:))
      endif
      
    end function w_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001891" class="method-detail">
        <a name="M001891"></a>

        <div class="method-heading">


          <a href="#M001891" class="method-signature">



          <span class="method-name">x_AvrLat_xy</span><span class="method-args">( xy_data ) result(x_AvrLat_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001891">x_AvrLat_xy</a>(im)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの緯度(Y)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, y_Y_Weight
の総和で割ることで平均している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001891-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001891-source">
<pre>
    function x_AvrLat_xy(xy_data)
      !
      ! 2 次元緯度経度格子点データの緯度(Y)方向平均(1 層用).
      !
      ! 実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, 
      ! y_Y_Weight の総和で割ることで平均している. 
      !
      real(8), intent(in) :: xy_data(0:im-1,1:jm)
      !(in) 2 次元経度緯度格子点データ(0:im-1,1:jm)
      real(8)             :: x_AvrLat_xy(im)
      !(out) 平均された 1 次元経度(X)格子点データ

      x_AvrLat_xy = x_IntLat_xy(xy_data)/sum(y_Lat_weight)

    end function x_AvrLat_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001887" class="method-detail">
        <a name="M001887"></a>

        <div class="method-heading">


          <a href="#M001887" class="method-signature">



          <span class="method-name">x_IntLat_xy</span><span class="method-args">( xy_data ) result(x_IntLat_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001887">x_IntLat_xy</a>(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの緯度(Y)方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001887-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001887-source">
<pre>
    function x_IntLat_xy(xy_data)
      !
      ! 2 次元緯度経度格子点データの緯度(Y)方向積分(1 層用).
      !
      ! 実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している. 
      !
      real(8), intent(in) :: xy_data(0:im-1,1:jm)           
      !(in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

      real(8)             :: x_IntLat_xy(0:im-1) 
      !(out) 積分された 1 次元経度(X)格子点データ

      integer :: j

      x_IntLat_xy = 0.0D0
      do j=1,jm
         x_IntLat_xy = x_IntLat_xy + xy_data(:,j) * y_Lat_weight(j)
      enddo

    end function x_IntLat_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001864" class="method-detail">
        <a name="M001864"></a>

        <div class="method-heading">




          <span class="method-name">x_Lon</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001864">x_Lon</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 経度経度

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001865" class="method-detail">
        <a name="M001865"></a>

        <div class="method-heading">




          <span class="method-name">x_Lon_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001865">x_Lon_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標重み

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001881" class="method-detail">
        <a name="M001881"></a>

        <div class="method-heading">


          <a href="#M001881" class="method-signature">



          <span class="method-name">xy_GradLambda_w</span><span class="method-args">( w_data ) result(xy_GradLambda_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001881">xy_GradLambda_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型経度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 ∂/∂λ を作用する(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001881-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001881-source">
<pre>
    function xy_GradLambda_w(w_data)
      !
      ! スペクトルデータに勾配型経度微分 ∂/∂λ を作用する(1 層用).
      !
      real(8)              :: xy_GradLambda_w(0:im-1,1:jm)
      !(out) スペクトルデータを勾配型経度微分した格子点データ

      real(8), intent(in)  :: w_data(nm+1)
      !(in) 入力スペクトルデータ
      
      xy_GradLambda_w = xy_w(w_data,ipow=0,iflag=-1)

    end function xy_GradLambda_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001876" class="method-detail">
        <a name="M001876"></a>

        <div class="method-heading">


          <a href="#M001876" class="method-signature">



          <span class="method-name">xy_GradLat_w</span><span class="method-args">( w_data ) result(xy_GradLat_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001876">xy_GradLat_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型緯度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型緯度微分 ∂/∂φ を作用させて
格子点データに変換して返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001876-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001876-source">
<pre>
    function xy_GradLat_w(w_data)
      !
      ! スペクトルデータに勾配型緯度微分 ∂/∂φ を作用させて
      ! 格子点データに変換して返す(1 層用).
      !
      real(8)              :: xy_GradLat_w(0:im-1,1:jm)
      !(out) スペクトルデータを勾配型緯度微分した格子点データ

      real(8), intent(in)  :: w_data(nm+1)
      !(in) 入力スペクトルデータ

      xy_GradLat_w = xy_w(w_data,ipow=1,iflag=1)

    end function xy_GradLat_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001875" class="method-detail">
        <a name="M001875"></a>

        <div class="method-heading">


          <a href="#M001875" class="method-signature">



          <span class="method-name">xy_GradLon_w</span><span class="method-args">( w_data ) result(xy_GradLon_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001875">xy_GradLon_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型経度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 1/cosφ・∂/∂λ を
作用させた格子点データを返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001875-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001875-source">
<pre>
    function xy_GradLon_w(w_data)
      !
      ! スペクトルデータに勾配型経度微分 1/cosφ・∂/∂λ を
      ! 作用させた格子点データを返す(1 層用).
      !
      real(8)              :: xy_GradLon_w(0:im-1,1:jm)
      !(out) スペクトルデータを勾配型経度微分した格子点データ

      real(8), intent(in)  :: w_data(nm+1)
      !(in) 入力スペクトルデータ

      xy_GradLon_w = xy_w(w_data,ipow=1,iflag=-1)

    end function xy_GradLon_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001882" class="method-detail">
        <a name="M001882"></a>

        <div class="method-heading">


          <a href="#M001882" class="method-signature">



          <span class="method-name">xy_GradMu_w</span><span class="method-args">( w_data ) result(xy_GradMu_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001882">xy_GradMu_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型緯度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型緯度微分 (1-μ^2)∂/∂μ (μ=sinφ)
を作用させて格子点データに変換して返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001882-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001882-source">
<pre>
    function xy_GradMu_w(w_data)
      !
      ! スペクトルデータに勾配型緯度微分 (1-μ^2)∂/∂μ  (μ=sinφ)
      ! を作用させて格子点データに変換して返す(1 層用).
      !
      real(8)              :: xy_GradMu_w(0:im-1,1:jm)
      !(out) スペクトルデータを勾配型緯度微分した格子点データ

      real(8), intent(in)  :: w_data(nm+1)
      !(in) 入力スペクトルデータ

      xy_GradMu_w = xy_w(w_data,ipow=0,iflag=1)

    end function xy_GradMu_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001867" class="method-detail">
        <a name="M001867"></a>

        <div class="method-heading">




          <span class="method-name">xy_Lat</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001867">xy_Lat</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001866" class="method-detail">
        <a name="M001866"></a>

        <div class="method-heading">




          <span class="method-name">xy_Lon</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001866">xy_Lon</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001872" class="method-detail">
        <a name="M001872"></a>

        <div class="method-heading">


          <a href="#M001872" class="method-signature">



          <span class="method-name">xy_w</span><span class="method-args">( w_data, [ipow], [iflag] ) result(xy_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001872">xy_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ipow  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 作用させる 1/cosφ の次数. 省略時は 0.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>iflag  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 変換の種類

<pre>
   0 : 通常の正変換
   1 : 緯度微分 cosφ・∂/∂φ を作用させた逆変換
  -1 : 経度微分を作用させた逆変換
   2 : sinφを作用させた逆変換(非実装)
   省略時は 0.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子データへ変換する(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001872-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001872-source">
<pre>
    function xy_w(w_data,ipow,iflag)
      !
      ! スペクトルデータから格子データへ変換する(1 層用).
      !
      real(8)               :: xy_w(0:im-1,1:jm)
      !(out) 格子点データ

      real(8), intent(in)   :: w_data(nm+1)
      !(in) スペクトルデータ

      integer, intent(in), optional  :: ipow      
      !(in) 作用させる 1/cosφ の次数. 省略時は 0. 

      integer, intent(in), optional  :: iflag
      !(in) 変換の種類
      !    0 : 通常の正変換
      !    1 : 緯度微分 cosφ・∂/∂φ を作用させた逆変換
      !   -1 : 経度微分を作用させた逆変換
      !    2 : sinφを作用させた逆変換(非実装)
      !    省略時は 0.
      !
      integer, parameter  :: ipow_default  = 0
      integer, parameter  :: iflag_default = 0

      integer ipval, ifval, i

      if (present(ipow)) then
         ipval = ipow
      else
         ipval = ipow_default
      endif

      if (present(iflag)) then
         ifval = iflag
      else
         ifval = iflag_default
      endif

      if ( ifval == -1 ) then                          ! 経度微分は 0 
         xy_w = 0.0D0        
      else if ( ifval == 1 ) then                    ! 緯度微分
         do i=0,im-1
            xy_w(i,:) = y_GradLat_w(w_data) * cos(y_Lat)
         enddo
      else if ( ifval == 2 ) then                     ! sinφ をかけた逆変換
         do i=0,im-1
            xy_w(i,:) = y_w(w_data)
         enddo
         xy_w = xy_w * sin(xy_Lat)
      else
         do i=0,im-1
            xy_w(i,:) = y_w(w_data)
         enddo
      endif

      if ( ipval /= 0 ) then
         xy_w = xy_w/cos(xy_Lat)**ipval
      end if

    end function xy_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001892" class="method-detail">
        <a name="M001892"></a>

        <div class="method-heading">


          <a href="#M001892" class="method-signature">



          <span class="method-name">y_AvrLon_xy</span><span class="method-args">( xy_data ) result(y_AvrLon_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001892">y_AvrLon_xy</a>(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元緯度(Y)格子点

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの経度(X)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, x_X_Weight
の総和で割ることで平均している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001892-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001892-source">
<pre>
    function y_AvrLon_xy(xy_data)
      !
      ! 2 次元緯度経度格子点データの経度(X)方向平均(1 層用).
      !
      ! 実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, 
      ! x_X_Weight の総和で割ることで平均している. 
      !
      real(8), intent(in) :: xy_data(0:im-1,1:jm)
      !(in) 2 次元経度緯度格子点データ(0:im-1,1:jm)
      real(8)             :: y_AvrLon_xy(1:jm)
      !(out) 平均された 1 次元緯度(Y)格子点

      y_AvrLon_xy = y_IntLon_xy(xy_data)/sum(x_Lon_weight)

    end function y_AvrLon_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001888" class="method-detail">
        <a name="M001888"></a>

        <div class="method-heading">


          <a href="#M001888" class="method-signature">



          <span class="method-name">y_IntLon_xy</span><span class="method-args">( xy_data ) result(y_IntLon_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001888">y_IntLon_xy</a>(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元緯度(Y)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの経度(X)方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001888-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001888-source">
<pre>
    function y_IntLon_xy(xy_data)
      !
      ! 2 次元緯度経度格子点データの経度(X)方向積分(1 層用).
      !
      ! 実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している. 
      !
      real(8), intent(in) :: xy_data(0:im-1,1:jm)
      !(in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

      real(8)             :: y_IntLon_xy(1:jm)
      !(out) 積分された 1 次元緯度(Y)格子点データ

      integer :: i

      y_IntLon_xy = 0.0D0
      do i=0,im-1
         y_IntLon_xy = y_IntLon_xy + xy_data(i,:) * x_Lon_weight(i)
      enddo

    end function y_IntLon_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001904" class="method-detail">
        <a name="M001904"></a>

        <div class="method-heading">




          <span class="method-name">y_Lat</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001904">y_Lat</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 緯度経度

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="l_module.html#M000645">l_module#y_Lat</a>
</p>


        </div>
      </div>


      <div id="method-M001905" class="method-detail">
        <a name="M001905"></a>

        <div class="method-heading">




          <span class="method-name">y_Lat_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_zonal_module.html#M001905">y_Lat_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標重み

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="l_module.html#M000646">l_module#y_Lat_Weight</a>
</p>


        </div>
      </div>



    </div>



  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
