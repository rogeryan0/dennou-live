<?xml version="1.0" encoding="euc-jp"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: wq_module</title>
  <meta http-equiv="Content-Type" content="text/html; charset=euc-jp" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">wq_module</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../files/src/wq_module_f90.html">

                src/wq_module.f90

                </a>


        <br />
            </td>
        </tr>


        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">


  <div id="contextContent">



    <div id="description">
      <h1><a href="wq_module.html">wq_module</a></h1>
<table>
<tr><td valign="top">Authors:</td><td>Shin-ichi Takehiro, Youhei SASAKI

</td></tr>
<tr><td valign="top">Version:</td><td>$Id: <a href="../files/src/wq_module_f90.html">wq_module.f90</a>,v 1.8
2009-02-28 21:33:48 uwabami Exp $

</td></tr>
<tr><td valign="top">Copyright&amp;License:</td><td>See <a href="../../COPYRIGHT">COPYRIGHT</a>

</td></tr>
</table>
<h2>概要</h2>
<p>
spml/wq_module モジュールは球内での流体運動をスペクトル法によって
数値計算するための Fortran90 関数を提供するものである.
</p>
<p>
水平方向に球面調和函数変換および動径方向に Matsushima and Marcus (1994)
で提唱された多項式を用いた スペクトル計算のためのさまざまな関数を提供する.
</p>
<p>
内部で <a href="wa_module.html">wa_module</a>, <a
href="aq_module.html">aq_module</a> を用いている.
最下部では球面調和変換のエンジンとして ISPACK の Fortran77
サブルーチンを用いている.
</p>
<h2>関数・変数の名前と型について</h2>
<h3>命名法</h3>
<ul>
<li>関数名の先頭 (wq_, nmr_, nr_, xyr_, wr_, w_, xy_, x_, y_, r_, a_) は,
返す値の形を示している.

<table>
<tr><td valign="top">wq_  :</td><td>スペクトルデータ(球面調和函数・チェビシェフ変換)

</td></tr>
<tr><td valign="top">nmr_ :</td><td>水平スペクトルデータ(全波数 n, 帯状波数各成分, 動径)

</td></tr>
<tr><td valign="top">nr_  :</td><td>水平スペクトルデータ(全波数 n, 動径)

</td></tr>
<tr><td valign="top">xyr_ :</td><td>3 次元格子点データ(経度・緯度・動径)

</td></tr>
<tr><td valign="top">wr_  :</td><td>水平スペクトル, 動径格子点データ

</td></tr>
</table>
</li>
<li>関数名の間の文字列(DLon, GradLat, GradLat, DivLon, DivLat, Lapla,..) は,
その関数の作用を表している.

</li>
<li>関数名の最後 (wq_, xyz_, wr_, w_, xy_, x_, y_, r_, a_) は, 入力変数の
形がスペクトルデータおよび格子点データであることを示している.

<table>
<tr><td valign="top">_wq      :</td><td>スペクトルデータ

</td></tr>
<tr><td valign="top">_xyr     :</td><td>3 次元格子点データ

</td></tr>
<tr><td valign="top">_xyr_xyr :</td><td>2 つの3 次元格子点データ, &#8230;

</td></tr>
</table>
</li>
</ul>
<h3>各データの種類の説明</h3>
<ul>
<li>xyr : 3 次元格子点データ(経度・緯度・動径)

<ul>
<li>変数の種類と次元は real(8), dimension(0:im-1,1:jm,km).

</li>
<li>im, jm, km はそれぞれ経度, 緯度, 動径座標の格子点数であり, サブルーチン <a
href="wq_module.html#M002015">wq_Initial</a> にてあらかじめ設定しておく.

</li>
</ul>
</li>
<li>wq : スペクトルデータ

<ul>
<li>変数の種類と次元は real(8), dimension((nm+1)*(nm+1),0:lm).

</li>
<li>nm は球面調和函数の最大全波数, lm はチェビシェフ多項式の最大次数 であり,
サブルーチン <a href="wq_module.html#M002015">wq_Initial</a>
にてあらかじめ設定しておく.

</li>
<li>水平スペクトルデータの格納のされ方は関数 <a
href="wq_module.html#M002098">l_nm</a>, <a
href="wq_module.html#M002102">nm_l</a> によって調べる ことができる.

</li>
<li>動径スペクトルデータの格納方法については <a
href="../files/src/aq_module_f90.html">aq_module.f90</a> を 参照のこと.

</li>
</ul>
</li>
<li>nmr : 水平スペクトルデータの並んだ 3 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(0:nm,-nm:nm,km).

</li>
<li>第 1 次元が水平全波数, 第 2 次元が帯状波数, 第 3 次元が動径座標を表す.

</li>
<li>nm は球面調和函数の最大全波数であり, サブルーチン <a
href="wq_module.html#M002015">wq_Initial</a> にて あらかじめ設定しておく.

</li>
</ul>
</li>
<li>nr : スペクトルデータの並んだ 2 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(0:nm,km).

</li>
<li>第 1 次元が水平全波数を表す. nm は球面調和函数の最大全波数であり,
サブルーチン <a href="wq_module.html#M002015">wq_Initial</a>
にてあらかじめ設定しておく.

</li>
</ul>
</li>
<li>wr : 水平スペクトル, 動径格子点データ.

<ul>
<li>変数の種類と次元は real(8), dimension((nm+1)*(nm+1),km).

</li>
</ul>
</li>
<li>wq_ で始まる関数が返す値はスペクトルデータに同じ.

</li>
<li>xyr_ で始まる関数が返す値は 3 次元格子点データに同じ.

</li>
<li>wr_ で始まる関数が返す値は水平スペクトル, 動径格子点データに同じ.

</li>
<li>スペクトルデータに対する微分等の作用とは, 対応する格子点データに
微分などを作用させたデータをスペクトル変換したものことである.

</li>
</ul>
<h2>変数・手続き群の要約</h2>
<h4>初期化</h4>
<table>
<tr><td valign="top"><a href="wq_module.html#M002015">wq_Initial</a> :</td><td>スペクトル変換の格子点数, 波数, 領域の大きさの設定

</td></tr>
</table>
<h4>座標変数</h4>
<table>
<tr><td valign="top"><a href="wq_module.html#M002092">x_Lon</a>, <a href="wq_module.html#M002094">y_Lat</a>, <a href="wq_module.html#M002096">r_Rad</a>          :</td><td>格子点座標(緯度, 経度, 動径座標)を 格納した1 次元配列

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002093">x_Lon_Weight</a>, <a href="wq_module.html#M002095">y_Lat_Weight</a>, <a href="wq_module.html#M002097">r_Rad_Weight</a> :</td><td>重み座標を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002010">xyr_Lon</a>, <a href="wq_module.html#M002011">xyr_Lat</a>, <a href="wq_module.html#M002012">xyr_Rad</a>    :</td><td>格子点データの経度・緯度・動径座標(X,Y,Z) (格子点データ型 3 次元配列)

</td></tr>
</table>
<h4>基本変換</h4>
<table>
<tr><td valign="top"><a href="wq_module.html#M002016">xyr_wq</a>, <a href="wq_module.html#M002017">wq_xyr</a> :</td><td>スペクトルデータと 3 次元格子データの間の変換 (球面調和函数,
チェビシェフ変換)

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002018">xyr_wr</a>, <a href="wq_module.html#M002019">wr_xyr</a> :</td><td>3 次元格子データと水平スペクトル・動径格子データとの 間の変換
(球面調和函数)

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002020">wr_wq</a>, <a href="wq_module.html#M002021">wq_wr</a>   :</td><td>スペクトルデータと水平スペクトル・動径格子データとの 間の変換
(チェビシェフ変換)

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002106">w_xy</a>, <a href="wq_module.html#M002107">xy_w</a>     :</td><td>スペクトルデータと 2 次元水平格子データの 間の変換(球面調和函数変換)

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002098">l_nm</a>, <a href="wq_module.html#M002102">nm_l</a>     :</td><td>スペクトルデータの格納位置と全波数・帯状波数の変換

</td></tr>
</table>
<h4>微分</h4>
<table>
<tr><td valign="top"><a href="wq_module.html#M002108">wq_RadDRad_wq</a>       :</td><td>スペクトルデータに動径微分 r∂/∂r を作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002022">wr_DivRad_wq</a>        :</td><td>スペクトルデータに発散型動径微分 1/r^2 ∂/∂r r^2 = ∂/∂r + 2/r
を作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002023">wr_RotDRad_wq</a>       :</td><td>スペクトルデータに回転型動径微分 1/r ∂/∂rr = ∂/∂r + 1/r を作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002024">wr_RotDRad_wr</a>       :</td><td>スペクトルデータに回転型動径微分 1/r ∂/∂rr = ∂/∂r + 1/r を作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002025">wq_RotDRad_wr</a>       :</td><td>スペクトルデータに回転型動径微分 1/r ∂/∂rr = ∂/∂r + 1/r を作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002026">wq_Lapla_wq</a>         :</td><td>スペクトルデータにラプラシアンを作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002027">xyr_GradLon_wq</a>      :</td><td>スペクトルデータに勾配型経度微分 1/rcosφ・∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002028">xyr_GradLat_wq</a>      :</td><td>スペクトルデータに勾配型緯度微分 1/r・∂/∂φを作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002029">wr_DivLon_xyr</a>       :</td><td>格子データに発散型経度微分 1/rcosφ・∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002030">wr_DivLat_xyr</a>       :</td><td>格子データに発散型緯度微分 1/rcosφ・∂(g cosφ)/∂φを作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002031">wr_Div_xyr_xyr_xyr</a>  :</td><td>ベクトル成分である 3 つの格子データに 発散を作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002032">xyr_Div_xyr_xyr_xyr</a> :</td><td>ベクトル成分である 3 つの格子データに 発散を作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002033">xyr_RotLon_wq_wq</a>    :</td><td>ベクトル場の回転の経度成分を計算する

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002034">xyr_RotLat_wq_wq</a>    :</td><td>ベクトル場の回転の緯度成分を計算する

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002035">wr_RotRad_xyr_xyr</a>   :</td><td>ベクトル場の回転の動径成分を計算する

</td></tr>
</table>
<h4>トロイダルポロイダル計算用微分</h4>
<table>
<tr><td valign="top"><a href="wq_module.html#M002064">wq_KxRGrad_wq</a>     :</td><td>スペクトルデータに経度微分 k×r・▽ = ∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002065">xyr_KGrad_wq</a>      :</td><td>スペクトルデータに軸方向微分 k・▽ = cosφ/r ∂/∂φ + sinφ∂/∂r
を作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002066">wq_L2_wq</a>          :</td><td>スペクトルデータに L2 演算子 = -水平ラプラシアンを 作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002067">wq_L2Inv_wq</a>       :</td><td>スペクトルデータに L2 演算子の逆 = -逆水平ラプラシアン を作用させる

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002068">wq_QOperator_wq</a>   :</td><td>スペクトルデータに演算子 Q=(k・▽-1/2(L2 k・▽+ k・▽L2)) を作用させる

</td></tr>
<tr><td valign="top">wq_RadRot_xyr_xyr :</td><td>ベクトル v の渦度と動径ベクトル r の内積 r・(▽×v) を 計算する

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002070">wr_RadRotRot_xyr_xyr_xyr</a> :</td><td>ベクトルの v の r・(▽×▽×v) を計算する

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002071">wq_RadRotRot_xyr_xyr_xyr</a> :</td><td>ベクトルの v の r・(▽×▽×v) を計算する

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002072">wq_Potential2Vector</a>      :</td><td>トロイダルポロイダルポテンシャルから ベクトル場を計算する

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002073">wq_Potential2Rotation</a>    :</td><td>トロイダルポロイダルポテンシャルで表される
非発散ベクトル場の回転の各成分を計算する

</td></tr>
</table>
<h4>ポロイダル/トロイダルモデル用スペクトル解析</h4>
<table>
<tr><td valign="top"><a href="wq_module.html#M002074">nmr_ToroidalEnergySpectrum_wq</a>, <a href="wq_module.html#M002075">nr_ToroidalEnergySpectrum_wq</a>  :</td><td>トロイダルポテンシャルからエネルギーの球面調和函数各成分を計算する

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002076">nmr_PoloidalEnergySpectrum_wq</a>, <a href="wq_module.html#M002077">nr_PoloidalEnergySpectrum_wq</a>  :</td><td>ポロイダルポテンシャルからエネルギーの球面調和函数各成分を計算する

</td></tr>
</table>
<h4>境界値問題</h4>
<table>
<tr><td valign="top">wq_BoundariesTau, wr_BoundariesGrid, wq_Boundaries                   :</td><td>ディリクレ, ノイマン境界条件を適用する(タウ法, 選点法)

</td></tr>
<tr><td valign="top">wq_TorBoundariesTau, wr_TorBoundariesGrid, wq_TorBoundaries          :</td><td>速度トロイダルポテンシャルの境界条件を適用する(タウ法,選点法)

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002089">wq_LaplaPol2Pol_wq</a>                                                   :</td><td>速度ポロイダルポテンシャルΦを▽^2Φから求める

</td></tr>
<tr><td valign="top">wq_TorMagBoundariesTau, wr_TorMagBoundariesGrid, wq_TorMagBoundaries :</td><td>磁場トロイダルポテンシャルの境界条件を適用する(タウ法, 選点法)

</td></tr>
<tr><td valign="top">wq_PolMagBoundariesTau, wr_PolMagBoundariesGrid, wq_PolMagBoundaries :</td><td>磁場トロイダルポテンシャル境界の境界条件を適用する(タウ法, 選点法)

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002078">wq_BoundaryTau</a>, <a href="wq_module.html#M002079">wr_BoundaryGrid</a>, <a href="wq_module.html#M002087">wq_Boundary</a>                         :</td><td>ディリクレ, ノイマン境界条件を適用する(タウ法, 選点法)

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002080">wq_TorBoundaryTau</a>, <a href="wq_module.html#M002081">wr_TorBoundaryGrid</a>, <a href="wq_module.html#M002088">wq_TorBoundary</a>                :</td><td>速度トロイダルポテンシャルの境界条件を適用する(タウ法,選点法)

</td></tr>
<tr><td valign="top">wr_LaplaPol2Pol_wr, <a href="wq_module.html#M002089">wq_LaplaPol2Pol_wq</a>                               :</td><td>速度ポロイダルポテンシャルΦを▽^2Φから求める
(入出力がそれぞれ格子点およびスペクトル係数)

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002083">wq_TorMagBoundaryTau</a>, <a href="wq_module.html#M002084">wr_TorMagBoundaryGrid</a>, <a href="wq_module.html#M002090">wq_TorMagBoundary</a>       :</td><td>磁場トロイダルポテンシャルの境界条件を適用する(タウ法, 選点法)

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002085">wq_PolMagBoundaryTau</a>, <a href="wq_module.html#M002086">wr_PolMagBoundaryGrid</a>, <a href="wq_module.html#M002091">wq_PolMagBoundary</a>       :</td><td>磁場トロイダルポテンシャル境界の境界条件を適用する(タウ法, 選点法)

</td></tr>
</table>
<h4>積分・平均(3 次元データ)</h4>
<table>
<tr><td valign="top">IntLonLatRad_xyz, AvrLonLatRad_xyz :</td><td>3 次元格子点データの 全領域積分および平均

</td></tr>
<tr><td valign="top">z_IntLonLat_xyz, z_AvrLonLat_xyz   :</td><td>3 次元格子点データの 緯度経度(水平・球面)積分および平均

</td></tr>
<tr><td valign="top">y_IntLonRad_xyz, y_AvrLonRad_xyz   :</td><td>3 次元格子点データの 緯度動径積分および平均

</td></tr>
<tr><td valign="top">z_IntLatRad_xyz, z_AvrLatRad_xyz   :</td><td>3 次元格子点データの 経度動径(子午面)積分および平均

</td></tr>
<tr><td valign="top">yz_IntLon_xyz, yz_AvrLon_xyz       :</td><td>3 次元格子点データの 経度方向積分および平均

</td></tr>
<tr><td valign="top">xz_IntLat_xyz, xz_AvrLat_xyz       :</td><td>3 次元格子点データの 緯度方向積分および平均

</td></tr>
<tr><td valign="top">xz_IntRad_xyz, xz_AvrRad_xyz       :</td><td>3 次元格子点データの 動径方向積分および平均

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002042">IntLonLatRad_xyr</a>, <a href="wq_module.html#M002056">AvrLonLatRad_xyr</a> :</td><td>3 次元格子点データの 全領域積分および平均

</td></tr>
<tr><td valign="top">z_IntLonLat_xyr, z_AvrLonLat_xyr   :</td><td>3 次元格子点データの 緯度経度(水平・球面)積分および平均

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002040">y_IntLonRad_xyr</a>, <a href="wq_module.html#M002054">y_AvrLonRad_xyr</a>   :</td><td>3 次元格子点データの 緯度動径積分および平均

</td></tr>
<tr><td valign="top">z_IntLatRad_xyr, z_AvrLatRad_xyr   :</td><td>3 次元格子点データの 経度動径(子午面)積分および平均

</td></tr>
<tr><td valign="top">yz_IntLon_xyr, yz_AvrLon_xyr       :</td><td>3 次元格子点データの 経度方向積分および平均

</td></tr>
<tr><td valign="top">xz_IntLat_xyr, xz_AvrLat_xyr       :</td><td>3 次元格子点データの 緯度方向積分および平均

</td></tr>
<tr><td valign="top">xz_IntRad_xyr, xz_AvrRad_xyr       :</td><td>3 次元格子点データの 動径方向積分および平均

</td></tr>
</table>
<h4>積分・平均(2 次元データ)</h4>
<table>
<tr><td valign="top"><a href="wq_module.html#M002116">IntLonLat_xy</a>, <a href="wq_module.html#M002121">AvrLonLat_xy</a> :</td><td>2 次元格子点データの水平(球面)積分および平均

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002048">IntLonRad_xr</a>, <a href="wq_module.html#M002062">AvrLonRad_xr</a> :</td><td>2 次元(XZ)格子点データの経度動径積分 および平均

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002045">IntLatRad_yr</a>, <a href="wq_module.html#M002059">AvrLatRad_yr</a> :</td><td>2 次元(YZ)格子点データの緯度動径(子午面) 積分および平均

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002115">y_IntLon_xy</a>, <a href="wq_module.html#M002120">y_AvrLon_xy</a>   :</td><td>水平 2 次元(球面)格子点データの経度方向 積分および平均

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002114">x_IntLat_xy</a>, <a href="wq_module.html#M002119">x_AvrLat_xy</a>   :</td><td>水平2 次元(球面)格子点データの緯度方向積分 および平均

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002046">r_IntLon_xr</a>, <a href="wq_module.html#M002060">r_AvrLon_xr</a>   :</td><td>2 次元(XZ)格子点データの経度方向積分および 平均

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002047">x_IntRad_xr</a>, <a href="wq_module.html#M002061">x_AvrRad_xr</a>   :</td><td>2 次元(XZ)格子点データの動径方向積分および 平均

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002043">r_IntLat_yr</a>, <a href="wq_module.html#M002057">r_AvrLat_yr</a>   :</td><td>2 次元(YZ)格子点データの緯度方向積分および 平均

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002044">y_IntRad_yr</a>, <a href="wq_module.html#M002058">y_AvrRad_yr</a>   :</td><td>2 次元(YZ)格子点データの動径方向積分および 平均

</td></tr>
</table>
<h4>積分・平均(1 次元データ)</h4>
<table>
<tr><td valign="top"><a href="wq_module.html#M002117">IntLon_x</a>, <a href="wq_module.html#M002122">AvrLon_x</a>  :</td><td>1 次元(X)格子点データの経度方向積分および平均

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002118">IntLat_y</a>, <a href="wq_module.html#M002123">AvrLat_y</a>  :</td><td>1 次元(Y)格子点データの緯度方向積分および平均

</td></tr>
<tr><td valign="top"><a href="wq_module.html#M002049">IntRad_r</a>, <a href="wq_module.html#M002063">AvrRad_r</a>  :</td><td>1 次元(Z)格子点データの動径方向積分および平均

</td></tr>
</table>

    </div>





   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M002059">AvrLatRad_yr</a>&nbsp;&nbsp;

        <a href="#M002123">AvrLat_y</a>&nbsp;&nbsp;

        <a href="#M002056">AvrLonLatRad_xyr</a>&nbsp;&nbsp;

        <a href="#M002121">AvrLonLat_xy</a>&nbsp;&nbsp;

        <a href="#M002062">AvrLonRad_xr</a>&nbsp;&nbsp;

        <a href="#M002122">AvrLon_x</a>&nbsp;&nbsp;

        <a href="#M002063">AvrRad_r</a>&nbsp;&nbsp;

        <a href="#M002045">IntLatRad_yr</a>&nbsp;&nbsp;

        <a href="#M002118">IntLat_y</a>&nbsp;&nbsp;

        <a href="#M002042">IntLonLatRad_xyr</a>&nbsp;&nbsp;

        <a href="#M002116">IntLonLat_xy</a>&nbsp;&nbsp;

        <a href="#M002048">IntLonRad_xr</a>&nbsp;&nbsp;

        <a href="#M002117">IntLon_x</a>&nbsp;&nbsp;

        <a href="#M002049">IntRad_r</a>&nbsp;&nbsp;

        <a href="#M002098">l_nm</a>&nbsp;&nbsp;

        <a href="#M002099">l_nm</a>&nbsp;&nbsp;

        <a href="#M002100">l_nm</a>&nbsp;&nbsp;

        <a href="#M002101">l_nm</a>&nbsp;&nbsp;

        <a href="#M002102">nm_l</a>&nbsp;&nbsp;

        <a href="#M002103">nm_l</a>&nbsp;&nbsp;

        <a href="#M002076">nmr_PoloidalEnergySpectrum_wq</a>&nbsp;&nbsp;

        <a href="#M002074">nmr_ToroidalEnergySpectrum_wq</a>&nbsp;&nbsp;

        <a href="#M002077">nr_PoloidalEnergySpectrum_wq</a>&nbsp;&nbsp;

        <a href="#M002075">nr_ToroidalEnergySpectrum_wq</a>&nbsp;&nbsp;

        <a href="#M002113">q_Rad2Inv_q</a>&nbsp;&nbsp;

        <a href="#M002111">q_Rad2_q</a>&nbsp;&nbsp;

        <a href="#M002109">q_RadDRad_q</a>&nbsp;&nbsp;

        <a href="#M002057">r_AvrLat_yr</a>&nbsp;&nbsp;

        <a href="#M002055">r_AvrLonLat_xyr</a>&nbsp;&nbsp;

        <a href="#M002060">r_AvrLon_xr</a>&nbsp;&nbsp;

        <a href="#M002043">r_IntLat_yr</a>&nbsp;&nbsp;

        <a href="#M002041">r_IntLonLat_xyr</a>&nbsp;&nbsp;

        <a href="#M002046">r_IntLon_xr</a>&nbsp;&nbsp;

        <a href="#M002097">r_RAD_WEIGHT</a>&nbsp;&nbsp;

        <a href="#M002096">r_Rad</a>&nbsp;&nbsp;

        <a href="#M002106">w_xy</a>&nbsp;&nbsp;

        <a href="#M002087">wq_Boundary</a>&nbsp;&nbsp;

        <a href="#M002078">wq_BoundaryTau</a>&nbsp;&nbsp;

        <a href="#M002015">wq_Initial</a>&nbsp;&nbsp;

        <a href="#M002064">wq_KxRGrad_wq</a>&nbsp;&nbsp;

        <a href="#M002067">wq_L2Inv_wq</a>&nbsp;&nbsp;

        <a href="#M002066">wq_L2_wq</a>&nbsp;&nbsp;

        <a href="#M002082">wq_LaplaPol2PolTau_wq</a>&nbsp;&nbsp;

        <a href="#M002089">wq_LaplaPol2Pol_wq</a>&nbsp;&nbsp;

        <a href="#M002026">wq_Lapla_wq</a>&nbsp;&nbsp;

        <a href="#M002091">wq_PolMagBoundary</a>&nbsp;&nbsp;

        <a href="#M002085">wq_PolmagBoundaryTau</a>&nbsp;&nbsp;

        <a href="#M002073">wq_Potential2Rotation</a>&nbsp;&nbsp;

        <a href="#M002072">wq_Potential2Vector</a>&nbsp;&nbsp;

        <a href="#M002068">wq_QOperator_wq</a>&nbsp;&nbsp;

        <a href="#M002112">wq_Rad2Inv_wq</a>&nbsp;&nbsp;

        <a href="#M002110">wq_Rad2_wq</a>&nbsp;&nbsp;

        <a href="#M002108">wq_RadDRad_wq</a>&nbsp;&nbsp;

        <a href="#M002071">wq_RadRotRot_xyr_xyr_xyr</a>&nbsp;&nbsp;

        <a href="#M002025">wq_RotDRad_wr</a>&nbsp;&nbsp;

        <a href="#M002088">wq_TorBoundary</a>&nbsp;&nbsp;

        <a href="#M002080">wq_TorBoundaryTau</a>&nbsp;&nbsp;

        <a href="#M002090">wq_TorMagBoundary</a>&nbsp;&nbsp;

        <a href="#M002083">wq_TormagBoundaryTau</a>&nbsp;&nbsp;

        <a href="#M002014">wq_VMiss</a>&nbsp;&nbsp;

        <a href="#M002021">wq_wr</a>&nbsp;&nbsp;

        <a href="#M002017">wq_xyr</a>&nbsp;&nbsp;

        <a href="#M002079">wr_BoundaryGrid</a>&nbsp;&nbsp;

        <a href="#M002030">wr_DivLat_xyr</a>&nbsp;&nbsp;

        <a href="#M002029">wr_DivLon_xyr</a>&nbsp;&nbsp;

        <a href="#M002022">wr_DivRad_wq</a>&nbsp;&nbsp;

        <a href="#M002031">wr_Div_xyr_xyr_xyr</a>&nbsp;&nbsp;

        <a href="#M002086">wr_PolmagBoundaryGrid</a>&nbsp;&nbsp;

        <a href="#M002013">wr_RAD</a>&nbsp;&nbsp;

        <a href="#M002070">wr_RadRotRot_xyr_xyr_xyr</a>&nbsp;&nbsp;

        <a href="#M002069">wr_RadRot_xyr_xyr</a>&nbsp;&nbsp;

        <a href="#M002023">wr_RotDRad_wq</a>&nbsp;&nbsp;

        <a href="#M002024">wr_RotDRad_wr</a>&nbsp;&nbsp;

        <a href="#M002035">wr_RotRad_xyr_xyr</a>&nbsp;&nbsp;

        <a href="#M002081">wr_TorBoundaryGrid</a>&nbsp;&nbsp;

        <a href="#M002084">wr_TormagBoundaryGrid</a>&nbsp;&nbsp;

        <a href="#M002020">wr_wq</a>&nbsp;&nbsp;

        <a href="#M002019">wr_xyr</a>&nbsp;&nbsp;

        <a href="#M002053">x_AvrLatRad_xyr</a>&nbsp;&nbsp;

        <a href="#M002119">x_AvrLat_xy</a>&nbsp;&nbsp;

        <a href="#M002061">x_AvrRad_xr</a>&nbsp;&nbsp;

        <a href="#M002039">x_IntLatRad_xyr</a>&nbsp;&nbsp;

        <a href="#M002114">x_IntLat_xy</a>&nbsp;&nbsp;

        <a href="#M002047">x_IntRad_xr</a>&nbsp;&nbsp;

        <a href="#M002092">x_Lon</a>&nbsp;&nbsp;

        <a href="#M002093">x_Lon_Weight</a>&nbsp;&nbsp;

        <a href="#M002051">xr_AvrLat_xyr</a>&nbsp;&nbsp;

        <a href="#M002037">xr_IntLat_xyr</a>&nbsp;&nbsp;

        <a href="#M002052">xy_AvrRad_xyr</a>&nbsp;&nbsp;

        <a href="#M002038">xy_IntRad_xyr</a>&nbsp;&nbsp;

        <a href="#M002105">xy_Lat</a>&nbsp;&nbsp;

        <a href="#M002104">xy_Lon</a>&nbsp;&nbsp;

        <a href="#M002107">xy_w</a>&nbsp;&nbsp;

        <a href="#M002032">xyr_Div_xyr_xyr_xyr</a>&nbsp;&nbsp;

        <a href="#M002028">xyr_GradLat_wq</a>&nbsp;&nbsp;

        <a href="#M002027">xyr_GradLon_wq</a>&nbsp;&nbsp;

        <a href="#M002065">xyr_KGrad_wq</a>&nbsp;&nbsp;

        <a href="#M002011">xyr_LAT</a>&nbsp;&nbsp;

        <a href="#M002010">xyr_LON</a>&nbsp;&nbsp;

        <a href="#M002012">xyr_RAD</a>&nbsp;&nbsp;

        <a href="#M002034">xyr_RotLat_wq_wq</a>&nbsp;&nbsp;

        <a href="#M002033">xyr_RotLon_wq_wq</a>&nbsp;&nbsp;

        <a href="#M002016">xyr_wq</a>&nbsp;&nbsp;

        <a href="#M002018">xyr_wr</a>&nbsp;&nbsp;

        <a href="#M002054">y_AvrLonRad_xyr</a>&nbsp;&nbsp;

        <a href="#M002120">y_AvrLon_xy</a>&nbsp;&nbsp;

        <a href="#M002058">y_AvrRad_yr</a>&nbsp;&nbsp;

        <a href="#M002040">y_IntLonRad_xyr</a>&nbsp;&nbsp;

        <a href="#M002115">y_IntLon_xy</a>&nbsp;&nbsp;

        <a href="#M002044">y_IntRad_yr</a>&nbsp;&nbsp;

        <a href="#M002094">y_Lat</a>&nbsp;&nbsp;

        <a href="#M002095">y_Lat_Weight</a>&nbsp;&nbsp;

        <a href="#M002050">yr_AvrLon_xyr</a>&nbsp;&nbsp;

        <a href="#M002036">yr_IntLon_xyr</a>&nbsp;&nbsp;
      </div>
    </div>


  </div>


    <!-- if includes -->

    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">

        <span class="include-name">dc_message</span>

        <span class="include-name"><a href="lumatrix.html">lumatrix</a></span>

        <span class="include-name"><a href="wa_module.html">wa_module</a></span>

        <span class="include-name"><a href="aq_module.html">aq_module</a></span>
      </div>
    </div>



    <div id="section">










      


    <!-- if method_list -->

    <div id="methods">


      <h3 class="section-bar">Public Instance methods</h3>


      <div id="method-M002059" class="method-detail">
        <a name="M002059"></a>

        <div class="method-heading">


          <a href="#M002059" class="method-signature">



          <span class="method-name">AvrLatRad_yr</span><span class="method-args">( yr ) result(AvrLatRad_yr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002059">AvrLatRad_yr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径(子午面)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度動径(子午面)積分
</p>
<p>
2 次元(YR)格子点データの緯度動径(子午面)平均
</p>
<p>
2 次元データ f(φ,r) に対して
</p>
<pre>
   ∫f(φ,r) r^2cosφ dφdr /(2(r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002059-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002059-source">
<pre>
    function AvrLatRad_yr(yr)  ! 緯度動径(子午面)積分
      !
      ! 2 次元(YR)格子点データの緯度動径(子午面)平均
      !
      ! 2 次元データ f(φ,r) に対して
      !
      !    ∫f(φ,r) r^2cosφ dφdr /(2(r[o]^3-r[i]^3)/3) 
      !
      ! を計算する.
      !
      real(8), dimension(1:jm,km), intent(in) :: yr
      !(in) 2 次元緯度動径(子午面)格子点データ

      real(8)                   :: AvrLatRad_yr
      !(out) 平均値

      AvrLatRad_yr = IntLatRad_yr(yr)/(sum(y_Lat_Weight)*sum(r_Rad_Weight))

    end function AvrLatRad_yr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002123" class="method-detail">
        <a name="M002123"></a>

        <div class="method-heading">




          <span class="method-name">AvrLat_y</span><span class="method-args">( y_data ) result(AvrLat_y)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002123">AvrLat_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y_data(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(Y)格子点データの緯度(Y)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, y_Y_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000924">wa_module#AvrLat_y</a>
</p>


        </div>
      </div>


      <div id="method-M002056" class="method-detail">
        <a name="M002056"></a>

        <div class="method-heading">


          <a href="#M002056" class="method-signature">



          <span class="method-name">AvrLonLatRad_xyr</span><span class="method-args">( xyr ) result(AvrLonLatRad_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002056">AvrLonLatRad_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全球平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度経度動径(全球)積分
</p>
<p>
3 次元格子点データの緯度経度動径(全球)積分
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
   ∫f(λ,φ,r) r^2cosφ dλdφdr /(4π(r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002056-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002056-source">
<pre>
    function AvrLonLatRad_xyr(xyr) ! 緯度経度動径(全球)積分
      !
      ! 3 次元格子点データの緯度経度動径(全球)積分
      !
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !    ∫f(λ,φ,r) r^2cosφ dλdφdr /(4π(r[o]^3-r[i]^3)/3) 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8)                     :: AvrLonLatRad_xyr
      !(out) 全球平均値

      AvrLonLatRad_xyr = IntLonLatRad_xyr(xyr) /(sum(x_Lon_Weight)*sum(y_Lat_Weight) * sum(r_Rad_Weight))

    end function AvrLonLatRad_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002121" class="method-detail">
        <a name="M002121"></a>

        <div class="method-heading">




          <span class="method-name">AvrLonLat_xy</span><span class="method-args">( xy_data ) result(AvrLonLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002121">AvrLonLat_xy</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの全領域平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた 総和を計算し,
x_X_Weight*y_Y_Weight の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000920">wa_module#AvrLonLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M002062" class="method-detail">
        <a name="M002062"></a>

        <div class="method-heading">


          <a href="#M002062" class="method-signature">



          <span class="method-name">AvrLonRad_xr</span><span class="method-args">( xr ) result(AvrLonRad_xr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002062">AvrLonRad_xr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
経度動径(緯度円)積分
</p>
<p>
2 次元(XR)格子点データの経度動径平均
</p>
<p>
2 次元データ f(λ,r) に対して
</p>
<pre>
   ∫f(λ,r) r^2dλdr /(2π(r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002062-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002062-source">
<pre>
    function AvrLonRad_xr(xr)  ! 経度動径(緯度円)積分
      !
      ! 2 次元(XR)格子点データの経度動径平均
      !
      ! 2 次元データ f(λ,r) に対して 
      ! 
      !    ∫f(λ,r) r^2dλdr /(2π(r[o]^3-r[i]^3)/3)
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,km), intent(in) :: xr
      ! (in) 2 次元格子点データ
      real(8)                                 :: AvrLonRad_xr      
      ! 積分値

      AvrLonRad_xr = IntLonRad_xr(xr)/(sum(x_Lon_Weight)*sum(r_Rad_Weight))

    end function AvrLonRad_xr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002122" class="method-detail">
        <a name="M002122"></a>

        <div class="method-heading">




          <span class="method-name">AvrLon_x</span><span class="method-args">( x_data ) result(AvrLon_x)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002122">AvrLon_x</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>x_data(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(X)格子点データの経度(X)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, x_X_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000922">wa_module#AvrLon_x</a>
</p>


        </div>
      </div>


      <div id="method-M002063" class="method-detail">
        <a name="M002063"></a>

        <div class="method-heading">


          <a href="#M002063" class="method-signature">



          <span class="method-name">AvrRad_r</span><span class="method-args">( z ) result(AvrRad_r)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002063">AvrRad_r</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>z  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(Z)格子点データの動径方向域平均.
</p>
<p>
1 次元データ f(r) に対して ∫f(r) r^2dr /((r[o]^3-r[i]^3)/3) を 計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002063-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002063-source">
<pre>
    function AvrRad_r(z)
      !
      ! 1 次元(Z)格子点データの動径方向域平均.
      !
      ! 1 次元データ f(r) に対して ∫f(r) r^2dr /((r[o]^3-r[i]^3)/3) を
      ! 計算する.
      !
      real(8), dimension(0:im-1,km), intent(in) :: z
      !(in) 1 次元動径格子点データ
      real(8)                                 :: AvrRad_r
      !(out) 平均値

      AvrRad_r = IntRad_r(z)/sum(r_Rad_Weight)

    end function AvrRad_r
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002045" class="method-detail">
        <a name="M002045"></a>

        <div class="method-heading">


          <a href="#M002045" class="method-signature">



          <span class="method-name">IntLatRad_yr</span><span class="method-args">( yr ) result(IntLatRad_yr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002045">IntLatRad_yr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径(子午面)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元(YR)格子点データの緯度動径積分(子午面)および平均
</p>
<p>
2 次元データ f(φ,r) に対して ∫f(φ,r) r^2cosφ dφdr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002045-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002045-source">
<pre>
    function IntLatRad_yr(yr)
      !
      ! 2 次元(YR)格子点データの緯度動径積分(子午面)および平均
      !
      ! 2 次元データ f(φ,r) に対して ∫f(φ,r) r^2cosφ dφdr を計算する.
      !
      real(8), dimension(1:jm,km), intent(in) :: yr
      !(in) 2 次元緯度動径(子午面)格子点データ

      real(8)                   :: IntLatRad_yr
      !(out) 積分値
      integer :: j, k

      IntLatRad_yr = 0.0D0
      do k=1,km
         do j=1,jm
            IntLatRad_yr = IntLatRad_yr + yr(j,k) * y_Lat_Weight(j) * r_Rad_Weight(k)
         enddo
      enddo

    end function IntLatRad_yr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002118" class="method-detail">
        <a name="M002118"></a>

        <div class="method-heading">




          <span class="method-name">IntLat_y</span><span class="method-args">( y_data ) result(IntLat_y)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002118">IntLat_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y_data(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元緯度(Y)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元緯度(Y)格子点データの Y 方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000919">wa_module#IntLat_y</a>
</p>


        </div>
      </div>


      <div id="method-M002042" class="method-detail">
        <a name="M002042"></a>

        <div class="method-heading">


          <a href="#M002042" class="method-signature">



          <span class="method-name">IntLonLatRad_xyr</span><span class="method-args">( xyr ) result(IntLonLatRad_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002042">IntLonLatRad_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全球積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度経度動径(全球)積分
</p>
<p>
3 次元格子点データの緯度経度動径(全球)積分
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
    ∫f(λ,φ,r) r^2cosφ dλdφdr
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002042-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002042-source">
<pre>
    function IntLonLatRad_xyr(xyr) ! 緯度経度動径(全球)積分
      !
      ! 3 次元格子点データの緯度経度動径(全球)積分
      !
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !     ∫f(λ,φ,r) r^2cosφ dλdφdr 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr 
      !(in) 3 次元経度緯度動径格子点データ

      real(8)                     :: IntLonLatRad_xyr 
      !(out) 全球積分値

      integer :: i, j, k

      IntLonLatRad_xyr = 0.0D0
      do k=1,km
         do j=1,jm
            do i=0,im-1
               IntLonLatRad_xyr = IntLonLatRad_xyr + xyr(i,j,k) * x_Lon_Weight(i) * y_Lat_Weight(j) * r_Rad_Weight(k)
            enddo
         enddo
      enddo

    end function IntLonLatRad_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002116" class="method-detail">
        <a name="M002116"></a>

        <div class="method-heading">




          <span class="method-name">IntLonLat_xy</span><span class="method-args">( xy_data ) result(IntLonLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002116">IntLonLat_xy</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの全領域積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた
総和を計算している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000915">wa_module#IntLonLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M002048" class="method-detail">
        <a name="M002048"></a>

        <div class="method-heading">


          <a href="#M002048" class="method-signature">



          <span class="method-name">IntLonRad_xr</span><span class="method-args">( xr ) result(IntLonRad_xr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002048">IntLonRad_xr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
経度動径(緯度円)積分
</p>
<p>
2 次元(XR)格子点データの経度動径積分
</p>
<p>
2 次元データ f(λ,r) に対して∫f(λ,r) r^2dλdr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002048-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002048-source">
<pre>
    function IntLonRad_xr(xr)  ! 経度動径(緯度円)積分
      !
      ! 2 次元(XR)格子点データの経度動径積分
      !
      ! 2 次元データ f(λ,r) に対して∫f(λ,r) r^2dλdr を計算する.
      !
      real(8), dimension(0:im-1,km), intent(in) :: xr
      !(in) 2 次元緯度動径格子点データ

      real(8)                                 :: IntLonRad_xr
      !(out) 積分値

      integer :: i, k

      IntLonRad_xr = 0.0D0
      do k=1,km
         do i=0,im-1
            IntLonRad_xr = IntLonRad_xr + xr(i,k) * x_Lon_Weight(i) * r_Rad_Weight(k)
         enddo
      enddo

    end function IntLonRad_xr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002117" class="method-detail">
        <a name="M002117"></a>

        <div class="method-heading">




          <span class="method-name">IntLon_x</span><span class="method-args">( x_data ) result(IntLon_x)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002117">IntLon_x</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>x_data(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元経度(X)格子点データの X 方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000917">wa_module#IntLon_x</a>
</p>


        </div>
      </div>


      <div id="method-M002049" class="method-detail">
        <a name="M002049"></a>

        <div class="method-heading">


          <a href="#M002049" class="method-signature">



          <span class="method-name">IntRad_r</span><span class="method-args">( z ) result(IntRad_r)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002049">IntRad_r</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>z  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
動径積分
</p>
<p>
1 次元(Z)格子点データの動径方向域積分.
</p>
<p>
1 次元データ f(r) に対して ∫f(r) r^2dr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002049-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002049-source">
<pre>
    function IntRad_r(z)  ! 動径積分
      !
      ! 1 次元(Z)格子点データの動径方向域積分.
      !
      ! 1 次元データ f(r) に対して ∫f(r) r^2dr を計算する.
      !
      real(8), dimension(km), intent(in) :: z
      !(in) 1 次元動径格子点データ

      real(8)                              :: IntRad_r
      !(out) 積分値

      integer :: k

      IntRad_r = 0.0d0
      do k=1,km
         IntRad_r = IntRad_r + z(k) * r_Rad_Weight(k) 
      enddo

    end function IntRad_r
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002098" class="method-detail">
        <a name="M002098"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( n, m ) result(l_nm_array00)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array00  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>n  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>m  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
引数 n,m がともに整数値の場合, 整数値を返す.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000877">wa_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M002099" class="method-detail">
        <a name="M002099"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( n, marray ) result(l_nm_array01)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array01(size(marray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>n  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>marray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置
</p>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1 引数 n が整数, 第 2 引数 marray が整数 1 次元配列の場合, marray
と同じ大きさの 1 次元整数配列を返す.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000877">wa_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M002100" class="method-detail">
        <a name="M002100"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( narray, m ) result(l_nm_array10)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array10(size(narray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>narray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>m  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1 引数 narray が整数 1 次元配列, 第 2 引数 m が整数の場合, narray
と同じ大きさの 1 次元整数配列を返す.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000877">wa_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M002101" class="method-detail">
        <a name="M002101"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( narray, marray ) result(l_nm_array11)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array11(size(narray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>narray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>marray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1,2 引数 narray, marray がともに整数 1 次元配列の場合, narray, marray
と同じ大きさの 1 次元整数配列を返す. narray, marray
は同じ大きさでなければならない.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000877">wa_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M002102" class="method-detail">
        <a name="M002102"></a>

        <div class="method-heading">




          <span class="method-name">nm_l</span><span class="method-args">( l ) result(nm_l_int)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>nm_l_int(2)  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全波数, 帯状波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>l  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置(l)から全波数(n)と東西波数(m)を返す.
</p>
<p>
引数 l が整数値の場合, 対応する全波数と帯状波数を 長さ 2 の 1
次元整数値を返す. <a href="wq_module.html#M002102">nm_l</a>(1) が全波数, <a
href="wq_module.html#M002102">nm_l</a>(2) が帯状波数である.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000881">wa_module#nm_l</a>
</p>


        </div>
      </div>


      <div id="method-M002103" class="method-detail">
        <a name="M002103"></a>

        <div class="method-heading">




          <span class="method-name">nm_l</span><span class="method-args">( larray ) result(nm_l_array)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>nm_l_array(size(larray),2)  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>larray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全波数, 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置(l)から全波数(n)と東西波数(m)を返す.
</p>
<p>
引数 larray が整数 1 次元配列の場合, larray に対応する n, m を格納した 2
次元整数配列を返す. nm_l_array(:,1) が全波数, nm_l_array(:,2)
が帯状波数である.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000881">wa_module#nm_l</a>
</p>


        </div>
      </div>


      <div id="method-M002076" class="method-detail">
        <a name="M002076"></a>

        <div class="method-heading">


          <a href="#M002076" class="method-signature">



          <span class="method-name">nmr_PoloidalEnergySpectrum_wq</span><span class="method-args">( wq_POLPOT ) result(nmr_PoloidalEnergySpectrum_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002076">nmr_PoloidalEnergySpectrum_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,-nm:nm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトルポロイダル成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq_POLPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ポロイダルポテンシャル

</td></tr>
</table>
</td></tr>
</table>
<p>
ポロイダルポテンシャルから, ポロイダルエネルギーの 球面調和函数全波数 n,
帯状波数 m の各成分を計算する.
</p>
<pre>
 * 全波数 n, 帯状波数 m のポロイダルポテンシャルのスペクトル成分
   φ(n,m,r)から全波数 n, 帯状波数 m 成分のポロイダルエネルギー
   スペクトルは

     (1/2)n(n+1)4πr^2{[d(rφ(n,m,r))/dr]^2 + n(n+1)φ(n,m,r)^2}

   と計算される.

 * 全てのエネルギースペクトル成分の和を動径積分したもの(r^2の重み無し)
   が球殻内での全エネルギーに等しい.

 * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
   欠損値の値はモジュール変数 wq_VMiss によって設定できる
   (初期値は -999.0)
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002076-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002076-source">
<pre>
    function nmr_PoloidalEnergySpectrum_wq(wq_POLPOT)
      !
      ! ポロイダルポテンシャルから, ポロイダルエネルギーの
      ! 球面調和函数全波数 n, 帯状波数 m の各成分を計算する.
      !
      !  * 全波数 n, 帯状波数 m のポロイダルポテンシャルのスペクトル成分
      !    φ(n,m,r)から全波数 n, 帯状波数 m 成分のポロイダルエネルギー
      !    スペクトルは 
      !
      !      (1/2)n(n+1)4πr^2{[d(rφ(n,m,r))/dr]^2 + n(n+1)φ(n,m,r)^2} 
      !
      !    と計算される.
      !
      !  * 全てのエネルギースペクトル成分の和を動径積分したもの(r^2の重み無し)
      !    が球殻内での全エネルギーに等しい.
      !
      !  * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
      !    欠損値の値はモジュール変数 wq_VMiss によって設定できる
      !    (初期値は -999.0)
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq_POLPOT
      !(in) ポロイダルポテンシャル

      real(8), dimension(0:nm,-nm:nm,km) :: nmr_PoloidalEnergySpectrum_wq 
      !(out) エネルギースペクトルポロイダル成分


      real(8), dimension((nm+1)*(nm+1),km) ::wr_DATA1   ! 作業領域
      real(8), dimension((nm+1)*(nm+1),km) ::wr_DATA2   ! 作業領域
      integer :: n, m

      nmr_PoloidalEnergySpectrum_wq = wq_VMiss

      wr_Data1 = wr_wq(wq_POLPOT)
      wr_Data2 = wr_wq(wq_RadDRad_wq(wq_POLPOT)+wq_POLPOT)  ! d(rφ)/dr
                                                            ! = rdφ/dr+φ

      do n=0,nm
         do m=-n,n
            nmr_PoloidalEnergySpectrum_wq(n,m,:) = + 0.5* n*(n+1)* (4*pi) *( wr_Data2(l_nm(n,m),:)**2 + n*(n+1)*wr_Data1(l_nm(n,m),:)**2 )
         enddo
      enddo

    end function nmr_PoloidalEnergySpectrum_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002074" class="method-detail">
        <a name="M002074"></a>

        <div class="method-heading">


          <a href="#M002074" class="method-signature">



          <span class="method-name">nmr_ToroidalEnergySpectrum_wq</span><span class="method-args">( wq_TORPOT ) result(nmr_ToroidalEnergySpectrum_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002074">nmr_ToroidalEnergySpectrum_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,-nm:nm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトルトロイダル成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) トロイダルポテンシャル

</td></tr>
</table>
</td></tr>
</table>
<p>
トロイダルポテンシャルから, トロイダルエネルギーの 球面調和函数全波数 n,
帯状波数 m の各成分を計算する
</p>
<pre>
 * 全波数 n, 帯状波数 m のトロイダルポテンシャルのスペクトル成分
   ψ(n,m,r)から全波数 n, 帯状波数 m 成分のトロイダルエネルギー
   スペクトルは  (1/2)n(n+1)4πr^2ψ(n,m,r)^2  と計算される.

 * 全てのエネルギースペクトル成分の和を動径積分したもの(r^2の重み無し)
   が球殻内での全エネルギーに等しい.

 * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
   wq_VMiss によって設定できる (初期値は -999.0)
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002074-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002074-source">
<pre>
    function nmr_ToroidalEnergySpectrum_wq(wq_TORPOT)
      !
      ! トロイダルポテンシャルから, トロイダルエネルギーの
      ! 球面調和函数全波数 n, 帯状波数 m の各成分を計算する
      !
      !  * 全波数 n, 帯状波数 m のトロイダルポテンシャルのスペクトル成分
      !    ψ(n,m,r)から全波数 n, 帯状波数 m 成分のトロイダルエネルギー
      !    スペクトルは  (1/2)n(n+1)4πr^2ψ(n,m,r)^2  と計算される.
      !
      !  * 全てのエネルギースペクトル成分の和を動径積分したもの(r^2の重み無し)
      !    が球殻内での全エネルギーに等しい.
      !    
      !  * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
      !    wq_VMiss によって設定できる (初期値は -999.0)
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq_TORPOT
      !(in) トロイダルポテンシャル

      real(8), dimension(0:nm,-nm:nm,km) :: nmr_ToroidalEnergySpectrum_wq
      !(out) エネルギースペクトルトロイダル成分

      real(8), dimension((nm+1)*(nm+1),km) ::wr_DATA   ! 作業領域
      integer :: n, m

      nmr_ToroidalEnergySpectrum_wq = wq_VMiss

      wr_DATA = wr_wq(wq_TORPOT)
      do n=0,nm
         do m=-n,n
            nmr_ToroidalEnergySpectrum_wq(n,m,:) = 0.5 * n*(n+1)* (4*pi) * r_Rad**2 * wr_DATA(l_nm(n,m),:)**2
         enddo
      enddo

    end function nmr_ToroidalEnergySpectrum_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002077" class="method-detail">
        <a name="M002077"></a>

        <div class="method-heading">


          <a href="#M002077" class="method-signature">



          <span class="method-name">nr_PoloidalEnergySpectrum_wq</span><span class="method-args">( wq_POLPOT ) result(nr_PoloidalEnergySpectrum_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002077">nr_PoloidalEnergySpectrum_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトルポロイダル成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq_POLPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ポロイダルポテンシャル

</td></tr>
</table>
</td></tr>
</table>
<p>
ポロイダルポテンシャルから, ポロイダルエネルギーの
球面調和函数全波数の各成分を計算する
</p>
<pre>
 * 全波数 n, 帯状波数 m のポロイダルポテンシャルのスペクトル成分
   φ(n,m,r)から全波数 n 成分のポロイダルエネルギースペクトルは

     Σ[m=-n]^n ((1/2)n(n+1)4πr^2{[d(rφ(n,m,r))/dr]^2
                + n(n+1)φ(n,m,r)^2}

   と計算される.

 * 全ての全波数に対してのエネルギースペクトル成分の和を動径積分したもの
   (r^2の重み無し)が球殻内での全エネルギーに等しい.
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002077-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002077-source">
<pre>
    function nr_PoloidalEnergySpectrum_wq(wq_POLPOT)
      !
      ! ポロイダルポテンシャルから, ポロイダルエネルギーの
      ! 球面調和函数全波数の各成分を計算する
      !
      !  * 全波数 n, 帯状波数 m のポロイダルポテンシャルのスペクトル成分
      !    φ(n,m,r)から全波数 n 成分のポロイダルエネルギースペクトルは
      !
      !      Σ[m=-n]^n ((1/2)n(n+1)4πr^2{[d(rφ(n,m,r))/dr]^2 
      !                 + n(n+1)φ(n,m,r)^2} 
      !
      !    と計算される.
      !
      !  * 全ての全波数に対してのエネルギースペクトル成分の和を動径積分したもの
      !    (r^2の重み無し)が球殻内での全エネルギーに等しい.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq_POLPOT
      !(in) ポロイダルポテンシャル

      real(8), dimension(0:nm,km) :: nr_PoloidalEnergySpectrum_wq
      !(out) エネルギースペクトルポロイダル成分

      real(8), dimension((nm+1)*(nm+1),km) ::wr_DATA1   ! 作業領域
      real(8), dimension((nm+1)*(nm+1),km) ::wr_DATA2   ! 作業領域
      integer :: n, m

      wr_Data1 = wr_wq(wq_POLPOT)
      wr_Data2 = wr_wq(wq_RadDRad_wq(wq_POLPOT)+wq_POLPOT)  ! d(rφ)/dr
                                                            ! = rdφ/dr+φ

      do n=0,nm
         nr_PoloidalEnergySpectrum_wq(n,:) = + 0.5* n*(n+1)* (4*pi) *( sum(wr_Data2(l_nm(n,(/(m,m=-n,n)/)),:)**2,1) + n*(n+1)*sum(wr_Data1(l_nm(n,(/(m,m=-n,n)/)),:)**2,1) )
      enddo

    end function nr_PoloidalEnergySpectrum_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002075" class="method-detail">
        <a name="M002075"></a>

        <div class="method-heading">


          <a href="#M002075" class="method-signature">



          <span class="method-name">nr_ToroidalEnergySpectrum_wq</span><span class="method-args">( wq_TORPOT ) result(nr_ToroidalEnergySpectrum_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002075">nr_ToroidalEnergySpectrum_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトルトロイダル成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) トロイダルポテンシャル

</td></tr>
</table>
</td></tr>
</table>
<p>
トロイダルポテンシャルから, トロイダルエネルギーの
球面調和函数全波数の各成分を計算する.
</p>
<pre>
 * 全波数 n, 帯状波数 m のトロイダルポテンシャルのスペクトル成分
   ψ(n,m,r)から全波数 n 成分のトロイダルエネルギースペクトルは
   Σ[m=-n]^n(1/2)n(n+1)4πr^2ψ(n,m,r)^2 と計算される.
</pre>
<ul>
<li>全てのエネルギースペクトル成分の和を動径積分したもの(r^2の重み無し)

<pre>
 が球殻内での全エネルギーに等しい.
</pre>
</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002075-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002075-source">
<pre>
    function nr_ToroidalEnergySpectrum_wq(wq_TORPOT)
      !
      ! トロイダルポテンシャルから, トロイダルエネルギーの
      ! 球面調和函数全波数の各成分を計算する.
      !
      !  * 全波数 n, 帯状波数 m のトロイダルポテンシャルのスペクトル成分
      !    ψ(n,m,r)から全波数 n 成分のトロイダルエネルギースペクトルは
      !    Σ[m=-n]^n(1/2)n(n+1)4πr^2ψ(n,m,r)^2 と計算される.
      !
      ! * 全てのエネルギースペクトル成分の和を動径積分したもの(r^2の重み無し)
      !    が球殻内での全エネルギーに等しい.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq_TORPOT
      !(in) トロイダルポテンシャル

      real(8), dimension(0:nm,km) :: nr_ToroidalEnergySpectrum_wq 
      !(out) エネルギースペクトルトロイダル成分

      real(8), dimension((nm+1)*(nm+1),km) ::wr_DATA   ! 作業領域
      integer :: n, m

      wr_DATA = wr_wq(wq_TORPOT)
      do n=0,nm
         nr_ToroidalEnergySpectrum_wq(n,:) = 0.5 * n*(n+1)* (4*pi) * r_Rad**2 * sum(wr_Data(l_nm(n,(/(m,m=-n,n)/)),:)**2,1)
      enddo

    end function nr_ToroidalEnergySpectrum_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002113" class="method-detail">
        <a name="M002113"></a>

        <div class="method-heading">




          <span class="method-name">q_Rad2Inv_q</span><span class="method-args">( q_data ) result(q_r2Inv_q)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>q_r2Inv_q  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの R 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに対して積 r^2 のスペクトル係数 を計算する(1
次元配列用).
</p>
<p>
Original external subprogram is <a
href="aq_module.html#M001993">aq_module#q_r2Inv_q</a>
</p>


        </div>
      </div>


      <div id="method-M002111" class="method-detail">
        <a name="M002111"></a>

        <div class="method-heading">




          <span class="method-name">q_Rad2_q</span><span class="method-args">( q_data ) result(q_r2_q)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>q_r2_q  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの R 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに対して積 r^2 のスペクトル係数 を計算する(1
次元配列用).
</p>
<p>
Original external subprogram is <a
href="aq_module.html#M001991">aq_module#q_r2_q</a>
</p>


        </div>
      </div>


      <div id="method-M002109" class="method-detail">
        <a name="M002109"></a>

        <div class="method-heading">




          <span class="method-name">q_RadDRad_q</span><span class="method-args">( q_data ) result(q_rDr_q)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>q_rDr_q  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの R 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>q_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに r(d/dR) 微分を作用する(1 次元配列用).
</p>
<p>
スペクトルデータの r(d/dR) 微分とは, 対応する格子点データに R 微分を
作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="aq_module.html#M001989">aq_module#q_rDr_q</a>
</p>


        </div>
      </div>


      <div id="method-M002057" class="method-detail">
        <a name="M002057"></a>

        <div class="method-heading">


          <a href="#M002057" class="method-signature">



          <span class="method-name">r_AvrLat_yr</span><span class="method-args">( yr ) result(r_AvrLat_yr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002057">r_AvrLat_yr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度平均された 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径(子午面)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元(YR)格子点データの緯度方向域平均.
</p>
<p>
2 次元データ f(φ,r) に対して ∫f(φ,r) cosφ dφ/2 を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002057-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002057-source">
<pre>
    function r_AvrLat_yr(yr)
      !
      ! 2 次元(YR)格子点データの緯度方向域平均.
      !
      ! 2 次元データ f(φ,r) に対して ∫f(φ,r) cosφ dφ/2 を計算する.
      !
      real(8), dimension(1:jm,km), intent(in) :: yr
      !(in) 2 次元緯度動径(子午面)格子点データ

      real(8), dimension(km)  :: r_AvrLat_yr
      !(out) 緯度平均された 1 次元動径格子点データ

      r_AvrLat_yr = r_IntLat_yr(yr)/sum(y_Lat_Weight)

    end function r_AvrLat_yr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002055" class="method-detail">
        <a name="M002055"></a>

        <div class="method-heading">


          <a href="#M002055" class="method-signature">



          <span class="method-name">r_AvrLonLat_xyr</span><span class="method-args">( xyr ) result(r_AvrLonLat_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002055">r_AvrLonLat_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度経度(水平, 球面)平均された 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度経度(水平)積分
</p>
<p>
3 次元格子点データの緯度経度(水平, 球面)積分
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
   ∫f(λ,φ,r) cosφ dλdφ /4π
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002055-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002055-source">
<pre>
    function r_AvrLonLat_xyr(xyr)  ! 緯度経度(水平)積分
      !
      ! 3 次元格子点データの緯度経度(水平, 球面)積分
      ! 
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !    ∫f(λ,φ,r) cosφ dλdφ /4π 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(km)     :: r_AvrLonLat_xyr
      !(out) 緯度経度(水平, 球面)平均された 1 次元動径格子点データ

      r_AvrLonLat_xyr = r_IntLonLat_xyr(xyr) /(sum(x_Lon_Weight)*sum(y_Lat_Weight))

    end function r_AvrLonLat_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002060" class="method-detail">
        <a name="M002060"></a>

        <div class="method-heading">


          <a href="#M002060" class="method-signature">



          <span class="method-name">r_AvrLon_xr</span><span class="method-args">( xr ) result(r_AvrLon_xr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002060">r_AvrLon_xr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度平均された 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
経度(帯状)積分
</p>
<p>
2 次元(XR)格子点データの経度方向平均.
</p>
<p>
2 次元データ f(λ,r) に対して ∫f(λ,r)dλ/2π を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002060-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002060-source">
<pre>
    function r_AvrLon_xr(xr)  ! 経度(帯状)積分
      !
      ! 2 次元(XR)格子点データの経度方向平均.
      !
      ! 2 次元データ f(λ,r) に対して ∫f(λ,r)dλ/2π を計算する.
      !
      real(8), dimension(0:im-1,km), intent(in) :: xr
      !(in) 2 次元緯度動径格子点データ

      real(8), dimension(km)  :: r_AvrLon_xr 
      !(out) 経度平均された 1 次元動径格子点データ

      r_AvrLon_xr = r_IntLon_xr(xr)/sum(x_Lon_Weight)

    end function r_AvrLon_xr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002043" class="method-detail">
        <a name="M002043"></a>

        <div class="method-heading">


          <a href="#M002043" class="method-signature">



          <span class="method-name">r_IntLat_yr</span><span class="method-args">( yr ) result(r_IntLat_yr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002043">r_IntLat_yr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度積分された 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径(子午面)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度積分
</p>
<p>
2 次元(YR)格子点データの緯度方向域積分.
</p>
<p>
2 次元データ f(φ,r) に対して∫f(φ,r) cosφ dφ を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002043-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002043-source">
<pre>
    function r_IntLat_yr(yr)  ! 緯度積分
      !
      ! 2 次元(YR)格子点データの緯度方向域積分.
      !
      ! 2 次元データ f(φ,r) に対して∫f(φ,r) cosφ dφ を計算する.
      !
      real(8), dimension(1:jm,km), intent(in) :: yr
      !(in) 2 次元緯度動径(子午面)格子点データ

      real(8), dimension(km)  :: r_IntLat_yr
      !(out) 緯度積分された 1 次元動径格子点データ

      integer :: j

      r_IntLat_yr = 0.0d0
      do j=1,jm
         r_IntLat_yr(:) = r_IntLat_yr(:) + yr(j,:) * y_Lat_Weight(j)
      enddo

    end function r_IntLat_yr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002041" class="method-detail">
        <a name="M002041"></a>

        <div class="method-heading">


          <a href="#M002041" class="method-signature">



          <span class="method-name">r_IntLonLat_xyr</span><span class="method-args">( xyr ) result(r_IntLonLat_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002041">r_IntLonLat_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度経度(水平, 球面)積分された 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度経度(水平)積分
</p>
<p>
3 次元格子点データの緯度経度(水平, 球面)積分
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
   ∫f(λ,φ,r) cosφ dλdφ
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002041-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002041-source">
<pre>
    function r_IntLonLat_xyr(xyr)  ! 緯度経度(水平)積分
      !
      ! 3 次元格子点データの緯度経度(水平, 球面)積分
      ! 
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !    ∫f(λ,φ,r) cosφ dλdφ 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(km)     :: r_IntLonLat_xyr
      !(out) 緯度経度(水平, 球面)積分された 1 次元動径格子点データ

      integer :: i, j

      r_IntLonLat_xyr = 0.0D0
      do j=1,jm
         do i=0,im-1
            r_IntLonLat_xyr = r_IntLonLat_xyr + xyr(i,j,:) * x_Lon_Weight(i) * y_Lat_Weight(j)
         enddo
      enddo
    end function r_IntLonLat_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002046" class="method-detail">
        <a name="M002046"></a>

        <div class="method-heading">


          <a href="#M002046" class="method-signature">



          <span class="method-name">r_IntLon_xr</span><span class="method-args">( xr ) result(r_IntLon_xr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002046">r_IntLon_xr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度積分された 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元(XR)格子点データの経度方向積分.
</p>
<p>
2 次元データ f(λ,r) に対して ∫f(λ,r)dλ を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002046-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002046-source">
<pre>
    function r_IntLon_xr(xr)
      !
      ! 2 次元(XR)格子点データの経度方向積分.
      !
      ! 2 次元データ f(λ,r) に対して ∫f(λ,r)dλ を計算する.
      !
      real(8), dimension(0:im-1,km), intent(in) :: xr
      !(in) 2 次元緯度動径格子点データ

      real(8), dimension(km)  :: r_IntLon_xr
      !(out) 経度積分された 1 次元動径格子点データ

      integer :: i

      r_IntLon_xr = 0.0d0
      do i=0,im-1
         r_IntLon_xr(:) = r_IntLon_xr(:) + xr(i,:) * x_Lon_Weight(i)
      enddo

    end function r_IntLon_xr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002097" class="method-detail">
        <a name="M002097"></a>

        <div class="method-heading">




          <span class="method-name">r_RAD_WEIGHT</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>g_R_Weight(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> ガウス重み

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="aq_module.html#M001982">aq_module#g_R_Weight</a>
</p>


        </div>
      </div>


      <div id="method-M002096" class="method-detail">
        <a name="M002096"></a>

        <div class="method-heading">




          <span class="method-name">r_Rad</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>g_R(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> ガウス&#8212;ラダウ格子点

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="aq_module.html#M001981">aq_module#g_R</a>
</p>


        </div>
      </div>


      <div id="method-M002106" class="method-detail">
        <a name="M002106"></a>

        <div class="method-heading">




          <span class="method-name">w_xy</span><span class="method-args">( xy_data, [ipow], [iflag] ) result(w_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002106">w_xy</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ipow  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 変換時に同時に作用させる 1/cosφ の次数. 省略時は 0.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>iflag  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> 変換の種類

<pre>
   0 : 通常の正変換
  -1 : 経度微分を作用させた正変換
   1 : 緯度微分 1/cosφ・∂(f cos^2φ)/∂φ を作用させた正変換
   2 : sinφを作用させた正変換
 省略時は 0.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからスペクトルデータへ(正)変換する(1 層用).
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000876">wa_module#w_xy</a>
</p>


        </div>
      </div>


      <div id="method-M002087" class="method-detail">
        <a name="M002087"></a>

        <div class="method-heading">




          <span class="method-name">wq_Boundary</span><span class="method-args">( wq, [value], [cond] ) </span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1)), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界での 値/勾配 分布を水平スペクトル変換したものを与える.

<pre>
    省略時は値/勾配 0 となる.
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=1), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件. 省略時は &#8216;D&#8216;

<pre>
       D : 外側ディリクレ条件
       N : 外側ノイマン条件
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータにディリクレ・ノイマン境界条件を適用する Chebyshev
空間での境界条件適用(タウ法)
</p>
<p>
チェビシェフ空間において境界条件を満たすべく高次の係数を
定める方法をとっている(タウ法).
</p>
<p>
Alias for <a href="wq_module.html#M002078">wq_BoundaryTau</a>
</p>


        </div>
      </div>


      <div id="method-M002078" class="method-detail">
        <a name="M002078"></a>

        <div class="method-heading">


          <a href="#M002078" class="method-signature">



          <span class="method-name">wq_BoundaryTau</span><span class="method-args">( wq, [value], [cond] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1)), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界での 値/勾配 分布を水平スペクトル変換したものを与える.

<pre>
    省略時は値/勾配 0 となる.
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=1), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件. 省略時は &#8216;D&#8216;

<pre>
       D : 外側ディリクレ条件
       N : 外側ノイマン条件
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータにディリクレ・ノイマン境界条件を適用する Chebyshev
空間での境界条件適用(タウ法)
</p>
<p>
チェビシェフ空間において境界条件を満たすべく高次の係数を
定める方法をとっている(タウ法).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002078-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002078-source">
<pre>
    subroutine wq_BoundaryTau(wq,value,cond)
      !
      ! スペクトルデータにディリクレ・ノイマン境界条件を適用する
      ! Chebyshev 空間での境界条件適用(タウ法)
      !
      ! チェビシェフ空間において境界条件を満たすべく高次の係数を
      ! 定める方法をとっている(タウ法).
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)      :: wq
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      real(8), dimension((nm+1)*(nm+1)), intent(in), optional   :: value
              !(in) 境界での 値/勾配 分布を水平スペクトル変換したものを与える. 
              !     省略時は値/勾配 0 となる. 

      character(len=1), intent(in), optional                    :: cond
              !(in) 境界条件. 省略時は 'D'
              !        D : 外側ディリクレ条件
              !        N : 外側ノイマン条件

      if (.not. present(cond)) then
         if (present(value)) then
            call aq_BoundaryTau_D(wq,value)
         else
            call aq_BoundaryTau_D(wq)
         endif
         return
      endif

      select case(cond)
      case ('N')
         if (present(value)) then
            call aq_BoundaryTau_N(wq,value)
         else
            call aq_BoundaryTau_N(wq)
         endif
      case ('D')
         if (present(value)) then
            call aq_BoundaryTau_D(wq,value)
         else
            call aq_BoundaryTau_D(wq)
         endif
      case default
         call MessageNotify('E','wq_BoundaryTau','B.C. not supported')
      end select

    end subroutine wq_BoundaryTau
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002015" class="method-detail">
        <a name="M002015"></a>

        <div class="method-heading">


          <a href="#M002015" class="method-signature">



          <span class="method-name">wq_Initial</span><span class="method-args">( i, j, k, n, l, r, [np], [wa_init] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>i  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点数(経度λ)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>j  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点数(緯度φ)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>k  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点数(動径 r)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>n  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 切断波数(水平全波数)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>l  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 切断波数(動径波数)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>r  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 球半径

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>np  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> OPENMP での最大スレッド数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_init  </tt></b>  <tt> </tt> :</td><td><tt>logical,intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> wa_initial スイッチ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル変換の格子点数, 波数, 動径座標の範囲を設定する.
</p>
<p>
他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで初期設定を
しなければならない.
</p>
<p>
np に 1 より大きな値を指定すれば ISPACK の球面調和函数変換 OPENMP
並列計算ルーチンが用いられる. 並列計算を実行するには, 実行時に環境変数
OMP_NUM_THREADS を np 以下の数字に設定する等の
システムに応じた準備が必要となる.
</p>
<p>
np に 1 より大きな値を指定しなければ並列計算ルーチンは呼ばれない.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002015-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002015-source">
<pre>
   subroutine wq_Initial(i,j,k,n,l,r,np,wa_init)
     !
     ! スペクトル変換の格子点数, 波数, 動径座標の範囲を設定する.
     !
     ! 他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで初期設定を
     ! しなければならない. 
     !
     ! np に 1 より大きな値を指定すれば ISPACK の球面調和函数変換 
     ! OPENMP 並列計算ルーチンが用いられる. 並列計算を実行するには, 
     ! 実行時に環境変数 OMP_NUM_THREADS を np 以下の数字に設定する等の
     ! システムに応じた準備が必要となる. 
     !
     ! np に 1 より大きな値を指定しなければ並列計算ルーチンは呼ばれない.
     !
     !
     integer,intent(in) :: i              ! 格子点数(経度λ)
     integer,intent(in) :: j              ! 格子点数(緯度φ)
     integer,intent(in) :: k              ! 格子点数(動径 r)
     integer,intent(in) :: n              ! 切断波数(水平全波数)
     integer,intent(in) :: l              ! 切断波数(動径波数)

     real(8),intent(in) :: r              ! 球半径

     integer,intent(in), optional :: np   ! OPENMP での最大スレッド数
     logical,intent(in), optional :: wa_init   ! wa_initial スイッチ

     logical    :: wa_initialize=.true.   ! wa_initial スイッチ

     integer :: nn, mm

     im = i  
      jm = j 
      km = k
     nm = n  
      lm = l
     ra = r

     if ( present(wa_init) ) then
        wa_initialize = wa_init
     else
        wa_initialize = .true.
     endif

     if ( wa_initialize ) then
        if ( present(np) ) then
           call wa_Initial(nm,im,jm,km,np)
        else
           call wa_Initial(nm,im,jm,km)
        endif
     endif

     allocate(nd((nm+1)*(nm+1)))

     do nn=0,nm
        do mm=-nn,nn
           nd(l_nm(nn,mm)) = nn                 ! 水平 n 次は r^n から
        enddo
     enddo

     call aq_Initial(km,lm,ra,alpha,beta,nd)

     allocate(xyr_Lon(0:im-1,1:jm,km))
     allocate(xyr_Lat(0:im-1,1:jm,km))
     allocate(xyr_Rad(0:im-1,1:jm,km))

     allocate(wr_Rad((nm+1)*(nm+1),km))

     xyr_Lon = spread(xy_Lon,3,km)
     xyr_Lat = spread(xy_Lat,3,km)
     xyr_Rad = spread(spread(r_Rad,1,jm),1,im)

     wr_Rad = spread(r_Rad,1,(nm+1)*(nm+1))

    call MessageNotify('M','wu_initial','wu_module (2009/01/09) is initialized')

   end subroutine wq_initial
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002064" class="method-detail">
        <a name="M002064"></a>

        <div class="method-heading">


          <a href="#M002064" class="method-signature">



          <span class="method-name">wq_KxRGrad_wq</span><span class="method-args">( wq ) result(wq_KxRGrad_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002064">wq_KxRGrad_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度微分を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに経度微分 k×r・▽ = ∂/∂λを作用する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002064-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002064-source">
<pre>
    function wq_KxRGrad_wq(wq)
      !
      ! 入力スペクトルデータに経度微分 k×r・▽ = ∂/∂λを作用する.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wq_KxRGrad_wq
      !(out) 経度微分を作用された 2 次元スペクトルデータ

      wq_KxRGrad_wq =  wa_Dlon_wa(wq)

    end function wq_KxRGrad_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002067" class="method-detail">
        <a name="M002067"></a>

        <div class="method-heading">


          <a href="#M002067" class="method-signature">



          <span class="method-name">wq_L2Inv_wq</span><span class="method-args">( wq ) result(wq_L2Inv_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002067">wq_L2Inv_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) L^2 演算子の逆演算を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに L^2 演算子の逆演算(-逆水平ラプラシアン)を 作用する.
</p>
<p>
スペクトルデータに L^2 演算子を作用させる関数 <a
href="wq_module.html#M002066">wq_L2_wq</a> の逆計算を 行う関数である.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002067-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002067-source">
<pre>
    function wq_L2Inv_wq(wq)
      !
      ! 入力スペクトルデータに L^2 演算子の逆演算(-逆水平ラプラシアン)を
      ! 作用する.
      !
      ! スペクトルデータに L^2 演算子を作用させる関数 wq_L2_wq の逆計算を
      ! 行う関数である.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wq_L2Inv_wq
      !(out) L^2 演算子の逆演算を作用された 2 次元スペクトルデータ

      wq_L2Inv_wq = -wa_LaplaInv_wa(wq)

    end function wq_L2Inv_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002066" class="method-detail">
        <a name="M002066"></a>

        <div class="method-heading">


          <a href="#M002066" class="method-signature">



          <span class="method-name">wq_L2_wq</span><span class="method-args">( wq ) result(wq_L2_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002066">wq_L2_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) L^2 演算子を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに L^2 演算子(=-水平ラプラシアン)を作用する.
</p>
<p>
L^2 演算子は単位球面上の水平ラプラシアンの逆符号にあたる.
</p>
<pre>
 入力スペクトルデ ータに対応する格子点データに演算子

    L^2 = -1/cos^2φ・∂^2/∂λ^2 - 1/cosφ・∂/∂φ(cosφ∂/∂φ)
</pre>
<p>
を作用させたデータのスペクトル変換が返される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002066-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002066-source">
<pre>
    function wq_L2_wq(wq)
      !
      ! 入力スペクトルデータに L^2 演算子(=-水平ラプラシアン)を作用する.
      !
      ! L^2 演算子は単位球面上の水平ラプラシアンの逆符号にあたる. 
      !  入力スペクトルデ ータに対応する格子点データに演算子 
      !
      !     L^2 = -1/cos^2φ・∂^2/∂λ^2 - 1/cosφ・∂/∂φ(cosφ∂/∂φ)
      !
      ! を作用させたデータのスペクトル変換が返される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wq_L2_wq
      !(out) L^2 演算子を作用された 2 次元スペクトルデータ

      wq_L2_wq = -wa_Lapla_wa(wq)

    end function wq_L2_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002082" class="method-detail">
        <a name="M002082"></a>

        <div class="method-heading">


          <a href="#M002082" class="method-signature">



          <span class="method-name">wq_LaplaPol2PolTau_wq</span><span class="method-args">( wq, [cond], [new] ) result(wq_LaplaPol2PolTau_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002082">wq_LaplaPol2PolTau_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 出力ポロイダルポテンシャル分布

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力▽^2φ分布

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=1), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件スイッチ. 省略時は &#8216;R&#8216;

<pre>
    R    : 上側粘着条件
    F    : 上側応力なし条件
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
速度ポロイダルポテンシャルΦを▽^2Φから計算する.
</p>
<p>
スペクトル空間で境界条件を適用している(タウ法).
</p>
<p>
速度ポロイダルポテンシャルΦを f = ▽^2Φから定める式は
</p>
<pre>
  ▽^2Φ = f
    Φ = const. at Boundary.
    ∂Φ/∂r = 0 at Boundary           (粘着条件)
    or ∂^2Φ/∂r^2 = 0 at Boundary    (応力なし条件)
</pre>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002082-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002082-source">
<pre>
    function wq_LaplaPol2PolTau_wq(wq,cond,new)
      !
      ! 速度ポロイダルポテンシャルΦを▽^2Φから計算する.
      !
      ! スペクトル空間で境界条件を適用している(タウ法). 
      !
      ! 速度ポロイダルポテンシャルΦを f = ▽^2Φから定める式は
      !
      !   ▽^2Φ = f
      !     Φ = const. at Boundary.
      !     ∂Φ/∂r = 0 at Boundary           (粘着条件) 
      !     or ∂^2Φ/∂r^2 = 0 at Boundary    (応力なし条件)
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(in)  :: wq
              !(in) 入力▽^2φ分布

      real(8), dimension((nm+1)*(nm+1),0:lm)  :: wq_LaplaPol2PolTau_wq
              !(out) 出力ポロイダルポテンシャル分布

      character(len=1), intent(in), optional  :: cond
              !(in) 境界条件スイッチ. 省略時は 'R'
              !     R    : 上側粘着条件
              !     F    : 上側応力なし条件

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:,:), allocatable  :: alu     ! 内部領域計算用
      integer, dimension(:,:), allocatable    :: kp      ! 内部領域計算用

      real(8), dimension(:,:,:), allocatable  :: alub    ! 境界条件計算用
      integer, dimension(:,:), allocatable    :: kpb     ! 境界条件計算用

      real(8), dimension((nm+1)*(nm+1),km)    :: wr_work
      real(8), dimension((nm+1)*(nm+1),0:lm)  :: wq_work
      logical                                 :: rigid   ! 境界条件

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer :: l,n, lend
      save    :: alu, kp, first
      save    :: alub, kpb

      if (.not. present(cond)) then
         rigid=.TRUE. 
      else
         select case (cond)
         case ('R')
            rigid = .TRUE.
         case ('F')
            rigid = .FALSE.
         case default
            call MessageNotify('E','wq_laplapol2pol_wq','B.C. not supported')
         end select
      endif

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         if ( allocated(alub) ) deallocate(alub)
         if ( allocated(kpb) ) deallocate(kpb)
         allocate(alu((nm+1)*(nm+1),0:lm,0:lm),kp((nm+1)*(nm+1),0:lm))
         allocate(alub((nm+1)*(nm+1),0:lm,0:lm),kpb((nm+1)*(nm+1),0:lm))


         !---- 内部領域計算用行列 -----
         do l=0,lm
            wq_work = 0.0
            wq_work(:,l) = 1.0D0
            alu(:,:,l) = wq_Lapla_wq(wq_work)
         enddo

         ! 0 成分のところを 1 で埋める.
         do n=1,(nm+1)**2
            do l=0,nd(n)-1
               alu(n,l,l) = 1.0D0
            enddo
            do l=nd(n)+1,lm,2
               alu(n,l,l) = 1.0D0
            enddo
         enddo

         ! alu(:,:,nd(n)) 列は 0 なので 1 をいれておく. 
         ! l=nd(n) 成分は境界条件で決める. 
         do n=1,(nm+1)**2
            if ( mod(nd(n),2) .eq. mod(lm,2) ) then
               alu(n,lm,nd(n)) = 1.0D0
            else
               alu(n,lm-1,nd(n)) = 1.0D0
            endif
         enddo

         call ludecomp(alu,kp)

         !---- 境界条件計算用行列 -----

         alub = 0.0D0
         do l=0,lm
            alub(:,l,l) = 1.0D0
         enddo

         do l=0,lm
            wq_work=0.0D0 
             wq_work(:,l)=1.0D0
            wr_work = wr_wq(wq_work)

            ! 運動学的条件. 流線は境界で一定
            !     l=nd(n) 成分を境界条件で決める. 
            do n=1,(nm+1)**2
               alub(n,nd(n),l) = wr_work(n,km)
            enddo

            ! 力学的条件粘着条件 
            !     l=lend 成分を境界条件で決める. 
            if ( rigid ) then
               wr_work=wr_wq(wq_RadDRad_wq(wq_work))/wr_Rad
            else
               wr_work=wr_wq(wq_RadDRad_wq(wq_RadDRad_wq(wq_work)) -wq_RadDRad_wq(wq_work) ) /wr_Rad**2
            endif
            
            do n=1,(nm+1)**2
               if ( mod(nd(n),2) .eq. mod(lm,2) ) then
                  lend = lm
               else
                  lend = lm-1
               endif
               alub(n,lend,l) = wr_work(n,km)
            enddo
         enddo

         ! 関係ないところを 0 で埋める.
         do n=1,(nm+1)**2
            if ( mod(nd(n),2) .eq. mod(lm,2) ) then
               lend = lm
            else
               lend = lm-1
            endif

            do l=0,nd(n)-1
               alub(n,nd(n),l) = 0.0D0
               alub(n,lend,l) = 0.0D0
            enddo
            do l=nd(n)+1,lm,2
               alub(n,nd(n),l) = 0.0D0
               alub(n,lend,l) = 0.0D0
            enddo
         enddo

         call ludecomp(alub,kpb)

         if ( rigid ) then
            call MessageNotify('M','wq_LaplaPol2PolTau_wq', 'Matrix to apply rigid b.c. newly produced.')
         else
            call MessageNotify('M','wq_LaplaPol2PolTau_wq', 'Matrix to apply stress-free b.c. newly produced.')
         endif
      endif

      ! 内部領域計算
      wq_work = wq

      wq_work = lusolve(alu,kp,wq_work)

      ! 境界条件計算
      do n=1,(nm+1)**2
         wq_work(n,nd(n)) = 0
         if ( mod(nd(n),2) .eq. mod(lm,2) ) then
            wq_work(n,lm)   = 0
         else
            wq_work(n,lm-1) = 0
         endif
      enddo

      wq_laplapol2polTau_wq = lusolve(alub,kpb,wq_work)

    end function wq_LaplaPol2PolTau_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002089" class="method-detail">
        <a name="M002089"></a>

        <div class="method-heading">




          <span class="method-name">wq_LaplaPol2Pol_wq</span><span class="method-args">( wq, [cond], [new] ) result(wq_LaplaPol2PolTau_wq)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002082">wq_LaplaPol2PolTau_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 出力ポロイダルポテンシャル分布

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力▽^2φ分布

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=1), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件スイッチ. 省略時は &#8216;R&#8216;

<pre>
    R    : 上側粘着条件
    F    : 上側応力なし条件
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
速度ポロイダルポテンシャルΦを▽^2Φから計算する.
</p>
<p>
スペクトル空間で境界条件を適用している(タウ法).
</p>
<p>
速度ポロイダルポテンシャルΦを f = ▽^2Φから定める式は
</p>
<pre>
  ▽^2Φ = f
    Φ = const. at Boundary.
    ∂Φ/∂r = 0 at Boundary           (粘着条件)
    or ∂^2Φ/∂r^2 = 0 at Boundary    (応力なし条件)
</pre>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>
<p>
Alias for <a href="wq_module.html#M002082">wq_LaplaPol2PolTau_wq</a>
</p>


        </div>
      </div>


      <div id="method-M002026" class="method-detail">
        <a name="M002026"></a>

        <div class="method-heading">


          <a href="#M002026" class="method-signature">



          <span class="method-name">wq_Lapla_wq</span><span class="method-args">( wq ) result(wq_Lapla_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002026">wq_Lapla_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ラプラシアンを作用された水平スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータにラプラシアン
</p>
<pre>
    ▽^2 =   1/r^2 cos^2φ・∂^2/∂λ^2
           + 1/r^2 cosφ・∂/∂φ(cosφ∂/∂φ)
           + 1/r^2 ∂/∂r (r^2 ∂/∂r)
             [1/r^2 (r∂/∂r)(r∂/∂r) + 1/r^2(r∂/∂r)]
</pre>
<p>
を作用する.
</p>
<p>
スペクトルデータのラプラシアンとは, 対応する格子点データに
ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002026-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002026-source">
<pre>
    function wq_Lapla_wq(wq)
      ! 入力スペクトルデータにラプラシアン
      !
      !     ▽^2 =   1/r^2 cos^2φ・∂^2/∂λ^2 
      !            + 1/r^2 cosφ・∂/∂φ(cosφ∂/∂φ) 
      !            + 1/r^2 ∂/∂r (r^2 ∂/∂r) 
      !              [1/r^2 (r∂/∂r)(r∂/∂r) + 1/r^2(r∂/∂r)]
      !
      ! を作用する.
      !
      ! スペクトルデータのラプラシアンとは, 対応する格子点データに
      ! ラプラシアンを作用させたデータのスペクトル変換のことである. 
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wq_Lapla_wq
      !(out) ラプラシアンを作用された水平スペクトルデータ

      wq_Lapla_wq = wq_Rad2Inv_wq(  wq_RadDRad_wq(wq_RadDRad_wq(wq)) + wq_RadDRad_wq(wq)+ wa_Lapla_wa(wq) )

    end function wq_Lapla_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002091" class="method-detail">
        <a name="M002091"></a>

        <div class="method-heading">




          <span class="method-name">wq_PolMagBoundary</span><span class="method-args">( wq_POL, [new] ) </span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wq_POL  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
磁場ポロイダルポテンシャルに対して境界条件を適用する. Chebyshev
空間での境界条件適用
</p>
<p>
チェビシェフ空間において境界条件を満たすべく高次の係数を定める方法を
とっている(タウ法). 現在のところ境界物質が非電気伝導体の場合のみ
対応している. その場合, 磁場ポロイダルポテンシャルの各水平スペクトル 成分 h
にたいして境界条件が与えられ,
</p>
<pre>
 * 外側境界 : dh/dr + (n+1)h/r = 0
</pre>
<p>
である. ここで n は h の水平全波数である.
</p>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>
<p>
Alias for <a href="wq_module.html#M002085">wq_PolMagBoundaryTau</a>
</p>


        </div>
      </div>


      <div id="method-M002085" class="method-detail">
        <a name="M002085"></a>

        <div class="method-heading">


          <a href="#M002085" class="method-signature">



          <span class="method-name">wq_PolmagBoundaryTau</span><span class="method-args">( wq_POL, [new] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wq_POL  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
磁場ポロイダルポテンシャルに対して境界条件を適用する. Chebyshev
空間での境界条件適用
</p>
<p>
チェビシェフ空間において境界条件を満たすべく高次の係数を定める方法を
とっている(タウ法). 現在のところ境界物質が非電気伝導体の場合のみ
対応している. その場合, 磁場ポロイダルポテンシャルの各水平スペクトル 成分 h
にたいして境界条件が与えられ,
</p>
<pre>
 * 外側境界 : dh/dr + (n+1)h/r = 0
</pre>
<p>
である. ここで n は h の水平全波数である.
</p>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002085-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002085-source">
<pre>
    subroutine wq_PolmagBoundaryTau(wq_POL,new)
      !
      ! 磁場ポロイダルポテンシャルに対して境界条件を適用する.
      ! Chebyshev 空間での境界条件適用
      !
      ! チェビシェフ空間において境界条件を満たすべく高次の係数を定める方法を
      ! とっている(タウ法). 現在のところ境界物質が非電気伝導体の場合のみ
      ! 対応している. その場合, 磁場ポロイダルポテンシャルの各水平スペクトル
      ! 成分 h にたいして境界条件が与えられ,
      !
      !  * 外側境界 : dh/dr + (n+1)h/r = 0
      !
      ! である. ここで n は h の水平全波数である. 
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)   :: wq_POL
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:,:), allocatable  :: alu
      integer, dimension(:,:), allocatable    :: kp

      real(8), dimension(:,:), allocatable    :: wq_I
      real(8), dimension(:,:), allocatable    :: wr_PSI
      real(8), dimension(:,:), allocatable    :: wr_DPSIDR

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer  :: l, n, nn(2), lend
      save     :: alu, kp, first

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         if ( allocated(wq_I) ) deallocate(wq_I)
         if ( allocated(wr_PSI) ) deallocate(wr_PSI)
         if ( allocated(wr_DPSIDR) ) deallocate(wr_DPSIDR)

         allocate(alu((nm+1)*(nm+1),0:lm,0:lm),kp((nm+1)*(nm+1),0:lm))
         allocate(wq_I((nm+1)*(nm+1),0:lm))
         allocate(wr_PSI((nm+1)*(nm+1),km),wr_DPSIDR((nm+1)*(nm+1),km))

         alu = 0.0D0
         do l=0,lm
            alu(:,l,l) = 1.0D0
         enddo

         ! 非電気伝導体
         do l=0,lm
            wq_I = 0.0D0  
             wq_I(:,l) = 1.0D0
            wr_PSI = wr_wq(wq_I)
            wr_DPSIDR = wr_wq(wq_RadDRad_wq(wq_I))/wr_Rad

            do n=1,(nm+1)**2
               if ( mod(nd(n),2) .eq. mod(lm,2) ) then
                  lend = lm
               else
                  lend = lm-1
               endif
               nn=nm_l(n)
               alu(n,lend,l) = wr_DPSIDR(n,km) + (nn(1)+1) * wr_PSI(n,km)/r_RAD(km)
            enddo
         enddo

         ! 関係ないところを 0 で埋める.
         do n=1,(nm+1)**2
            if ( mod(nd(n),2) .eq. mod(lm,2) ) then
               lend = lm
            else
               lend = lm-1
            endif

            do l=0,nd(n)-1
               alu(n,lend,l) = 0.0D0
            enddo
            do l=nd(n)+1,lm,2
               alu(n,lend,l) = 0.0D0
            enddo
         enddo

         call ludecomp(alu,kp)

         deallocate(wq_I,wr_PSI,wr_DPSIDR)

         call MessageNotify('M','PolmagBoundaryTau', 'Matrix to apply  b.c. newly produced.')
      endif

      do n=1,(nm+1)**2
         if ( mod(nd(n),2) .eq. mod(lm,2) ) then
            wq_POL(n,lm)   = 0.0
         else
            wq_POL(n,lm-1) = 0.0
         endif
      enddo
      wq_POL = lusolve(alu,kp,wq_POL)

    end subroutine wq_PolmagBoundaryTau
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002073" class="method-detail">
        <a name="M002073"></a>

        <div class="method-heading">


          <a href="#M002073" class="method-signature">



          <span class="method-name">wq_Potential2Rotation</span><span class="method-args">( xyr_RotVLON, xyr_RotVLAT, xyr_RotVRAD, wq_TORPOT, wq_POLPOT ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>xyr_RotVLON  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(OUT)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 回転の経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_RotVLAT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(OUT)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 回転の緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_RotVRAD  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(OUT)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 回転の動径成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) トロイダルポテンシャル

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq_POLPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ポロイダルポテンシャル

</td></tr>
</table>
</td></tr>
</table>
<p>
トロイダルポロイダルポテンシャルΨ,Φで表される非発散ベクトル場
</p>
<pre>
    v = ▽x(Ψr) + ▽x▽x(Φr)
</pre>
<p>
に対して, その回転
</p>
<pre>
    ▽xv = ▽x▽x(Ψr) + ▽x▽x▽x(Φr) = ▽x▽x(Ψr) - ▽x((▽^2Φ)r)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002073-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002073-source">
<pre>
    subroutine wq_Potential2Rotation( xyr_RotVLON,xyr_RotVLAT,xyr_RotVRAD,wq_TORPOT,wq_POLPOT)
      !
      ! トロイダルポロイダルポテンシャルΨ,Φで表される非発散ベクトル場
      !
      !     v = ▽x(Ψr) + ▽x▽x(Φr) 
      !
      ! に対して, その回転
      !
      !     ▽xv = ▽x▽x(Ψr) + ▽x▽x▽x(Φr) = ▽x▽x(Ψr) - ▽x((▽^2Φ)r)
      !
      ! を計算する. 
      
      ! ベクトル場の回転
      real(8), dimension(0:im-1,1:jm,km), intent(OUT) :: xyr_RotVLON
      !(out) 回転の経度成分

      real(8), dimension(0:im-1,1:jm,km), intent(OUT) :: xyr_RotVLAT
      !(out) 回転の緯度成分

      real(8), dimension(0:im-1,1:jm,km), intent(OUT) :: xyr_RotVRAD
      !(out) 回転の動径成分

      ! 入力ベクトル場を表すポテンシャル
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq_TORPOT
      !(in) トロイダルポテンシャル

      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq_POLPOT
      !(in) ポロイダルポテンシャル

      call wq_Potential2Vector( xyr_RotVLON,xyr_RotVLAT,xyr_RotVRAD, -wq_Lapla_wq(wq_POLPOT), wq_TORPOT)

    end subroutine wq_Potential2Rotation
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002072" class="method-detail">
        <a name="M002072"></a>

        <div class="method-heading">


          <a href="#M002072" class="method-signature">



          <span class="method-name">wq_Potential2Vector</span><span class="method-args">( xyr_VLON, xyr_VLAT, xyr_VRAD, wq_TORPOT, wq_POLPOT ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>xyr_VLON  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_VLAT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_VRAD  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の動径成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) トロイダルポテンシャル

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq_POLPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ポロイダルポテンシャル

</td></tr>
</table>
</td></tr>
</table>
<p>
トロイダルポロイダルポテンシャルΨ,Φで表される非発散ベクトル場
</p>
<pre>
    v = ▽x(Ψr) + ▽x▽x(Φr)
</pre>
<p>
の各成分を計算する
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002072-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002072-source">
<pre>
    subroutine wq_Potential2Vector( xyr_VLON,xyr_VLAT,xyr_VRAD,wq_TORPOT,wq_POLPOT)
      !
      ! トロイダルポロイダルポテンシャルΨ,Φで表される非発散ベクトル場
      !
      !     v = ▽x(Ψr) + ▽x▽x(Φr) 
      !
      ! の各成分を計算する
      !
      real(8), dimension(0:im-1,1:jm,km)     :: xyr_VLON
      !(out) ベクトル場の経度成分

      real(8), dimension(0:im-1,1:jm,km)     :: xyr_VLAT
      !(out) ベクトル場の緯度成分

      real(8), dimension(0:im-1,1:jm,km)     :: xyr_VRAD
      !(out) ベクトル場の動径成分

      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq_TORPOT
      !(in) トロイダルポテンシャル

      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq_POLPOT
      !(in) ポロイダルポテンシャル

      xyr_VLON =   xyr_RAD * xyr_GradLat_wq(wq_TORPOT) + xya_GradLon_wa(wr_RotDRad_wq(wq_POLPOT))
      xyr_VLAT = - xyr_RAD * xyr_GradLon_wq(wq_TORPOT) + xya_GradLat_wa(wr_RotDRad_wq(wq_POLPOT))
      xyr_VRAD = xyr_wq(wq_L2_wq(wq_POLPOT))/xyr_RAD

    end subroutine wq_Potential2Vector
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002068" class="method-detail">
        <a name="M002068"></a>

        <div class="method-heading">


          <a href="#M002068" class="method-signature">



          <span class="method-name">wq_QOperator_wq</span><span class="method-args">( wq ) result(wq_QOperator_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002068">wq_QOperator_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) Q 演算子を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに対応する格子点データに演算子
</p>
<pre>
   Q=(k・▽-1/2(L2 k・▽+ k・▽L2))
</pre>
<p>
を作用させたデータのスペクトル変換が返される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002068-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002068-source">
<pre>
    function wq_QOperator_wq(wq)
      !
      ! 入力スペクトルデータに対応する格子点データに演算子 
      !
      !    Q=(k・▽-1/2(L2 k・▽+ k・▽L2)) 
      !
      ! を作用させたデータのスペクトル変換が返される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wq_QOperator_wq
      !(out) Q 演算子を作用された 2 次元スペクトルデータ

      wq_QOperator_wq = wq_xyr(xyr_KGrad_wq(wq) - xyr_KGrad_wq(wq_L2_wq(wq))/2) - wq_L2_wq(wq_xyr(xyr_KGrad_wq(wq)))/2

    end function wq_QOperator_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002112" class="method-detail">
        <a name="M002112"></a>

        <div class="method-heading">




          <span class="method-name">wq_Rad2Inv_wq</span><span class="method-args">( aq_data ) result(aq_r2Inv_aq)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>aq_r2Inv_aq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(aq_data,1),0:size(aq_data,2)-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 出力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに対して積 r^-2 のスペクトル係数 を計算する(2
次元配列用).
</p>
<pre>
  a_n^m = aq_r2Inv_aq/sqrt(Inm),  b_n^m = aq_data/sqrt(Inm)

  b_n^m = (n-|m|)(n+|m|+beta-1)/((2n+gamma-5)(2n+gamma-3)) a_n-2^m
      + (2n(n+gamma-1) + 2|m|(|m|+beta-1)+(gamma-3)(beta+1)
           /((2n+gamma+1)(2n+gamma-3)) a_n^m
      + (n-|m|+gamma-beta)(n+|m|+gamma-1)
           /((2n+gamma+3)(2n+gamma+1)) a_n+2^m
</pre>
<p>
Original external subprogram is <a
href="aq_module.html#M001992">aq_module#aq_r2Inv_aq</a>
</p>


        </div>
      </div>


      <div id="method-M002110" class="method-detail">
        <a name="M002110"></a>

        <div class="method-heading">




          <span class="method-name">wq_Rad2_wq</span><span class="method-args">( aq_data ) result(aq_r2_aq)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>aq_r2_aq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(aq_data,1),0:size(aq_data,2)-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 出力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに対して積 r^2 のスペクトル係数 を計算する(2
次元配列用).
</p>
<pre>
  a_n^m = aq_data/sqrt(Inm),  b_n^m = aq_rDr_aq/sqrt(Inm)

  b_n^m = (n-|m|)(n+|m|+beta-1)/((2n+gamma-5)(2n+gamma-3)) a_n-2^m
      + (2n(n+gamma-1) + 2|m|(|m|+beta-1)+(gamma-3)(beta+1)
           /((2n+gamma+1)(2n+gamma-3)) a_n^m
      + (n-|m|+gamma-beta)(n+|m|+gamma-1)
           /((2n+gamma+3)(2n+gamma+1)) a_n+2^m
</pre>
<p>
Original external subprogram is <a
href="aq_module.html#M001990">aq_module#aq_r2_aq</a>
</p>


        </div>
      </div>


      <div id="method-M002108" class="method-detail">
        <a name="M002108"></a>

        <div class="method-heading">




          <span class="method-name">wq_RadDRad_wq</span><span class="method-args">( aq_data ) result(aq_rDr_aq)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>aq_rDr_aq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(aq_data,1),0:size(aq_data,2)-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 出力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>aq_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに対して微分 r(d/dr) のスペクトル係数 を計算する(2
次元配列用).
</p>
<pre>
  a_n = aq_data/sqrt(Inm),  b_n = aq_rDr_aq/sqrt(Inm)

  b_n = (2n+gamma-1)/(2n+gamma+3)b_n+2
      + (2n+gamma-1)(n+gamma+1)/(2n+gamma+3)a_n+2 + n a_n
</pre>
<p>
Original external subprogram is <a
href="aq_module.html#M001988">aq_module#aq_rDr_aq</a>
</p>


        </div>
      </div>


      <div id="method-M002071" class="method-detail">
        <a name="M002071"></a>

        <div class="method-heading">


          <a href="#M002071" class="method-signature">



          <span class="method-name">wq_RadRotRot_xyr_xyr_xyr</span><span class="method-args">( xyr_VLON, xyr_VLAT, xyr_VRAD ) result(wq_RadRotRot_xyr_xyr_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002071">wq_RadRotRot_xyr_xyr_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル v の r・(▽×▽×v)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_VLON  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトルの経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_VLAT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトルの緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_VRAD  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトルの動径成分

</td></tr>
</table>
</td></tr>
</table>
<p>
ベクトル v に対して r・(▽×▽×v) を計算する.
</p>
<p>
第 1, 2, 3 引数(v[λ], v[φ], v[r])がそれぞれベクトルの経度成分, 緯度成分,
動径成分を表す.
</p>
<pre>
   r・(▽×▽×v)  = 1/r ∂/∂r (r・( 1/cosφ・∂v[λ]/∂λ
                                 + 1/cosφ・∂(v[φ] cosφ)/∂φ ) )
                    + L^2 v[r]/r
</pre>
<p>
のスペクトルデータが返される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002071-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002071-source">
<pre>
    function wq_RadRotRot_xyr_xyr_xyr(xyr_VLON,xyr_VLAT,xyr_VRAD) 
      ! 
      ! ベクトル v に対して r・(▽×▽×v) を計算する.
      !
      ! 第 1, 2, 3 引数(v[λ], v[φ], v[r])がそれぞれベクトルの経度成分, 
      ! 緯度成分, 動径成分を表す. 
      !
      !    r・(▽×▽×v)  = 1/r ∂/∂r (r・( 1/cosφ・∂v[λ]/∂λ 
      !                                  + 1/cosφ・∂(v[φ] cosφ)/∂φ ) ) 
      !                     + L^2 v[r]/r 
      !
      ! のスペクトルデータが返される.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_VLON
      !(in) ベクトルの経度成分

      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_VLAT
      !(in) ベクトルの緯度成分

      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_VRAD
      !(in) ベクトルの動径成分

      real(8), dimension((nm+1)*(nm+1),0:lm)     :: wq_RadRotRot_xyr_xyr_xyr
      !(out) ベクトル v の r・(▽×▽×v) 

      wq_RadRotRot_xyr_xyr_xyr = wq_RotDRad_wr( wa_DivLon_xya(xyr_VLON)+ wa_DivLat_xya(xyr_VLAT)) - wa_Lapla_wa(wq_xyr(xyr_VRAD/xyr_RAD))

    end function wq_RadRotRot_xyr_xyr_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002025" class="method-detail">
        <a name="M002025"></a>

        <div class="method-heading">


          <a href="#M002025" class="method-signature">



          <span class="method-name">wq_RotDRad_wr</span><span class="method-args">( wr ) result(wq_RotDRad_wr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002025">wq_RotDRad_wr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 回転型動径微分を作用された水平スペクトル動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに回転型動径微分
</p>
<pre>
     1/r ∂(r.)/∂r = ∂(.)/∂r + (.)/r
</pre>
<p>
を作用する.
</p>
<p>
スペクトルデータの回転型動径微分とは, 対応する格子点データに
回転型動径微分を作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002025-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002025-source">
<pre>
    function wq_RotDRad_wr(wr)
      !
      ! 入力スペクトルデータに回転型動径微分
      !
      !      1/r ∂(r.)/∂r = ∂(.)/∂r + (.)/r
      !
      ! を作用する.
      !
      ! スペクトルデータの回転型動径微分とは, 対応する格子点データに
      ! 回転型動径微分を作用させたデータのスペクトル変換のことである. 
      !
      real(8), dimension((nm+1)*(nm+1),km), intent(in) :: wr
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)               :: wq_RotDRad_wr
      !(out) 回転型動径微分を作用された水平スペクトル動径格子点データ

      wq_RotDRad_wr = wq_Rad2Inv_wq(wq_RadDRad_wq(wq_wr(wr*wr_Rad)))

    end function wq_RotDRad_wr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002088" class="method-detail">
        <a name="M002088"></a>

        <div class="method-heading">




          <span class="method-name">wq_TorBoundary</span><span class="method-args">( wq_TORPOT, [value], [cond], [new] ) </span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wq_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1)), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 両端境界でのトロイダルポテンシャル

<pre>
    粘着条件の時のみ有効
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=1), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件スイッチ. 省略時は &#8216;R&#8216;

<pre>
    R    : 上側粘着条件
    F    : 上側応力なし条件
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
速度トロイダルポテンシャルに対して境界条件を適用する. Chebyshev
空間での境界条件適用.
</p>
<p>
速度トロイダルポテンシャルΨに対して与えられる境界条件は
</p>
<pre>
  * 粘着条件 : Ψ = Ψb(lon,lat). Ψb は境界球面での速度分布.
                                  default は 0(静止状態).

  * 応力なし条件 : ∂(Ψ/r)/∂r = 0.
</pre>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>
<p>
Alias for <a href="wq_module.html#M002080">wq_TorBoundaryTau</a>
</p>


        </div>
      </div>


      <div id="method-M002080" class="method-detail">
        <a name="M002080"></a>

        <div class="method-heading">


          <a href="#M002080" class="method-signature">



          <span class="method-name">wq_TorBoundaryTau</span><span class="method-args">( wq_TORPOT, [value], [cond], [new] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wq_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1)), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 両端境界でのトロイダルポテンシャル

<pre>
    粘着条件の時のみ有効
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=1), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件スイッチ. 省略時は &#8216;R&#8216;

<pre>
    R    : 上側粘着条件
    F    : 上側応力なし条件
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
速度トロイダルポテンシャルに対して境界条件を適用する. Chebyshev
空間での境界条件適用.
</p>
<p>
速度トロイダルポテンシャルΨに対して与えられる境界条件は
</p>
<pre>
  * 粘着条件 : Ψ = Ψb(lon,lat). Ψb は境界球面での速度分布.
                                  default は 0(静止状態).

  * 応力なし条件 : ∂(Ψ/r)/∂r = 0.
</pre>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002080-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002080-source">
<pre>
    subroutine wq_TorBoundaryTau(wq_TORPOT,value,cond,new) 
      !
      ! 速度トロイダルポテンシャルに対して境界条件を適用する. 
      ! Chebyshev 空間での境界条件適用. 
      !
      ! 速度トロイダルポテンシャルΨに対して与えられる境界条件は
      !
      !   * 粘着条件 : Ψ = Ψb(lon,lat). Ψb は境界球面での速度分布. 
      !                                   default は 0(静止状態).
      !
      !   * 応力なし条件 : ∂(Ψ/r)/∂r = 0.
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)      :: wq_TORPOT
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      real(8), dimension((nm+1)*(nm+1)), intent(in), optional :: value
              !(in) 両端境界でのトロイダルポテンシャル
              !     粘着条件の時のみ有効

      character(len=1), intent(in), optional  :: cond
              !(in) 境界条件スイッチ. 省略時は 'R'
              !     R    : 上側粘着条件
              !     F    : 上側応力なし条件

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:,:), allocatable  :: alu
      integer, dimension(:,:), allocatable    :: kp
      real(8), dimension((nm+1)*(nm+1),0:lm)  :: wq_data
      real(8), dimension((nm+1)*(nm+1),km)    :: wr_data
      logical                                 :: rigid        ! 境界条件

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer :: n, l, lend
      save    :: alu, kp, first

      if (.not. present(cond)) then
         rigid=.TRUE.
      else
         select case (cond)
         case ('R')
            rigid = .TRUE.
         case ('F')
            rigid = .FALSE.
         case default
            call MessageNotify('E','wq_TorBoundaryTau','B.C. not supported')
         end select
      endif

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         allocate(alu((nm+1)*(nm+1),0:lm,0:lm),kp((nm+1)*(nm+1),0:lm))

         alu = 0.0D0
         do l=0,lm
            alu(:,l,l)=1.0D0
         enddo

         ! 力学的条件

         do l=0,lm
            wq_data = 0.0 
             wq_data(:,l) = 1.0D0

            if ( rigid ) then          ! 力学的条件粘着
               wr_data = wr_wq(wq_data)
            else                       ! 力学的条件自由すべり
               wr_data = wr_wq(wq_RadDRad_wq(wq_data)- wq_data)/wr_Rad
            endif

            do n=1,(nm+1)**2
               if ( mod(nd(n),2) .eq. mod(lm,2) ) then
                  alu(n,lm,l) = wr_data(n,km)
               else
                  alu(n,lm-1,l) = wr_data(n,km)
               endif
            end do
         enddo

         ! 関係ないところを 0 で埋める.
         do n=1,(nm+1)**2
            if ( mod(nd(n),2) .eq. mod(lm,2) ) then
               lend = lm
            else
               lend = lm-1
            endif

            do l=0,nd(n)-1
               alu(n,lend,l) = 0.0D0
            enddo
            do l=nd(n)+1,lm,2
               alu(n,lend,l) = 0.0D0
            enddo
         enddo

         call ludecomp(alu,kp)

         if ( rigid .AND. present(value) ) then 
            call MessageNotify('M','wq_TorBoundaryTau', 'Toroidal potential at k=km was given by the optional variable.')
         else if ( rigid .AND. (.NOT.present(value)) ) then
            call MessageNotify('M','wq_TorBoundaryTau', 'Toroidal potential at k=km was set to zero.')
         else if ( (.NOT. rigid) .AND. present(value) ) then
            call MessageNotify('W','wq_TorBoundaryTau', 'Boundary value k=km cannot be set under stress-free condition.')
         endif

         call MessageNotify('M','wq_TorBoundaryTau', 'Matrix to apply  b.c. newly produced.')
      endif

      do n=1,(nm+1)**2
         if ( mod(nd(n),2) .eq. mod(lm,2) ) then
            lend = lm
         else
            lend = lm-1
         endif

         if ( rigid .AND. present(value) ) then
            wq_torpot(n,lend) = value(n)
         else
            wq_torpot(n,lend) = 0.0D0
         endif
      enddo

      wq_torpot = lusolve(alu,kp,wq_TORPOT)

    end subroutine wq_TorBoundaryTau
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002090" class="method-detail">
        <a name="M002090"></a>

        <div class="method-heading">




          <span class="method-name">wq_TorMagBoundary</span><span class="method-args">( wq_TOR, [new] ) </span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wq_TOR  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
Alias for <a href="wq_module.html#M002083">wq_TorMagBoundaryTau</a>
</p>


        </div>
      </div>


      <div id="method-M002083" class="method-detail">
        <a name="M002083"></a>

        <div class="method-heading">


          <a href="#M002083" class="method-signature">



          <span class="method-name">wq_TormagBoundaryTau</span><span class="method-args">( wq_TOR, [new] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wq_TOR  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002083-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002083-source">
<pre>
    subroutine wq_TormagBoundaryTau(wq_TOR,new)
      
      ! 磁場トロイダルポテンシャルに対して境界条件を適用する.
      ! Chebyshev 空間での境界条件適用
      !
      ! チェビシェフ空間において境界条件を満たすべく高次の係数を定める方法を
      ! とっている(タウ法). 現在のところ境界物質が非電気伝導体の場合のみ
      ! 対応している. その場合, 磁場トロイダルポテンシャルの境界条件は
      !
      ! 外側
      !    wq_psi = 0   at the outer boundary
      ! 
      ! であるから wq_Boundary で対応可能だが, 将来のため別途作成しておく.
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)   :: wq_TOR
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:,:), allocatable  :: alu
      integer, dimension(:,:), allocatable    :: kp

      real(8), dimension(:,:), allocatable    :: wq_I
      real(8), dimension(:,:), allocatable    :: wr_PSI

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer :: n, l, lend
      save    :: alu, kp, first

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         if ( allocated(wq_I) ) deallocate(wq_I)
         if ( allocated(wr_PSI) ) deallocate(wr_PSI)
         allocate(alu((nm+1)*(nm+1),0:lm,0:lm),kp((nm+1)*(nm+1),0:lm))
         allocate(wq_I((nm+1)*(nm+1),0:lm),wr_PSI((nm+1)*(nm+1),km))

         alu = 0.0D0
         do l=0,lm
            alu(:,l,l) = 1.0D0
         enddo

         do l=0,lm
            wq_I = 0.0 
             wq_I(:,l) = 1.0
            ! 非電気伝導体
            wr_PSI = wr_wq(wq_I)

            do n=1,(nm+1)**2
               if ( mod(nd(n),2) .eq. mod(lm,2) ) then
                  alu(n,lm,l) = wr_Psi(n,km)
                  lend = lm
               else
                  alu(n,lm-1,l) = wr_Psi(n,km)
               endif
            enddo
         enddo

         ! 関係ないところを 0 で埋める.
         do n=1,(nm+1)**2
            if ( mod(nd(n),2) .eq. mod(lm,2) ) then
               lend = lm
            else
               lend = lm-1
            endif

            do l=0,nd(n)-1
               alu(n,lend,l) = 0.0D0
            enddo
            do l=nd(n)+1,lm,2
               alu(n,lend,l) = 0.0D0
            enddo
         enddo

         call ludecomp(alu,kp)

         deallocate(wq_I,wr_PSI)

         call MessageNotify('M','TormagBoundaryTau', 'Matrix to apply  b.c. newly produced.')
      endif

      do n=1,(nm+1)**2
         if ( mod(nd(n),2) .eq. mod(lm,2) ) then
            wq_TOR(n,lm)   = 0.0
         else
            wq_TOR(n,lm-1) = 0.0
         endif
      enddo
      wq_TOR = lusolve(alu,kp,wq_TOR)

    end subroutine wq_TormagBoundaryTau
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002014" class="method-detail">
        <a name="M002014"></a>

        <div class="method-heading">




          <span class="method-name">wq_VMiss</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002014">wq_VMiss</a>  </tt></b>  <tt> = -999.0        </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 欠損値

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M002021" class="method-detail">
        <a name="M002021"></a>

        <div class="method-heading">


          <a href="#M002021" class="method-signature">



          <span class="method-name">wq_wr</span><span class="method-args">( wr ) result(wq_wr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002021">wq_wr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数スペクトル・動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
水平スペクトル・動径格子点データからスペクトルデータへ(正)変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002021-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002021-source">
<pre>
    function wq_wr(wr)
      !
      ! 水平スペクトル・動径格子点データからスペクトルデータへ(正)変換する.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm) :: wq_wr
      !(out) 2 次元球面調和函数チェビシェフスペクトルデータ
      real(8), dimension((nm+1)*(nm+1),km), intent(in) :: wr
      !(in) 2 次元球面調和函数スペクトル・動径格子点データ

      wq_wr = aq_ar(wr)
      
    end function wq_wr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002017" class="method-detail">
        <a name="M002017"></a>

        <div class="method-heading">


          <a href="#M002017" class="method-signature">



          <span class="method-name">wq_xyr</span><span class="method-args">( xyr ) result(wq_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002017">wq_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
3 次元格子点データからスペクトルデータへ(正)変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002017-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002017-source">
<pre>
    function wq_xyr(xyr)
      !
      ! 3 次元格子点データからスペクトルデータへ(正)変換する.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wq_xyr
      !(out) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension(0:im-1,1:jm,km), intent(in)           :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      wq_xyr = wq_wr(wa_xya(xyr))

    end function wq_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002079" class="method-detail">
        <a name="M002079"></a>

        <div class="method-heading">


          <a href="#M002079" class="method-signature">



          <span class="method-name">wr_BoundaryGrid</span><span class="method-args">( wr, [value], [cond] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1)), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界での 値/勾配 分布を水平スペクトル変換したものを与える.

<pre>
   省略時は値/勾配 0 となる.
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=1), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件. 省略時は &#8216;D&#8216;

<pre>
       D : 外側ディリクレ条件
       N : 外側ノイマン条件
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータにディリクレ・ノイマン境界条件を適用する
実空間での境界条件適用
</p>
<p>
鉛直実格子点空間において内部領域の値と境界条件を満たすように
条件を課している(選点法).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002079-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002079-source">
<pre>
    subroutine wr_BoundaryGrid(wr,value,cond)
      !
      ! スペクトルデータにディリクレ・ノイマン境界条件を適用する
      ! 実空間での境界条件適用
      !
      ! 鉛直実格子点空間において内部領域の値と境界条件を満たすように
      ! 条件を課している(選点法). 
      !
      real(8), dimension((nm+1)*(nm+1),km),intent(inout)      :: wr
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      real(8), dimension((nm+1)*(nm+1)), intent(in), optional   :: value
              !(in) 境界での 値/勾配 分布を水平スペクトル変換したものを与える. 
              !    省略時は値/勾配 0 となる. 

      character(len=1), intent(in), optional             :: cond
              !(in) 境界条件. 省略時は 'D'
              !        D : 外側ディリクレ条件
              !        N : 外側ノイマン条件

      if (.not. present(cond)) then
         if (present(value)) then
            call ag_BoundaryGrid_D(wr,value)
         else
            call ag_BoundaryGrid_D(wr)
         endif
         return
      endif

      select case(cond)
      case ('N')
         if (present(value)) then
            call ag_BoundaryGrid_N(wr,value)
         else
            call ag_BoundaryGrid_N(wr)
         endif
      case ('D')
         if (present(value)) then
            call ag_BoundaryGrid_D(wr,value)
         else
            call ag_BoundaryGrid_D(wr)
         endif
      case default
         call MessageNotify('E','wr_BoundaryGrid','B.C. not supported')
      end select

    end subroutine wr_BoundaryGrid
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002030" class="method-detail">
        <a name="M002030"></a>

        <div class="method-heading">


          <a href="#M002030" class="method-signature">



          <span class="method-name">wr_DivLat_xyr</span><span class="method-args">( xyr ) result(wr_DivLat_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002030">wr_DivLat_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 発散型緯度微分を作用された水平スペクトル動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子データに発散型緯度微分 1/rcosφ・∂(f cosφ)/∂φ を
作用させたスペクトルデータを返す.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002030-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002030-source">
<pre>
    function wr_DivLat_xyr(xyr)
      !
      ! 格子データに発散型緯度微分 1/rcosφ・∂(f cosφ)/∂φ を
      ! 作用させたスペクトルデータを返す.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in)     :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension((nm+1)*(nm+1),km)         :: wr_DivLat_xyr
      !(out) 発散型緯度微分を作用された水平スペクトル動径格子点データ

      wr_DivLat_xyr = wa_DivLat_xya(xyr/xyr_Rad)

    end function wr_DivLat_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002029" class="method-detail">
        <a name="M002029"></a>

        <div class="method-heading">


          <a href="#M002029" class="method-signature">



          <span class="method-name">wr_DivLon_xyr</span><span class="method-args">( xyr ) result(wr_DivLon_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002029">wr_DivLon_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 発散型経度微分を作用された水平スペクトル動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型経度微分 1/rcosφ・∂/∂λ を作用させた
スペクトルデータを返す.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002029-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002029-source">
<pre>
    function wr_DivLon_xyr(xyr)
      ! 
      ! 格子点データに発散型経度微分 1/rcosφ・∂/∂λ を作用させた
      ! スペクトルデータを返す.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in)     :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension((nm+1)*(nm+1),km)         :: wr_DivLon_xyr
      !(out) 発散型経度微分を作用された水平スペクトル動径格子点データ

      wr_DivLon_xyr = wa_DivLon_xya(xyr/xyr_Rad)

    end function wr_DivLon_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002022" class="method-detail">
        <a name="M002022"></a>

        <div class="method-heading">


          <a href="#M002022" class="method-signature">



          <span class="method-name">wr_DivRad_wq</span><span class="method-args">( wq ) result(wr_DivRad_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002022">wr_DivRad_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 発散型動径微分を作用された水平スペクトル動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに発散型動径微分
</p>
<pre>
      1/r^2 ∂/∂r (r^2 .)= ∂/∂r + 2/r
</pre>
<p>
を作用する.
</p>
<p>
スペクトルデータの発散型動径微分とは, 対応する格子点データに
発散型動径微分を作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002022-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002022-source">
<pre>
    function wr_DivRad_wq(wq)
      ! 
      ! 入力スペクトルデータに発散型動径微分
      !
      !       1/r^2 ∂/∂r (r^2 .)= ∂/∂r + 2/r
      !
      ! を作用する.
      !
      ! スペクトルデータの発散型動径微分とは, 対応する格子点データに
      ! 発散型動径微分を作用させたデータのスペクトル変換のことである. 
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),km)             :: wr_DivRad_wq
      !(out) 発散型動径微分を作用された水平スペクトル動径格子点データ

      wr_DivRad_wq = wr_wq(wq_RadDRad_wq(wq))/wr_Rad + 2/wr_Rad * wr_wq(wq)

    end function wr_DivRad_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002031" class="method-detail">
        <a name="M002031"></a>

        <div class="method-heading">


          <a href="#M002031" class="method-signature">



          <span class="method-name">wr_Div_xyr_xyr_xyr</span><span class="method-args">( xyr_Vlon, xyr_Vlat, xyr_Vrad ) result(wr_Div_xyr_xyr_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002031">wr_Div_xyr_xyr_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の発散

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_Vlon  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_Vlat  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_Vrad  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の動径成分

</td></tr>
</table>
</td></tr>
</table>
<p>
べクトル成分である 3 つの格子データに発散を作用させた
スペクトルデータを返す.
</p>
<p>
第 1, 2 ,3 引数(u,v,w)がそれぞれベクトルの経度成分, 緯度成分,
動径成分を表し, 発散は
</p>
<pre>
     1/rcosφ・∂u/∂λ + 1/rcosφ・∂(v cosφ)/∂φ
   + 1/r^2 ∂/∂r (r^2 w)
</pre>
<p>
と計算される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002031-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002031-source">
<pre>
    function wr_Div_xyr_xyr_xyr(xyr_Vlon,xyr_Vlat,xyr_Vrad)
      !
      ! べクトル成分である 3 つの格子データに発散を作用させた
      ! スペクトルデータを返す.
      !
      ! 第 1, 2 ,3 引数(u,v,w)がそれぞれベクトルの経度成分, 緯度成分, 
      ! 動径成分を表し, 発散は 
      !
      !      1/rcosφ・∂u/∂λ + 1/rcosφ・∂(v cosφ)/∂φ 
      !    + 1/r^2 ∂/∂r (r^2 w)
      !
      ! と計算される.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_Vlon
      !(in) ベクトル場の経度成分

      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_Vlat
      !(in) ベクトル場の緯度成分

      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_Vrad
      !(in) ベクトル場の動径成分

      real(8), dimension((nm+1)*(nm+1),km)     :: wr_Div_xyr_xyr_xyr
      !(out) ベクトル場の発散

      wr_Div_xyr_xyr_xyr =   wr_DivLon_xyr(xyr_Vlon) + wr_DivLat_xyr(xyr_Vlat) + wr_DivRad_wq(wq_xyr(xyr_Vrad))

    end function wr_Div_xyr_xyr_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002086" class="method-detail">
        <a name="M002086"></a>

        <div class="method-heading">


          <a href="#M002086" class="method-signature">



          <span class="method-name">wr_PolmagBoundaryGrid</span><span class="method-args">( wr_POL, [new] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wr_POL  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
磁場ポロイダルポテンシャルに対して境界条件を適用する.
鉛直実空間での境界条件適用.
</p>
<p>
鉛直実格子点空間において内部領域の値と境界条件を満たすように
条件を課している(選点法).
</p>
<p>
現在のところ境界物質が非電気伝導体の場合のみ対応している. その場合,
磁場ポロイダルポテンシャルの各水平スペクトル成分 h に
たいして境界条件が与えられ,
</p>
<pre>
 * 外側境界 : dh/dr + (n+1)h/r = 0
</pre>
<p>
である. ここで n は h の水平全波数である.
</p>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002086-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002086-source">
<pre>
    subroutine wr_PolmagBoundaryGrid(wr_POL,new)
      !
      ! 磁場ポロイダルポテンシャルに対して境界条件を適用する.
      ! 鉛直実空間での境界条件適用. 
      !
      ! 鉛直実格子点空間において内部領域の値と境界条件を満たすように
      ! 条件を課している(選点法). 
      !
      ! 現在のところ境界物質が非電気伝導体の場合のみ対応している. 
      ! その場合, 磁場ポロイダルポテンシャルの各水平スペクトル成分 h に
      ! たいして境界条件が与えられ,
      !
      !  * 外側境界 : dh/dr + (n+1)h/r = 0
      !
      ! である. ここで n は h の水平全波数である. 
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),km),intent(inout)   :: wr_POL
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:,:), allocatable  :: alu
      integer, dimension(:,:), allocatable    :: kp

      real(8), dimension(:,:), allocatable    :: wr_I
      real(8), dimension(:,:), allocatable    :: wr_PSI
      real(8), dimension(:,:), allocatable    :: wr_DPSIDR

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer  :: k, n, nn(2)
      save     :: alu, kp, first

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         if ( allocated(wr_I) ) deallocate(wr_I)
         if ( allocated(wr_PSI) ) deallocate(wr_PSI)
         if ( allocated(wr_DPSIDR) ) deallocate(wr_DPSIDR)

         allocate(alu((nm+1)*(nm+1),km,km),kp((nm+1)*(nm+1),km))
         allocate(wr_I((nm+1)*(nm+1),km))
         allocate(wr_PSI((nm+1)*(nm+1),km),wr_DPSIDR((nm+1)*(nm+1),km))

         do k=1,km
            wr_I = 0.0D0
            wr_I(:,k)=1.0D0
            alu(:,:,k) = wr_I                 ! 内部領域は値そのまま.
         enddo

         ! 非電気伝導体
         do k=1,km
            wr_I = 0.0D0
            wr_I(:,k) = 1.0D0
            wr_PSI = wr_I
            wr_DPSIDR = wr_wq(wq_RadDRad_wq(wq_wr(wr_I)))/wr_Rad

            do n=1,(nm+1)*(nm+1)
               nn=nm_l(n)
               alu(n,km,k) = wr_DPSIDR(n,km) + (nn(1)+1) * wr_PSI(n,km)/r_RAD(km)
            enddo
         end do

         call ludecomp(alu,kp)

         deallocate(wr_I,wr_PSI,wr_DPSIDR)

         call MessageNotify('M','PolmagBoundaryGrid', 'Matrix to apply  b.c. newly produced.')
      endif

      wr_POL(:,km)  = 0.0D0
      wr_POL = lusolve(alu,kp,wr_POL)

    end subroutine wr_PolmagBoundaryGrid
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002013" class="method-detail">
        <a name="M002013"></a>

        <div class="method-heading">




          <span class="method-name">wr_RAD</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002013">wr_RAD</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M002070" class="method-detail">
        <a name="M002070"></a>

        <div class="method-heading">


          <a href="#M002070" class="method-signature">



          <span class="method-name">wr_RadRotRot_xyr_xyr_xyr</span><span class="method-args">( xyr_VLON, xyr_VLAT, xyr_VRAD ) result(wr_RadRotRot_xyr_xyr_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002070">wr_RadRotRot_xyr_xyr_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル v の r・(▽×▽×v)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_VLON  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトルの経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_VLAT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトルの緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_VRAD  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトルの動径成分

</td></tr>
</table>
</td></tr>
</table>
<p>
ベクトル v に対して r・(▽×▽×v) を計算する.
</p>
<p>
第 1, 2, 3 引数(v[λ], v[φ], v[r])がそれぞれベクトルの経度成分, 緯度成分,
動径成分を表す.
</p>
<pre>
   r・(▽×▽×v)  = 1/r ∂/∂r (r・( 1/cosφ・∂v[λ]/∂λ
                                 + 1/cosφ・∂(v[φ] cosφ)/∂φ ) )
                    + L^2 v[r]/r
</pre>
<p>
のスペクトルデータが返される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002070-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002070-source">
<pre>
    function wr_RadRotRot_xyr_xyr_xyr(xyr_VLON,xyr_VLAT,xyr_VRAD) 
      ! 
      ! ベクトル v に対して r・(▽×▽×v) を計算する.
      !
      ! 第 1, 2, 3 引数(v[λ], v[φ], v[r])がそれぞれベクトルの経度成分, 
      ! 緯度成分, 動径成分を表す. 
      !
      !    r・(▽×▽×v)  = 1/r ∂/∂r (r・( 1/cosφ・∂v[λ]/∂λ 
      !                                  + 1/cosφ・∂(v[φ] cosφ)/∂φ ) ) 
      !                     + L^2 v[r]/r 
      !
      ! のスペクトルデータが返される.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_VLON
      !(in) ベクトルの経度成分

      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_VLAT
      !(in) ベクトルの緯度成分

      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_VRAD
      !(in) ベクトルの動径成分

      real(8), dimension((nm+1)*(nm+1),km)     :: wr_RadRotRot_xyr_xyr_xyr
      !(out) ベクトル v の r・(▽×▽×v) 

      wr_RadRotRot_xyr_xyr_xyr = wr_RotDRad_wr( wa_DivLon_xya(xyr_VLON)+ wa_DivLat_xya(xyr_VLAT)) - wa_Lapla_wa(wr_xyr(xyr_VRAD/xyr_RAD))

    end function wr_RadRotRot_xyr_xyr_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002069" class="method-detail">
        <a name="M002069"></a>

        <div class="method-heading">


          <a href="#M002069" class="method-signature">



          <span class="method-name">wr_RadRot_xyr_xyr</span><span class="method-args">( xyr_VLON, xyr_VLAT ) result(wr_RadRot_xyr_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002069">wr_RadRot_xyr_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトルの渦度と動径ベクトルの内積

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_VLON  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトルの経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_VLAT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトルの緯度成分

</td></tr>
</table>
</td></tr>
</table>
<p>
r・(▽×v)
</p>
<p>
ベクトルの渦度と動径ベクトルの内積 r・(▽×v) を計算する.
</p>
<p>
第 1, 2 引数(v[λ], v[φ])がそれぞれベクトルの経度成分, 緯度成分を表す.
</p>
<pre>
   r・(▽×v) = 1/cosφ・∂v[φ]/∂λ - 1/cosφ・∂(v[λ] cosφ)/∂φ
</pre>
<p>
のスペクトル データが返される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002069-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002069-source">
<pre>
    function wr_RadRot_xyr_xyr(xyr_VLON,xyr_VLAT)  ! r・(▽×v)
      !
      ! ベクトルの渦度と動径ベクトルの内積 r・(▽×v) を計算する.
      !
      ! 第 1, 2 引数(v[λ], v[φ])がそれぞれベクトルの経度成分, 緯度成分を表す.
      !
      !    r・(▽×v) = 1/cosφ・∂v[φ]/∂λ - 1/cosφ・∂(v[λ] cosφ)/∂φ
      !
      ! のスペクトル データが返される.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_VLON
      !(in) ベクトルの経度成分

      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_VLAT
      !(in) ベクトルの緯度成分

      real(8), dimension((nm+1)*(nm+1),km)     :: wr_RadRot_xyr_xyr
      !(out) ベクトルの渦度と動径ベクトルの内積

      wr_RadRot_xyr_xyr = wa_DivLon_xya(xyr_VLAT) - wa_DivLat_xya(xyr_VLON)
      
    end function wr_RadRot_xyr_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002023" class="method-detail">
        <a name="M002023"></a>

        <div class="method-heading">


          <a href="#M002023" class="method-signature">



          <span class="method-name">wr_RotDRad_wq</span><span class="method-args">( wq ) result(wr_RotDRad_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002023">wr_RotDRad_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 回転型動径微分を作用された水平スペクトル動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに回転型動径微分
</p>
<pre>
     1/r ∂(r.)/∂r = ∂(.)/∂r + (.)/r
</pre>
<p>
を作用する.
</p>
<p>
スペクトルデータの回転型動径微分とは, 対応する格子点データに
回転型動径微分を作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002023-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002023-source">
<pre>
    function wr_RotDRad_wq(wq)
      !
      ! 入力スペクトルデータに回転型動径微分
      !
      !      1/r ∂(r.)/∂r = ∂(.)/∂r + (.)/r
      !
      ! を作用する.
      !
      ! スペクトルデータの回転型動径微分とは, 対応する格子点データに
      ! 回転型動径微分を作用させたデータのスペクトル変換のことである. 
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),km)               :: wr_RotDRad_wq
      !(out) 回転型動径微分を作用された水平スペクトル動径格子点データ

      wr_RotDRad_wq = wr_wq(wq_RadDrad_wq(wq))/wr_Rad + wr_wq(wq)/wr_Rad

    end function wr_RotDRad_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002024" class="method-detail">
        <a name="M002024"></a>

        <div class="method-heading">


          <a href="#M002024" class="method-signature">



          <span class="method-name">wr_RotDRad_wr</span><span class="method-args">( wr ) result(wr_RotDRad_wr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002024">wr_RotDRad_wr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 回転型動径微分を作用された水平スペクトル動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに回転型動径微分
</p>
<pre>
     1/r ∂(r.)/∂r = ∂(.)/∂r + (.)/r
</pre>
<p>
を作用する.
</p>
<p>
スペクトルデータの回転型動径微分とは, 対応する格子点データに
回転型動径微分を作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002024-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002024-source">
<pre>
    function wr_RotDRad_wr(wr)
      !
      ! 入力スペクトルデータに回転型動径微分
      !
      !      1/r ∂(r.)/∂r = ∂(.)/∂r + (.)/r
      !
      ! を作用する.
      !
      ! スペクトルデータの回転型動径微分とは, 対応する格子点データに
      ! 回転型動径微分を作用させたデータのスペクトル変換のことである. 
      !
      real(8), dimension((nm+1)*(nm+1),km), intent(in) :: wr
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),km)               :: wr_RotDRad_wr
      !(out) 回転型動径微分を作用された水平スペクトル動径格子点データ

      wr_RotDRad_wr = wr_wq(wq_RadDRad_wq(wq_wr(wr*wr_Rad)))/wr_Rad**2

    end function wr_RotDRad_wr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002035" class="method-detail">
        <a name="M002035"></a>

        <div class="method-heading">


          <a href="#M002035" class="method-signature">



          <span class="method-name">wr_RotRad_xyr_xyr</span><span class="method-args">( xyr_Vlat, xyr_Vlon ) result(wr_RotRad_xyr_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002035">wr_RotRad_xyr_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の回転の動径成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_Vlat  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_Vlon  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の経度成分

</td></tr>
</table>
</td></tr>
</table>
<p>
ベクトルの緯度成分, 経度成分である第 1, 2 引数 Vlat, Vlon に対して
ベクトル場の回転の動径成分
</p>
<pre>
   1/rcosφ・∂Vlat/∂λ - 1/rcosφ・∂(Vlon cosφ)/∂φ
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002035-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002035-source">
<pre>
    function wr_RotRad_xyr_xyr(xyr_Vlat,xyr_Vlon) 
      !
      ! ベクトルの緯度成分, 経度成分である第 1, 2 引数 Vlat, Vlon に対して
      ! ベクトル場の回転の動径成分 
      !
      !    1/rcosφ・∂Vlat/∂λ - 1/rcosφ・∂(Vlon cosφ)/∂φ
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_Vlat
      !(in) ベクトル場の緯度成分

      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_Vlon
      !(in) ベクトル場の経度成分

      real(8), dimension((nm+1)*(nm+1),km)       :: wr_RotRad_xyr_xyr
      !(out) ベクトル場の回転の動径成分

        wr_RotRad_xyr_xyr =   wr_DivLon_xyr(xyr_Vlat) - wr_DivLat_xyr(xyr_Vlon)

    end function wr_RotRad_xyr_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002081" class="method-detail">
        <a name="M002081"></a>

        <div class="method-heading">


          <a href="#M002081" class="method-signature">



          <span class="method-name">wr_TorBoundaryGrid</span><span class="method-args">( wr_TORPOT, [value], [cond], [new] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wr_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1)), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 両端境界でのトロイダルポテンシャル

<pre>
    粘着条件の時のみ有効
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=1), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件スイッチ. 省略時は &#8216;R&#8216;

<pre>
    R    : 上側粘着条件
    F    : 上側応力なし条件
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
速度トロイダルポテンシャルに対して境界条件を適用する.
実空間での境界条件適用
</p>
<p>
鉛直実格子点空間において内部領域の値と境界条件を満たすように
条件を課している(選点法).
</p>
<p>
速度トロイダルポテンシャルΨに対して与えられる境界条件は
</p>
<pre>
  * 粘着条件 : Ψ = Ψb(lon,lat). Ψb は境界球面での速度分布.
                                  default は 0 (静止状態).

  * 応力なし条件 : ∂(Ψ/r)/∂r = 0.
</pre>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002081-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002081-source">
<pre>
    subroutine wr_TorBoundaryGrid(wr_TORPOT,value,cond,new) 
      !
      ! 速度トロイダルポテンシャルに対して境界条件を適用する.
      ! 実空間での境界条件適用
      !
      ! 鉛直実格子点空間において内部領域の値と境界条件を満たすように
      ! 条件を課している(選点法). 
      !
      ! 速度トロイダルポテンシャルΨに対して与えられる境界条件は
      !
      !   * 粘着条件 : Ψ = Ψb(lon,lat). Ψb は境界球面での速度分布. 
      !                                   default は 0 (静止状態).
      !
      !   * 応力なし条件 : ∂(Ψ/r)/∂r = 0.
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),km),intent(inout)    :: wr_TORPOT
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      real(8), dimension((nm+1)*(nm+1)), intent(in), optional :: value
              !(in) 両端境界でのトロイダルポテンシャル
              !     粘着条件の時のみ有効

      character(len=1), intent(in), optional  :: cond
              !(in) 境界条件スイッチ. 省略時は 'R'
              !     R    : 上側粘着条件
              !     F    : 上側応力なし条件

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:,:), allocatable  :: alu
      integer, dimension(:,:), allocatable    :: kp
      real(8), dimension((nm+1)*(nm+1),0:lm)  :: wq_data
      real(8), dimension((nm+1)*(nm+1),km)    :: wr_data
      logical                                 :: rigid   ! 境界条件

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer :: k
      save    :: alu, kp, first

      if (.not. present(cond)) then
         rigid=.TRUE.
      else
         select case (cond)
         case ('R')
            rigid = .TRUE.
         case ('F')
            rigid = .FALSE.
         case default
            call MessageNotify('E','wr_TorBoundaryGrid','B.C. not supported')
         end select
      endif

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         allocate(alu((nm+1)*(nm+1),km,km),kp((nm+1)*(nm+1),km))

         alu = 0.0D0
         do k=1,km
            wr_data = 0.0D0
            wr_data(:,k)=1.0D0
            alu(:,:,k) = wr_data
         enddo

         if ( .not. rigid ) then
            do k=1,km
               wr_data = 0.0D0
               wr_data(:,k)=1.0D0
               wq_data = wq_wr(wr_data)
               wr_data = wr_wq(wq_RadDRad_wq(wq_data) - wq_data)/wr_Rad
               alu(:,km,k) = wr_data(:,km)
            enddo
         endif

         call ludecomp(alu,kp)

         if ( rigid .AND. present(value) ) then 
            call MessageNotify('M','wr_TorBoundaryGrid', 'Toroidal potential at k=km was given by the optional variable.')
         else if ( rigid .AND. (.NOT.present(value)) ) then
            call MessageNotify('M','wr_TorBoundaryGrid', 'Toroidal potential at k=km was set to zero.')
         else if ( (.NOT. rigid) .AND. present(value) ) then
            call MessageNotify('W','wr_TorBoundaryGrid', 'Boundary value at k=km cannot be set under stress-free condition.')
         endif

         call MessageNotify('M','wr_TorBoundaryGrid', 'Matrix to apply  b.c. newly produced.')
      endif

      if ( rigid .AND. present(value) ) then
         wr_TorPot(:,km)  = value
      else
         wr_TorPot(:,km)  = 0.0D0
      endif

      wr_TorPot = lusolve(alu,kp,wr_TorPot)

    end subroutine wr_TorBoundaryGrid
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002084" class="method-detail">
        <a name="M002084"></a>

        <div class="method-heading">


          <a href="#M002084" class="method-signature">



          <span class="method-name">wr_TormagBoundaryGrid</span><span class="method-args">( wr_TOR, [new] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wr_TOR  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) (ダミー) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
磁場トロイダルポテンシャルに対して境界条件を適用する.
鉛直実空間での境界条件適用.
</p>
<p>
鉛直実格子点空間において内部領域の値と境界条件を満たすように
条件を課している(選点法).
</p>
<p>
現在のところ境界物質が非電気伝導体の場合のみ対応している. その場合,
磁場トロイダルポテンシャルの境界条件は
</p>
<p>
外側
</p>
<pre>
   wq_psi = 0   at the outer boundary
</pre>
<p>
であるので <a href="wq_module.html#M002087">wq_Boundary</a> で対応可能だが,
将来のため別途作成しておく
</p>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002084-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002084-source">
<pre>
    subroutine wr_TormagBoundaryGrid(wr_TOR,new)
      !
      ! 磁場トロイダルポテンシャルに対して境界条件を適用する.
      ! 鉛直実空間での境界条件適用.
      !
      ! 鉛直実格子点空間において内部領域の値と境界条件を満たすように
      ! 条件を課している(選点法). 
      !
      ! 現在のところ境界物質が非電気伝導体の場合のみ対応している. 
      ! その場合, 磁場トロイダルポテンシャルの境界条件は
      !
      ! 外側
      !    wq_psi = 0   at the outer boundary
      ! 
      ! であるので wq_Boundary で対応可能だが, 将来のため別途作成しておく
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),km),intent(inout)   :: wr_TOR
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 
      
      logical, intent(IN), optional :: new
              !(in) (ダミー) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      wr_TOR(:,km)  = 0.0D0

    end subroutine wr_TormagBoundaryGrid
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002020" class="method-detail">
        <a name="M002020"></a>

        <div class="method-heading">


          <a href="#M002020" class="method-signature">



          <span class="method-name">wr_wq</span><span class="method-args">( wq ) result(wr_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002020">wr_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 次元球面調和函数スペクトル・動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから水平スペクトル・動径格子点データへ(正)変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002020-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002020-source">
<pre>
    function wr_wq(wq)
      !
      ! スペクトルデータから水平スペクトル・動径格子点データへ(正)変換する.
      !
      real(8), dimension((nm+1)*(nm+1),km) :: wr_wq
      !(out) 2 次元球面調和函数スペクトル・動径格子点データ
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      wr_wq = ar_aq(wq)

    end function wr_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002019" class="method-detail">
        <a name="M002019"></a>

        <div class="method-heading">


          <a href="#M002019" class="method-signature">



          <span class="method-name">wr_xyr</span><span class="method-args">( xyr ) result(wr_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002019">wr_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 次元球面調和函数スペクトル・動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
3 次元格子データから水平スペクトル・動径格子点データへ(正)変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002019-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002019-source">
<pre>
    function wr_xyr(xyr)
      !
      ! 3 次元格子データから水平スペクトル・動径格子点データへ(正)変換する.
      !
      real(8), dimension((nm+1)*(nm+1),km)               :: wr_xyr
      !(out) 2 次元球面調和函数スペクトル・動径格子点データ

      real(8), dimension(0:im-1,1:jm,km), intent(in)         :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      wr_xyr = wa_xya(xyr)

    end function wr_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002053" class="method-detail">
        <a name="M002053"></a>

        <div class="method-heading">


          <a href="#M002053" class="method-signature">



          <span class="method-name">x_AvrLatRad_xyr</span><span class="method-args">( xyr ) result(x_AvrLatRad_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002053">x_AvrLatRad_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度動径(子午面)平均された 1 次元経度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度動径(子午面)積分
</p>
<p>
3 次元格子点データの緯度動径(子午面)平均
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
   ∫f(λ,,r) r^2cosφ dφdr /(2(r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002053-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002053-source">
<pre>
    function x_AvrLatRad_xyr(xyr)  ! 緯度動径(子午面)積分
      !
      ! 3 次元格子点データの緯度動径(子午面)平均
      !
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !    ∫f(λ,,r) r^2cosφ dφdr /(2(r[o]^3-r[i]^3)/3) 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:im-1)     :: x_AvrLatRad_xyr
      !(out) 緯度動径(子午面)平均された 1 次元経度格子点データ

      x_AvrLatRad_xyr = x_IntLatRad_xyr(xyr) /( sum(y_Lat_Weight)*sum(r_Rad_Weight) )

    end function x_AvrLatRad_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002119" class="method-detail">
        <a name="M002119"></a>

        <div class="method-heading">




          <span class="method-name">x_AvrLat_xy</span><span class="method-args">( xy_data ) result(x_AvrLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002119">x_AvrLat_xy</a>(im)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの緯度(Y)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, y_Y_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000923">wa_module#x_AvrLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M002061" class="method-detail">
        <a name="M002061"></a>

        <div class="method-heading">


          <a href="#M002061" class="method-signature">



          <span class="method-name">x_AvrRad_xr</span><span class="method-args">( xr ) result(x_AvrRad_xr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002061">x_AvrRad_xr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 動径平均された 1 次元経度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
動径積分
</p>
<p>
2 次元(XR)格子点データの動径方向域平均.
</p>
<p>
2 次元データ f(λ,r) に対して
</p>
<pre>
  ∫f(λ,r) r^2dr /((r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002061-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002061-source">
<pre>
    function x_AvrRad_xr(xr)  ! 動径積分
      !
      ! 2 次元(XR)格子点データの動径方向域平均.
      !
      ! 2 次元データ f(λ,r) に対して
      !
      !   ∫f(λ,r) r^2dr /((r[o]^3-r[i]^3)/3) 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,km), intent(in) :: xr
      !(in) 2 次元緯度動径格子点データ

      real(8), dimension(0:im-1)  :: x_AvrRad_xr
      !(out) 動径平均された 1 次元経度格子点データ

      x_AvrRad_xr = x_IntRad_xr(xr)/sum(r_Rad_Weight)

    end function x_AvrRad_xr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002039" class="method-detail">
        <a name="M002039"></a>

        <div class="method-heading">


          <a href="#M002039" class="method-signature">



          <span class="method-name">x_IntLatRad_xyr</span><span class="method-args">( xyr ) result(x_IntLatRad_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002039">x_IntLatRad_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度動径(子午面)積分された 1 次元経度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
3 次元格子点データの緯度動径(子午面)積分
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
   ∫f(λ,φ,r) r^2cosφ dφdr
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002039-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002039-source">
<pre>
    function x_IntLatRad_xyr(xyr)
      !
      ! 3 次元格子点データの緯度動径(子午面)積分
      !
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !    ∫f(λ,φ,r) r^2cosφ dφdr 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:im-1)     :: x_IntLatRad_xyr
      !(out) 緯度動径(子午面)積分された 1 次元経度格子点データ

      integer :: j, k

      x_IntLatRad_xyr = 0.0D0
      do k=1,km
         do j=1,jm
            x_IntLatRad_xyr = x_IntLatRad_xyr + xyr(:,j,k) * y_Lat_Weight(j) * r_Rad_Weight(k)
         enddo
      enddo

    end function x_IntLatRad_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002114" class="method-detail">
        <a name="M002114"></a>

        <div class="method-heading">




          <span class="method-name">x_IntLat_xy</span><span class="method-args">( xy_data ) result(x_IntLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002114">x_IntLat_xy</a>(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの緯度(Y)方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000918">wa_module#x_IntLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M002047" class="method-detail">
        <a name="M002047"></a>

        <div class="method-heading">


          <a href="#M002047" class="method-signature">



          <span class="method-name">x_IntRad_xr</span><span class="method-args">( xr ) result(x_IntRad_xr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002047">x_IntRad_xr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 動径積分された 1 次元経度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元(XR)格子点データの動径方向域積分.
</p>
<p>
2 次元データ f(λ,r) に対して ∫f(λ,r) r^2dr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002047-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002047-source">
<pre>
    function x_IntRad_xr(xr)
      !
      ! 2 次元(XR)格子点データの動径方向域積分.
      !
      ! 2 次元データ f(λ,r) に対して ∫f(λ,r) r^2dr を計算する.
      !
      real(8), dimension(0:im-1,km), intent(in) :: xr
      !(in) 2 次元緯度動径格子点データ

      real(8), dimension(0:im-1)  :: x_IntRad_xr
      !(out) 動径積分された 1 次元経度格子点データ

      integer :: k

      x_IntRad_xr = 0.0d0
      do k=1,km
         x_IntRad_xr(:) = x_IntRad_xr(:) + xr(:,k) * r_Rad_Weight(k) 
      enddo

    end function x_IntRad_xr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002092" class="method-detail">
        <a name="M002092"></a>

        <div class="method-heading">




          <span class="method-name">x_Lon</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002092">x_Lon</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 緯度経度

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="wa_module.html#M000869">wa_module#x_Lon</a>
</p>


        </div>
      </div>


      <div id="method-M002093" class="method-detail">
        <a name="M002093"></a>

        <div class="method-heading">




          <span class="method-name">x_Lon_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002093">x_Lon_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標重み

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="wa_module.html#M000871">wa_module#x_Lon_Weight</a>
</p>


        </div>
      </div>


      <div id="method-M002051" class="method-detail">
        <a name="M002051"></a>

        <div class="method-heading">


          <a href="#M002051" class="method-signature">



          <span class="method-name">xr_AvrLat_xyr</span><span class="method-args">( xyr ) result(xr_AvrLat_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002051">xr_AvrLat_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度平均された 2 次元緯度動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度積分
</p>
<p>
3 次元格子点データの緯度方向域平均.
</p>
<p>
3 次元データ f(λ,φ,r) に対して ∫f(λ,φ,r)cosφ dφ/2 を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002051-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002051-source">
<pre>
    function xr_AvrLat_xyr(xyr)  ! 緯度積分
      !
      ! 3 次元格子点データの緯度方向域平均.
      !
      ! 3 次元データ f(λ,φ,r) に対して ∫f(λ,φ,r)cosφ dφ/2 を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:im-1,km)  :: xr_AvrLat_xyr
      !(out) 緯度平均された 2 次元緯度動径格子点データ

      xr_AvrLat_xyr = xr_IntLat_xyr(xyr)/sum(y_Lat_Weight)

    end function xr_AvrLat_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002037" class="method-detail">
        <a name="M002037"></a>

        <div class="method-heading">


          <a href="#M002037" class="method-signature">



          <span class="method-name">xr_IntLat_xyr</span><span class="method-args">( xyr ) result(xr_IntLat_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002037">xr_IntLat_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度積分された 2 次元緯度動径格子点データ 緯度円格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
3 次元格子点データの緯度方向域積分.
</p>
<p>
3 次元データ f(λ,φ,r) に対して∫f(λ,φ,r) cosφ dφ を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002037-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002037-source">
<pre>
    function xr_IntLat_xyr(xyr)
      !
      ! 3 次元格子点データの緯度方向域積分.
      !
      ! 3 次元データ f(λ,φ,r) に対して∫f(λ,φ,r) cosφ dφ を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:im-1,km)  :: xr_IntLat_xyr        
      !(out) 緯度積分された 2 次元緯度動径格子点データ
      ! 緯度円格子点データ

      integer :: j

      xr_IntLat_xyr = 0.0d0
      do j=1,jm
         xr_IntLat_xyr(:,:) = xr_IntLat_xyr(:,:) + xyr(:,j,:) * y_Lat_Weight(j)
      enddo

    end function xr_IntLat_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002052" class="method-detail">
        <a name="M002052"></a>

        <div class="method-heading">


          <a href="#M002052" class="method-signature">



          <span class="method-name">xy_AvrRad_xyr</span><span class="method-args">( xyr ) result(xy_AvrRad_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002052">xy_AvrRad_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 動径平均された 2 次元経度緯度(水平, 球面)格子点データ
水平格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
3 次元格子点データの動径方向域平均.
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
   ∫f(λ,φ,r) r^2dr/((r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002052-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002052-source">
<pre>
    function xy_AvrRad_xyr(xyr)
      !
      ! 3 次元格子点データの動径方向域平均.
      !
      ! 3 次元データ f(λ,φ,r) に対して 
      !
      !    ∫f(λ,φ,r) r^2dr/((r[o]^3-r[i]^3)/3) 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:im-1,1:jm)  :: xy_AvrRad_xyr          
      !(out) 動径平均された 2 次元経度緯度(水平, 球面)格子点データ
      ! 水平格子点データ

      xy_AvrRad_xyr = xy_IntRad_xyr(xyr)/sum(r_Rad_Weight)

    end function xy_AvrRad_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002038" class="method-detail">
        <a name="M002038"></a>

        <div class="method-heading">


          <a href="#M002038" class="method-signature">



          <span class="method-name">xy_IntRad_xyr</span><span class="method-args">( xyr ) result(xy_IntRad_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002038">xy_IntRad_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 動径積分された 2 次元経度緯度(水平, 球面)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
動径積分
</p>
<p>
3 次元格子点データの動径方向域積分.
</p>
<p>
3 次元データ f(λ,φ,r) に対して∫f(λ,φ,r) r^2dr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002038-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002038-source">
<pre>
    function xy_IntRad_xyr(xyr)  ! 動径積分
      !
      ! 3 次元格子点データの動径方向域積分.
      !
      ! 3 次元データ f(λ,φ,r) に対して∫f(λ,φ,r) r^2dr を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:im-1,1:jm)  :: xy_IntRad_xyr
      !(out) 動径積分された 2 次元経度緯度(水平, 球面)格子点データ

      integer :: k

      xy_IntRad_xyr = 0.0d0
      do k=1,km
         xy_IntRad_xyr(:,:) = xy_IntRad_xyr(:,:) + xyr(:,:,k) * r_Rad_Weight(k) 
      enddo

    end function xy_IntRad_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002105" class="method-detail">
        <a name="M002105"></a>

        <div class="method-heading">




          <span class="method-name">xy_Lat</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002105">xy_Lat</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

</td></tr>
</table>
<p>
Original external subprogram is <a
href="wa_module.html#M000874">wa_module#xy_Lat</a>
</p>


        </div>
      </div>


      <div id="method-M002104" class="method-detail">
        <a name="M002104"></a>

        <div class="method-heading">




          <span class="method-name">xy_Lon</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002104">xy_Lon</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

</td></tr>
</table>
<p>
Original external subprogram is <a
href="wa_module.html#M000873">wa_module#xy_Lon</a>
</p>


        </div>
      </div>


      <div id="method-M002107" class="method-detail">
        <a name="M002107"></a>

        <div class="method-heading">




          <span class="method-name">xy_w</span><span class="method-args">( w_data, [ipow], [iflag] ) result(xy_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002107">xy_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ipow  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 作用させる 1/cosφ の次数. 省略時は 0.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>iflag  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 変換の種類

<pre>
   0 : 通常の正変換
  -1 : 経度微分を作用させた逆変換
   1 : 緯度微分 cosφ・∂/∂φ を作用させた逆変換
   2 : sinφを作用させた逆変換
   省略時は 0.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子データへ変換する(1 層用).
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000875">wa_module#xy_w</a>
</p>


        </div>
      </div>


      <div id="method-M002032" class="method-detail">
        <a name="M002032"></a>

        <div class="method-heading">


          <a href="#M002032" class="method-signature">



          <span class="method-name">xyr_Div_xyr_xyr_xyr</span><span class="method-args">( xyr_Vlon, xyr_Vlat, xyr_Vrad ) result(xyr_Div_xyr_xyr_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002032">xyr_Div_xyr_xyr_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の発散

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_Vlon  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_Vlat  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr_Vrad  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の動径成分

</td></tr>
</table>
</td></tr>
</table>
<p>
ベクトル成分である 3 つの格子データに発散を作用させる.
</p>
<p>
第 1, 2 ,3 引数(u,v,w)がそれぞれベクトルの経度成分, 緯度成分,
動径成分を表す.
</p>
<p>
極の特異性を回避するためにベクトル場に cosφ/r の重みをかけて 計算している.
</p>
<pre>
     div V = (r/cosφ)・div (Vcosφ/r) + V_φtanφ/r + V_r/r
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002032-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002032-source">
<pre>
    function xyr_Div_xyr_xyr_xyr(xyr_Vlon,xyr_Vlat,xyr_Vrad)
      !
      ! ベクトル成分である 3 つの格子データに発散を作用させる.
      !
      ! 第 1, 2 ,3 引数(u,v,w)がそれぞれベクトルの経度成分, 緯度成分, 
      ! 動径成分を表す.
      !
      ! 極の特異性を回避するためにベクトル場に cosφ/r の重みをかけて
      ! 計算している. 
      !
      !      div V = (r/cosφ)・div (Vcosφ/r) + V_φtanφ/r + V_r/r
      ! 
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_Vlon
      !(in) ベクトル場の経度成分

      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_Vlat
      !(in) ベクトル場の緯度成分

      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr_Vrad
      !(in) ベクトル場の動径成分

      real(8), dimension(0:im-1,1:jm,km)             :: xyr_Div_xyr_xyr_xyr
      !(out) ベクトル場の発散

      xyr_Div_xyr_xyr_xyr = xyr_Rad/cos(xyr_Lat) * xyr_wr(wr_Div_xyr_xyr_xyr(xyr_VLon*cos(xyr_Lat)/xyr_Rad, xyr_VLat*cos(xyr_Lat)/xyr_Rad, xyr_VRad*cos(xyr_Lat)/xyr_Rad )) + xyr_VLat*tan(xyr_Lat)/xyr_Rad + xyr_VRad/xyr_Rad

    end function xyr_Div_xyr_xyr_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002028" class="method-detail">
        <a name="M002028"></a>

        <div class="method-heading">


          <a href="#M002028" class="method-signature">



          <span class="method-name">xyr_GradLat_wq</span><span class="method-args">( wq ) result(xyr_GradLat_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002028">xyr_GradLat_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 勾配型緯度微分を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 1/r ∂/∂φ を作用させる.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002028-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002028-source">
<pre>
    function xyr_GradLat_wq(wq) 
      !
      ! スペクトルデータに勾配型経度微分 1/r ∂/∂φ を作用させる.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension(0:im-1,1:jm,km)    :: xyr_GradLat_wq
      !(out) 勾配型緯度微分を作用された 2 次元スペクトルデータ

      xyr_GradLat_wq = xya_GradLat_wa(wr_wq(wq))/xyr_Rad

    end function xyr_GradLat_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002027" class="method-detail">
        <a name="M002027"></a>

        <div class="method-heading">


          <a href="#M002027" class="method-signature">



          <span class="method-name">xyr_GradLon_wq</span><span class="method-args">( wq ) result(xyr_GradLon_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002027">xyr_GradLon_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 勾配型経度微分を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 1/rcosφ・∂/∂λ を作用させる.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002027-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002027-source">
<pre>
    function xyr_GradLon_wq(wq)
      !
      ! スペクトルデータに勾配型経度微分 1/rcosφ・∂/∂λ
      ! を作用させる.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension(0:im-1,1:jm,km)    :: xyr_GradLon_wq
      !(out) 勾配型経度微分を作用された 2 次元スペクトルデータ

      xyr_GradLon_wq = xya_GradLon_wa(wr_wq(wq))/xyr_Rad

    end function xyr_GradLon_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002065" class="method-detail">
        <a name="M002065"></a>

        <div class="method-heading">


          <a href="#M002065" class="method-signature">



          <span class="method-name">xyr_KGrad_wq</span><span class="method-args">( wq ) result(xyr_KGrad_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002065">xyr_KGrad_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 軸方向微分を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
k・▽ = cosφ/r ∂/∂φ + sinφ∂/∂r
</p>
<p>
入力スペクトルデータに対応する格子データに軸方向微分
</p>
<pre>
   k・▽ = cosφ/r ∂/∂φ + sinφ∂/∂r
</pre>
<p>
を作用させた格子データが返される. ここでベクトル k
は球の中心から北極向きの単位ベクトルである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002065-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002065-source">
<pre>
    function xyr_KGrad_wq(wq)    ! k・▽ = cosφ/r ∂/∂φ + sinφ∂/∂r
      !
      ! 入力スペクトルデータに対応する格子データに軸方向微分 
      !
      !    k・▽ = cosφ/r ∂/∂φ + sinφ∂/∂r 
      !
      ! を作用させた格子データが返される. 
      ! ここでベクトル k は球の中心から北極向きの単位ベクトルである.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension(0:im-1,1:jm,km)                 :: xyr_KGrad_wq
      !(out) 軸方向微分を作用された 2 次元スペクトルデータ

      xyr_KGrad_wq =  cos(xyr_Lat)*xyr_GradLat_wq(wq) + sin(xyr_Lat)*xyr_wq(wq_RadDRad_wq(wq))/xyr_Rad

    end function xyr_KGrad_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002011" class="method-detail">
        <a name="M002011"></a>

        <div class="method-heading">




          <span class="method-name">xyr_LAT</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002011">xyr_LAT</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:,:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M002010" class="method-detail">
        <a name="M002010"></a>

        <div class="method-heading">




          <span class="method-name">xyr_LON</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002010">xyr_LON</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:,:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M002012" class="method-detail">
        <a name="M002012"></a>

        <div class="method-heading">




          <span class="method-name">xyr_RAD</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002012">xyr_RAD</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:,:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M002034" class="method-detail">
        <a name="M002034"></a>

        <div class="method-heading">


          <a href="#M002034" class="method-signature">



          <span class="method-name">xyr_RotLat_wq_wq</span><span class="method-args">( wq_Vlon, wq_Vrad ) result(xyr_RotLat_wq_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002034">xyr_RotLat_wq_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の回転の緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq_Vlon  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq_Vrad  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の動径成分

</td></tr>
</table>
</td></tr>
</table>
<p>
ベクトル場の経度成分, 動径成分である第 1, 2 引数 Vlon, Vrad から
回転の緯度成分
</p>
<pre>
   1/r ∂(r Vlon)/∂r - 1/rcosφ・∂Vrad/∂λ
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002034-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002034-source">
<pre>
    function xyr_RotLat_wq_wq(wq_Vlon,wq_Vrad) 
      !
      ! ベクトル場の経度成分, 動径成分である第 1, 2 引数 Vlon, Vrad から
      ! 回転の緯度成分 
      !
      !    1/r ∂(r Vlon)/∂r - 1/rcosφ・∂Vrad/∂λ
      !
      ! を計算する.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq_Vlon
      !(in) ベクトル場の経度成分

      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq_Vrad
      !(in) ベクトル場の動径成分

      real(8), dimension(0:im-1,1:jm,km)                 :: xyr_RotLat_wq_wq
      !(out) ベクトル場の回転の緯度成分

        xyr_RotLat_wq_wq =   xyr_wr(wr_RotDRad_wq(wq_Vlon)) - xyr_GradLon_wq(wq_Vrad) 

    end function xyr_RotLat_wq_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002033" class="method-detail">
        <a name="M002033"></a>

        <div class="method-heading">


          <a href="#M002033" class="method-signature">



          <span class="method-name">xyr_RotLon_wq_wq</span><span class="method-args">( wq_Vrad, wq_Vlat ) result(xyr_RotLon_wq_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002033">xyr_RotLon_wq_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の回転の経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq_Vrad  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の動径成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq_Vlat  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の緯度成分

</td></tr>
</table>
</td></tr>
</table>
<p>
ベクトル場の動径成分, 緯度成分である第 1, 2 引数 Vrad, Vlat から
回転の経度成分
</p>
<pre>
   1/r ∂Vrad/∂φ-1/r ∂(r Vlat)/∂r を計算する.
</pre>
<p>
を計算する
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002033-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002033-source">
<pre>
    function xyr_RotLon_wq_wq(wq_Vrad,wq_Vlat) 
      !
      ! ベクトル場の動径成分, 緯度成分である第 1, 2 引数 Vrad, Vlat から
      ! 回転の経度成分 
      !
      !    1/r ∂Vrad/∂φ-1/r ∂(r Vlat)/∂r を計算する.
      !
      ! を計算する
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq_Vrad
      !(in) ベクトル場の動径成分

      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq_Vlat
      !(in) ベクトル場の緯度成分

      real(8), dimension(0:im-1,1:jm,km)                 :: xyr_RotLon_wq_wq
      !(out) ベクトル場の回転の経度成分

        xyr_RotLon_wq_wq =   xyr_GradLat_wq(wq_Vrad) - xyr_wr(wr_RotDRad_wq(wq_Vlat))

    end function xyr_RotLon_wq_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002016" class="method-detail">
        <a name="M002016"></a>

        <div class="method-heading">


          <a href="#M002016" class="method-signature">



          <span class="method-name">xyr_wq</span><span class="method-args">( wq ) result(xyr_wq)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002016">xyr_wq</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wq  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから 3 次元格子点データへ(逆)変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002016-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002016-source">
<pre>
    function xyr_wq(wq)
      !
      ! スペクトルデータから 3 次元格子点データへ(逆)変換する.
      !
      real(8), dimension(0:im-1,1:jm,km)                       :: xyr_wq
      !(out) 3 次元経度緯度動径格子点データ

      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wq
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      xyr_wq = xya_wa(wr_wq(wq))

    end function xyr_wq
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002018" class="method-detail">
        <a name="M002018"></a>

        <div class="method-heading">


          <a href="#M002018" class="method-signature">



          <span class="method-name">xyr_wr</span><span class="method-args">( wr ) result(xyr_wr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002018">xyr_wr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数スペクトル・動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
水平スペクトル・動径格子点データから 3 次元格子点データへ(逆)変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002018-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002018-source">
<pre>
    function xyr_wr(wr)
      !
      ! 水平スペクトル・動径格子点データから 3 次元格子点データへ(逆)変換する.
      !
      real(8), dimension(0:im-1,1:jm,km)                     :: xyr_wr
      !(out) 3 次元経度緯度動径格子点データ

      real(8), dimension((nm+1)*(nm+1),km), intent(in) :: wr
      !(in) 2 次元球面調和函数スペクトル・動径格子点データ

      xyr_wr = xya_wa(wr)

    end function xyr_wr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002054" class="method-detail">
        <a name="M002054"></a>

        <div class="method-heading">


          <a href="#M002054" class="method-signature">



          <span class="method-name">y_AvrLonRad_xyr</span><span class="method-args">( xyr ) result(y_AvrLonRad_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002054">y_AvrLonRad_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度動径(緯度円)平均された 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
経度動径(緯度円)積分
</p>
<p>
3 次元格子点データの経度動径(緯度円)平均.
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
    ∫f(λ,φ,r) r^2dλdr /(2π(r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002054-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002054-source">
<pre>
    function y_AvrLonRad_xyr(xyr)  ! 経度動径(緯度円)積分
      !
      ! 3 次元格子点データの経度動径(緯度円)平均.
      !
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !     ∫f(λ,φ,r) r^2dλdr /(2π(r[o]^3-r[i]^3)/3) 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(1:jm)       :: y_AvrLonRad_xyr
      !(out) 経度動径(緯度円)平均された 1 次元緯度格子点データ

      y_AvrLonRad_xyr = y_IntLonRad_xyr(xyr) /(sum(x_Lon_Weight)*sum(r_Rad_Weight))

    end function y_AvrLonRad_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002120" class="method-detail">
        <a name="M002120"></a>

        <div class="method-heading">




          <span class="method-name">y_AvrLon_xy</span><span class="method-args">( xy_data ) result(y_AvrLon_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002120">y_AvrLon_xy</a>(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元緯度(Y)格子点

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの経度(X)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, x_X_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000921">wa_module#y_AvrLon_xy</a>
</p>


        </div>
      </div>


      <div id="method-M002058" class="method-detail">
        <a name="M002058"></a>

        <div class="method-heading">


          <a href="#M002058" class="method-signature">



          <span class="method-name">y_AvrRad_yr</span><span class="method-args">( yr ) result(y_AvrRad_yr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002058">y_AvrRad_yr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 動径平均された 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径(子午面)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元(YR)格子点データの動径方向域平均.
</p>
<p>
2 次元データ f(φ,r) に対して ∫f(φ,r) r^2dr /((r[o]^3-r[i]^3)/3)
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002058-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002058-source">
<pre>
    function y_AvrRad_yr(yr)
      !
      ! 2 次元(YR)格子点データの動径方向域平均.
      !
      ! 2 次元データ f(φ,r) に対して ∫f(φ,r) r^2dr /((r[o]^3-r[i]^3)/3) 
      ! を計算する.
      !
      real(8), dimension(1:jm,km), intent(in) :: yr
      !(in) 2 次元緯度動径(子午面)格子点データ

      real(8), dimension(1:jm)  :: y_AvrRad_yr
      !(out) 動径平均された 1 次元緯度格子点データ

      y_AvrRad_yr = y_IntRad_yr(yr)/sum(r_Rad_Weight)

    end function y_AvrRad_yr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002040" class="method-detail">
        <a name="M002040"></a>

        <div class="method-heading">


          <a href="#M002040" class="method-signature">



          <span class="method-name">y_IntLonRad_xyr</span><span class="method-args">( xyr ) result(y_IntLonRad_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002040">y_IntLonRad_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度動径(緯度円)積分された 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
3 次元格子点データの経度動径(緯度円)積分.
</p>
<p>
3 次元データ f(λ,φ,r) に対して∫f(λ,φ,r) r^2dλdr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002040-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002040-source">
<pre>
    function y_IntLonRad_xyr(xyr)
      !
      ! 3 次元格子点データの経度動径(緯度円)積分.
      !
      ! 3 次元データ f(λ,φ,r) に対して∫f(λ,φ,r) r^2dλdr を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(1:jm)       :: y_IntLonRad_xyr
      !(out) 経度動径(緯度円)積分された 1 次元緯度格子点データ

      integer :: i, k

      y_IntLonRad_xyr = 0.0D0
      do k=1,km
         do i=0,im-1
            y_IntLonRad_xyr = y_IntLonRad_xyr + xyr(i,:,k) * x_Lon_Weight(i) * r_Rad_Weight(k)
         enddo
      enddo

    end function y_IntLonRad_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002115" class="method-detail">
        <a name="M002115"></a>

        <div class="method-heading">




          <span class="method-name">y_IntLon_xy</span><span class="method-args">( xy_data ) result(y_IntLon_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002115">y_IntLon_xy</a>(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元緯度(Y)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの経度(X)方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000916">wa_module#y_IntLon_xy</a>
</p>


        </div>
      </div>


      <div id="method-M002044" class="method-detail">
        <a name="M002044"></a>

        <div class="method-heading">


          <a href="#M002044" class="method-signature">



          <span class="method-name">y_IntRad_yr</span><span class="method-args">( yr ) result(y_IntRad_yr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002044">y_IntRad_yr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 動径積分された 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径(子午面)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
動径積分
</p>
<p>
2 次元(YR)格子点データの動径方向域積分.
</p>
<p>
2 次元データ f(φ,r) に対して∫f(φ,r) r^2dr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002044-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002044-source">
<pre>
    function y_IntRad_yr(yr)  ! 動径積分
      !
      ! 2 次元(YR)格子点データの動径方向域積分.
      !
      ! 2 次元データ f(φ,r) に対して∫f(φ,r) r^2dr を計算する.
      !
      real(8), dimension(1:jm,km), intent(in) :: yr
      !(in) 2 次元緯度動径(子午面)格子点データ

      real(8), dimension(1:jm)  :: y_IntRad_yr
      !(out) 動径積分された 1 次元緯度格子点データ

      integer :: k

      y_IntRad_yr = 0.0d0
      do k=1,km
         y_IntRad_yr(:) = y_IntRad_yr(:) + yr(:,k) * r_Rad_Weight(k) 
      enddo

    end function y_IntRad_yr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002094" class="method-detail">
        <a name="M002094"></a>

        <div class="method-heading">




          <span class="method-name">y_Lat</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002094">y_Lat</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 緯度経度

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="wa_module.html#M000870">wa_module#y_Lat</a>
</p>


        </div>
      </div>


      <div id="method-M002095" class="method-detail">
        <a name="M002095"></a>

        <div class="method-heading">




          <span class="method-name">y_Lat_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002095">y_Lat_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標重み

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="wa_module.html#M000872">wa_module#y_Lat_Weight</a>
</p>


        </div>
      </div>


      <div id="method-M002050" class="method-detail">
        <a name="M002050"></a>

        <div class="method-heading">


          <a href="#M002050" class="method-signature">



          <span class="method-name">yr_AvrLon_xyr</span><span class="method-args">( xyr ) result(yr_AvrLon_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002050">yr_AvrLon_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度方向(帯状)平均された 2 次元子午面格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
経度(帯状)積分
</p>
<p>
3 次元格子点データの経度方向(帯状)平均.
</p>
<p>
3 次元データ f(λ,φ,r) に対して ∫f(λ,φ,r)dλ/2π を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002050-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002050-source">
<pre>
    function yr_AvrLon_xyr(xyr)  ! 経度(帯状)積分
      !
      ! 3 次元格子点データの経度方向(帯状)平均.
      !
      ! 3 次元データ f(λ,φ,r) に対して ∫f(λ,φ,r)dλ/2π を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(1:jm,km)  :: yr_AvrLon_xyr
      !(out) 経度方向(帯状)平均された 2 次元子午面格子点データ

      yr_AvrLon_xyr = yr_IntLon_xyr(xyr)/sum(x_Lon_Weight)

    end function yr_AvrLon_xyr
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002036" class="method-detail">
        <a name="M002036"></a>

        <div class="method-heading">


          <a href="#M002036" class="method-signature">



          <span class="method-name">yr_IntLon_xyr</span><span class="method-args">( xyr ) result(yr_IntLon_xyr)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wq_module.html#M002036">yr_IntLon_xyr</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度方向(帯状)積分された 2 次元子午面格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyr  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
経度(帯状)積分
</p>
<p>
3 次元格子点データの経度方向(帯状)積分.
</p>
<p>
3 次元データ f(λ,φ,r) に対して ∫f(λ,φ,r)dλ を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002036-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002036-source">
<pre>
    function yr_IntLon_xyr(xyr)  ! 経度(帯状)積分
      !
      ! 3 次元格子点データの経度方向(帯状)積分.
      !
      ! 3 次元データ f(λ,φ,r) に対して ∫f(λ,φ,r)dλ を計算する.
      !
      real(8), dimension(0:im-1,1:jm,km), intent(in) :: xyr
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(1:jm,km)  :: yr_IntLon_xyr
      !(out) 経度方向(帯状)積分された 2 次元子午面格子点データ

      integer :: i

      yr_IntLon_xyr = 0.0d0
      do i=0,im-1
         yr_IntLon_xyr(:,:) = yr_IntLon_xyr(:,:) + xyr(i,:,:) * x_Lon_Weight(i)
      enddo
    end function yr_IntLon_xyr
</pre>
          </div>

        </div>
      </div>



    </div>



  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
