<?xml version="1.0" encoding="euc-jp"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: wa_zonal_module</title>
  <meta http-equiv="Content-Type" content="text/html; charset=euc-jp" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">wa_zonal_module</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../files/src/wa_zonal_module_f90.html">

                src/wa_zonal_module.f90

                </a>


        <br />
            </td>
        </tr>


        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">


  <div id="contextContent">



    <div id="description">
      <h1><a href="wa_zonal_module.html">wa_zonal_module</a></h1>
<table>
<tr><td valign="top">Authors:</td><td>Shin-ichi Takehiro, Youhei SASAKI

</td></tr>
<tr><td valign="top">Version:</td><td>$Id: <a
href="../files/src/wa_zonal_module_f90.html">wa_zonal_module.f90</a>,v 1.6
2009-02-28 21:33:48 uwabami Exp $

</td></tr>
<tr><td valign="top">Copyright&amp;License:</td><td>See <a href="../../COPYRIGHT">COPYRIGHT</a>

</td></tr>
</table>
<h2>概要</h2>
<pre>
 spml/wa_zonal_module モジュールは球面上での経度方向に一様な帯状的
 1 次元流体運動をルジャンドル多項式を用いたスペクトル法によって
 数値計算するための Fortran90 関数を提供する.

 球面上の 1 層モデル用 w_zonal_module モジュールを多層モデル用に
 拡張したものであり, 同時に複数個のスペクトルデータ, 格子点データに
 対する変換が行える.

 内部で l_module/la_module を用いている. 最下部ではルジャンドル
 多項式変換のエンジンとして ISPACK の Fortran77 サブルーチンを
 用いている.

 wa_zonal_modulde で提供される関数・サブルーチンは 2 次元的流体運動を扱う
 wa_module モジュールで用いられているものと名前およびインターフェースが
 共通になるように設計してある. したがって, wa_module を用いて構成された
 2 次元モデルを帯状方向に一様な 1 次元軸対称モデルへと改造するには
 次の手順が必要となる.

 1. use 文での wa_module の引用を wa_zonal_module に変更する.
 2. 配列の大きさを経度方向格子点数 im -&gt; 1 に,
    水平波数を (nm+1)**2 -&gt; nm+1 に変更する.
 3. DO 文で水平波数に関してループを回しているところを
    (nm+1)**2 -&gt; nm+1 に変更する.
 4. gtool 出力の次元変数変更する.
</pre>
<h2>関数・変数の名前と型について</h2>
<p>
<a href="w_zonal_module.html">w_zonal_module</a>
でのものに追加される関数・変数の名前と型についてのみ 説明する. <a
href="w_zonal_module.html">w_zonal_module</a>
での関数・変数の名前と型については <a
href="w_zonal_module.html">w_zonal_module</a> の該当項を参照されたい.
</p>
<h3>命名法</h3>
<ul>
<li>関数名の先頭 (wa_, nma_, na_, xya_, xa_, ya_, w_, xy_, x_, y_, a_) は,
返す値の形を示している.

<table>
<tr><td valign="top">wa_  :</td><td>水平スペクトルデータの並んだ 2 次元配列(スペクトルデータの 並びは
LTPACK/ISPACK に従ったもの)

</td></tr>
<tr><td valign="top">nma_ :</td><td>スペクトルデータの並んだ 3 次元配列 (スペクトルデータの並びは 全波数 n,
帯状波数 m で指定される 2 次元配列)

</td></tr>
<tr><td valign="top">na_  :</td><td>スペクトルデータの並んだ 2 次元配列 (スペクトルデータの並びは 全波数 n
で指定される 1 次元配列)

</td></tr>
<tr><td valign="top">xya_ :</td><td>2 次元格子点データの並んだ 3 次元配列

</td></tr>
<tr><td valign="top">xa_  :</td><td>経度方向 1 次元格子点データの並んだ 2 次元配列

</td></tr>
<tr><td valign="top">ya_  :</td><td>緯度方向 1 次元格子点データの並んだ 2 次元配列

</td></tr>
</table>
</li>
<li>関数名の間の文字列(DLon, GradLat, GradLat, DivLon, DivLat, Lapla, LaplaInv,
Jacobian)は, その関数の作用を表している.

</li>
<li>関数名の最後 (_wa_wa, _wa, _xya, _xa, _ya, _w_w, _w, _xy, _x, _y) は,
入力変数の形スペクトルデータおよび格子点データであることを示している.

<table>
<tr><td valign="top">_wa    :</td><td>スペクトルデータの並んだ 2 次元配列

</td></tr>
<tr><td valign="top">_wa_wa :</td><td>2 つのスペクトルデータの並んだ 2 次元配列

</td></tr>
<tr><td valign="top">_xya   :</td><td>2 次元格子点データの並んだ 3 次元配列

</td></tr>
<tr><td valign="top">_xa    :</td><td>経度方向 1 次元格子点データの並んだ 2 次元配列

</td></tr>
<tr><td valign="top">_ya    :</td><td>緯度方向 1 次元格子点データの並んだ 2 次元配列

</td></tr>
</table>
</li>
</ul>
<h3>各データの種類の説明</h3>
<ul>
<li>xya : 2 次元格子点データの並んだ 3 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(0:im-1,1:jm,:).

</li>
<li>im, jm はそれぞれ経度, 緯度座標の格子点数であり, サブルーチン <a
href="wa_zonal_module.html#M001179">wa_Initial</a>
にてあらかじめ設定しておく.

</li>
<li>扱う第 3 次元の大きさの最大値を <a
href="wa_zonal_module.html#M001179">wa_Initial</a> で設定しておく.

</li>
</ul>
</li>
<li>wa : スペクトルデータの並んだ 2 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(nm+1,:).

</li>
<li>nm は球面調和函数の最大全波数であり, サブルーチン <a
href="wa_zonal_module.html#M001179">wa_Initial</a> にて
あらかじめ設定しておく.

</li>
<li>スペクトルデータの格納のされ方は関数 <a
href="wa_zonal_module.html#M001216">l_nm</a>, <a
href="wa_zonal_module.html#M001220">nm_l</a> によって 調べることができる.

</li>
<li>扱う第 3 次元の大きさの 最大値を <a
href="wa_zonal_module.html#M001179">wa_Initial</a> で設定しておく.

</li>
</ul>
</li>
<li>xa, ya : 経度, 緯度方向 1 次元格子点データ.

<ul>
<li>変数の種類と次元はそれぞれ real(8), dimension(0:im-1,:) および real(8),
dimension(1:jm,:).

</li>
</ul>
</li>
<li>nma : スペクトルデータの並んだ 3 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(0:nm,-nm:nm,:).

</li>
<li>第 1 次元が水平全波数, 第 2 次元が帯状波数を表す.

</li>
<li>nm は球面調和函数の最大全波数であり, サブルーチン <a
href="wa_zonal_module.html#M001179">wa_Initial</a>
にてあらかじめ設定しておく.

</li>
</ul>
</li>
<li>na : スペクトルデータの並んだ 2 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(0:nm,:).

</li>
<li>第 1 次元が水平全波数を表す.nm は球面調和函数の最大全波数であり,
サブルーチン <a href="wa_zonal_module.html#M001179">wa_Initial</a>
にてあらかじめ設定しておく.

</li>
</ul>
</li>
<li>wa_ で始まる関数が返す値はスペクトルデータの並んだ 2 次元配列に同じ.

</li>
<li>nma_ で始まる関数が返す値はスペクトルデータの並んだ 3 次元配列に同じ.

</li>
<li>na_ で始まる関数が返す値はスペクトルデータの並んだ 2 次元配列に同じ.

</li>
<li>xya_ で始まる関数が返す値は 2 次元格子点データの並んだ 3 次元配列に 同じ.

</li>
<li>xa_, ya_ で始まる関数が返す値は 1 次元格子点データの並んだ 2 次元
配列に同じ.

</li>
<li>スペクトルデータに対する微分等の作用とは, 対応する格子点データに
微分などを作用させたデータをスペクトル変換したものことである.

</li>
</ul>
<h2>変数・手続き群の要約</h2>
<h4>初期化</h4>
<table>
<tr><td valign="top"><a href="wa_zonal_module.html#M001179">wa_Initial</a> :</td><td>スペクトル変換の格子点数, 波数, 領域の大きさ,

</td></tr>
</table>
<pre>
           :: および同時に計算するデータの個数の最大値設定
</pre>
<h4>座標変数</h4>
<table>
<tr><td valign="top"><a href="wa_zonal_module.html#M001206">x_Lon</a>, <a href="wa_zonal_module.html#M001207">y_Lat</a>     :</td><td>格子点座標(緯度, 経度座標)を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001209">x_Lon_Weight</a>, <a href="wa_zonal_module.html#M001210">y_Lat_Weight</a> :</td><td>重み座標を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001212">xy_Lon</a>, <a href="wa_zonal_module.html#M001213">xy_Lat</a>   :</td><td>格子点データの経度・緯度座標(X,Y) (格子点データ型 2 次元配列)

</td></tr>
</table>
<h4>基本変換</h4>
<table>
<tr><td valign="top"><a href="wa_zonal_module.html#M001180">xya_wa</a>, <a href="wa_zonal_module.html#M001214">xy_w</a> :</td><td>スペクトルデータから格子データへの変換(多層, 1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001181">wa_xya</a>, <a href="wa_zonal_module.html#M001215">w_xy</a> :</td><td>格子データからスペクトルデータへの変換(多層, 1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001216">l_nm</a>, <a href="wa_zonal_module.html#M001220">nm_l</a> :</td><td>スペクトルデータの格納位置と全波数・帯状波数の変換

</td></tr>
</table>
<h4>微分</h4>
<table>
<tr><td valign="top"><a href="wa_zonal_module.html#M001237">wa_Lapla_wa</a>, <a href="wa_zonal_module.html#M001224">w_Lapla_w</a>        :</td><td>スペクトルデータにラプラシアンを 作用させる(多層, 1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001222">rn</a>                            :</td><td>スペクトルデータのラプラシアンを 計算するための係数

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001223">irm</a>                           :</td><td>経度微分演算用配列

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001238">wa_LaplaInv_wa</a>, <a href="wa_zonal_module.html#M001225">w_LaplaInv_w</a>  :</td><td>スペクトルデータにラプラシアンの逆変換を 作用させる(多層, 1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001182">wa_DLon_wa</a>, <a href="wa_zonal_module.html#M001226">w_DLon_w</a>          :</td><td>スペクトルデータに 経度微分∂/∂λを作用させる(多層, 1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001183">xya_GradLon_wa</a>, <a href="wa_zonal_module.html#M001227">xy_GradLon_w</a>  :</td><td>スペクトルデータに 勾配型経度微分 1/cosφ・∂/∂λ を 作用させる(多層, 1
層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001184">xya_GradLat_wa</a>, <a href="wa_zonal_module.html#M001228">xy_GradLat_w</a>  :</td><td>スペクトルデータに 勾配型緯度微分 ∂/∂φ を作用させる (多層, 1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001185">wa_DivLon_xya</a>, <a href="wa_zonal_module.html#M001229">w_DivLon_xy</a>    :</td><td>格子データに 発散型経度微分 1/cosφ・∂/∂λを 作用させる(多層, 1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001186">wa_DivLat_xya</a>, <a href="wa_zonal_module.html#M001230">w_DivLat_xy</a>    :</td><td>格子データに 発散型緯度微分 1/cosφ・∂(g cosφ)/∂φを 作用させる (多層, 1
層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001187">wa_Div_xya_xya</a>, <a href="wa_zonal_module.html#M001231">w_Div_xy_xy</a>   :</td><td>ベクトル成分である 2 つの格子データに 発散を作用させる(多層, 1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001188">wa_Jacobian_wa_wa</a>,<a href="wa_zonal_module.html#M001232">w_Jacobian_w_w</a> :</td><td>2 つのスペクトルデータからヤコビアンを 計算する(多層, 1 層用)

</td></tr>
</table>
<h4>微分(λ,μ=sinφ 座標)</h4>
<table>
<tr><td valign="top"><a href="wa_zonal_module.html#M001189">xya_GradLambda_wa</a>,<a href="wa_zonal_module.html#M001233">xy_GradLambda_w</a>  :</td><td>スペクトルデータに 勾配型経度微分∂/∂λを 作用させる(多層, 1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001190">xya_GradMu_wa</a>,<a href="wa_zonal_module.html#M001234">xy_GradMu_w</a>          :</td><td>スペクトルデータに勾配型緯度微分 (1-μ^2)∂/∂μを作用させる (多層, 1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001191">wa_DivLambda_xya</a>,<a href="wa_zonal_module.html#M001235">w_DivLambda_xy</a>    :</td><td>格子データに発散型経度微分 1 /(1-μ^2)・∂/∂λを作用させる (多層, 1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001192">wa_DivMu_xya</a>,<a href="wa_zonal_module.html#M001236">w_DivMu_xy</a>            :</td><td>格子データに発散型緯度微分 ∂/∂μを作用させる(多層, 1 層用)

</td></tr>
</table>
<h4>補間計算</h4>
<table>
<tr><td valign="top"><a href="wa_zonal_module.html#M001193">a_Interpolate_wa</a>, <a href="wa_zonal_module.html#M001239">Interpolate_w</a> :</td><td>スペクトルデータから任意の点の 関数値を計算する.

</td></tr>
</table>
<h4>積分・平均</h4>
<table>
<tr><td valign="top"><a href="wa_zonal_module.html#M001194">a_IntLonLat_xya</a>, <a href="wa_zonal_module.html#M001198">a_AvrLonLat_xya</a> :</td><td>2 次元格子点データの 全領域積分および平均(多層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001240">IntLonLat_xy</a>, <a href="wa_zonal_module.html#M001246">AvrLonLat_xy</a>       :</td><td>2 次元格子点データの 全領域積分および平均(1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001196">ya_IntLon_xya</a>, <a href="wa_zonal_module.html#M001200">ya_AvrLon_xya</a>     :</td><td>2 次元格子点データの 経度方向積分および平均(多層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001241">y_IntLon_xy</a>, <a href="wa_zonal_module.html#M001247">y_AvrLon_xy</a>         :</td><td>2 次元格子点データの 経度方向積分および平均(1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001197">a_IntLon_xa</a>, <a href="wa_zonal_module.html#M001201">a_AvrLon_xa</a>         :</td><td>1 次元(X)格子点データの 経度方向積分および平均(多層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001242">IntLon_x</a>, <a href="wa_zonal_module.html#M001248">AvrLon_x</a>               :</td><td>1 次元(X)格子点データの 経度方向積分および平均(1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001195">xa_IntLat_xya</a>, <a href="wa_zonal_module.html#M001249">x_AvrLat_xy</a>       :</td><td>2 次元格子点データの 緯度方向積分および平均(多層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001243">x_IntLat_xy</a>, <a href="wa_zonal_module.html#M001249">x_AvrLat_xy</a>         :</td><td>2 次元格子点データの 緯度方向積分および平均(1 層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001252">a_IntLat_ya</a>, <a href="wa_zonal_module.html#M001253">a_AvrLat_ya</a>         :</td><td>1 次元(Y)格子点データの 緯度方向積分および平均(多層用)

</td></tr>
<tr><td valign="top"><a href="wa_zonal_module.html#M001244">IntLat_y</a>, <a href="wa_zonal_module.html#M001250">AvrLat_y</a>               :</td><td>1 次元(Y)格子点データの 緯度方向積分および平均(1 層用)

</td></tr>
</table>
<h4>スペクトル解析</h4>
<p>
<a href="wa_zonal_module.html#M001202">nma_EnergyFromStreamfunc_wa</a>,<a
href="wa_zonal_module.html#M001254">nm_EnergyFromStreamfunc_w</a> ::
流線関数からエネルギースペクトルを計算する (水平全波数 n, 帯状波数 m
空間)(多層, 1 層用)
</p>
<p>
<a href="wa_zonal_module.html#M001203">na_EnergyFromStreamfunc_wa</a>,<a
href="wa_zonal_module.html#M001255">n_EnergyFromStreamfunc_w</a> ::
流線関数からエネルギースペクトルを計算する (水平全波数 n 空間) (多層, 1
層用)
</p>
<p>
<a
href="wa_zonal_module.html#M001204">nma_EnstrophyFromStreamfunc_wa</a>,<a
href="wa_zonal_module.html#M001256">nm_EnstrophyFromStreamfunc_w</a> ::
流線関数からエンストロフィースペクトルを計算する (水平全波数 n, 帯状波数 m
空間)(多層, 1 層用)
</p>
<p>
<a href="wa_zonal_module.html#M001205">na_EnstrophyFromStreamfunc_wa</a>,<a
href="wa_zonal_module.html#M001257">n_EnstrophyFromStreamfunc_w</a> ::
流線関数からエンストロフィースペクトルを計算する(水平全波数 n 空間) (多層,
1 層用)
</p>
<table>
<tr><td valign="top"><a href="wa_zonal_module.html#M001258">w_spectrum_VMiss</a>              :</td><td>欠損値

</td></tr>
</table>

    </div>





   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M001251">AvrLat_y</a>&nbsp;&nbsp;

        <a href="#M001250">AvrLat_y</a>&nbsp;&nbsp;

        <a href="#M001246">AvrLonLat_xy</a>&nbsp;&nbsp;

        <a href="#M001248">AvrLon_x</a>&nbsp;&nbsp;

        <a href="#M001245">IntLat_y</a>&nbsp;&nbsp;

        <a href="#M001244">IntLat_y</a>&nbsp;&nbsp;

        <a href="#M001240">IntLonLat_xy</a>&nbsp;&nbsp;

        <a href="#M001242">IntLon_x</a>&nbsp;&nbsp;

        <a href="#M001239">Interpolate_w</a>&nbsp;&nbsp;

        <a href="#M001253">a_AvrLat_ya</a>&nbsp;&nbsp;

        <a href="#M001198">a_AvrLonLat_xya</a>&nbsp;&nbsp;

        <a href="#M001201">a_AvrLon_xa</a>&nbsp;&nbsp;

        <a href="#M001252">a_IntLat_ya</a>&nbsp;&nbsp;

        <a href="#M001194">a_IntLonLat_xya</a>&nbsp;&nbsp;

        <a href="#M001197">a_IntLon_xa</a>&nbsp;&nbsp;

        <a href="#M001193">a_Interpolate_wa</a>&nbsp;&nbsp;

        <a href="#M001223">irm</a>&nbsp;&nbsp;

        <a href="#M001216">l_nm</a>&nbsp;&nbsp;

        <a href="#M001217">l_nm</a>&nbsp;&nbsp;

        <a href="#M001218">l_nm</a>&nbsp;&nbsp;

        <a href="#M001219">l_nm</a>&nbsp;&nbsp;

        <a href="#M001255">n_EnergyFromStreamfunc_w</a>&nbsp;&nbsp;

        <a href="#M001257">n_EnstrophyFromStreamfunc_w</a>&nbsp;&nbsp;

        <a href="#M001203">na_EnergyFromStreamfunc_wa</a>&nbsp;&nbsp;

        <a href="#M001205">na_EnstrophyFromStreamfunc_wa</a>&nbsp;&nbsp;

        <a href="#M001254">nm_EnergyFromStreamfunc_w</a>&nbsp;&nbsp;

        <a href="#M001256">nm_EnstrophyFromStreamfunc_w</a>&nbsp;&nbsp;

        <a href="#M001220">nm_l</a>&nbsp;&nbsp;

        <a href="#M001221">nm_l</a>&nbsp;&nbsp;

        <a href="#M001202">nma_EnergyFromStreamfunc_wa</a>&nbsp;&nbsp;

        <a href="#M001204">nma_EnstrophyFromStreamfunc_wa</a>&nbsp;&nbsp;

        <a href="#M001222">rn</a>&nbsp;&nbsp;

        <a href="#M001226">w_DLon_w</a>&nbsp;&nbsp;

        <a href="#M001235">w_DivLambda_xy</a>&nbsp;&nbsp;

        <a href="#M001230">w_DivLat_xy</a>&nbsp;&nbsp;

        <a href="#M001229">w_DivLon_xy</a>&nbsp;&nbsp;

        <a href="#M001236">w_DivMu_xy</a>&nbsp;&nbsp;

        <a href="#M001231">w_Div_xy_xy</a>&nbsp;&nbsp;

        <a href="#M001232">w_Jacobian_w_w</a>&nbsp;&nbsp;

        <a href="#M001225">w_LaplaInv_w</a>&nbsp;&nbsp;

        <a href="#M001224">w_Lapla_w</a>&nbsp;&nbsp;

        <a href="#M001258">w_spectrum_VMiss</a>&nbsp;&nbsp;

        <a href="#M001215">w_xy</a>&nbsp;&nbsp;

        <a href="#M001182">wa_DLon_wa</a>&nbsp;&nbsp;

        <a href="#M001191">wa_DivLambda_xya</a>&nbsp;&nbsp;

        <a href="#M001186">wa_DivLat_xya</a>&nbsp;&nbsp;

        <a href="#M001185">wa_DivLon_xya</a>&nbsp;&nbsp;

        <a href="#M001192">wa_DivMu_xya</a>&nbsp;&nbsp;

        <a href="#M001187">wa_Div_xya_xya</a>&nbsp;&nbsp;

        <a href="#M001179">wa_Initial</a>&nbsp;&nbsp;

        <a href="#M001188">wa_Jacobian_wa_wa</a>&nbsp;&nbsp;

        <a href="#M001238">wa_LaplaInv_wa</a>&nbsp;&nbsp;

        <a href="#M001237">wa_Lapla_wa</a>&nbsp;&nbsp;

        <a href="#M001178">wa_spectrum_VMiss</a>&nbsp;&nbsp;

        <a href="#M001181">wa_xya</a>&nbsp;&nbsp;

        <a href="#M001249">x_AvrLat_xy</a>&nbsp;&nbsp;

        <a href="#M001243">x_IntLat_xy</a>&nbsp;&nbsp;

        <a href="#M001206">x_Lon</a>&nbsp;&nbsp;

        <a href="#M001209">x_Lon_Weight</a>&nbsp;&nbsp;

        <a href="#M001199">xa_AvrLat_xya</a>&nbsp;&nbsp;

        <a href="#M001195">xa_IntLat_xya</a>&nbsp;&nbsp;

        <a href="#M001233">xy_GradLambda_w</a>&nbsp;&nbsp;

        <a href="#M001228">xy_GradLat_w</a>&nbsp;&nbsp;

        <a href="#M001227">xy_GradLon_w</a>&nbsp;&nbsp;

        <a href="#M001234">xy_GradMu_w</a>&nbsp;&nbsp;

        <a href="#M001213">xy_Lat</a>&nbsp;&nbsp;

        <a href="#M001212">xy_Lon</a>&nbsp;&nbsp;

        <a href="#M001214">xy_w</a>&nbsp;&nbsp;

        <a href="#M001189">xya_GradLambda_wa</a>&nbsp;&nbsp;

        <a href="#M001184">xya_GradLat_wa</a>&nbsp;&nbsp;

        <a href="#M001183">xya_GradLon_wa</a>&nbsp;&nbsp;

        <a href="#M001190">xya_GradMu_wa</a>&nbsp;&nbsp;

        <a href="#M001180">xya_wa</a>&nbsp;&nbsp;

        <a href="#M001247">y_AvrLon_xy</a>&nbsp;&nbsp;

        <a href="#M001241">y_IntLon_xy</a>&nbsp;&nbsp;

        <a href="#M001208">y_Lat</a>&nbsp;&nbsp;

        <a href="#M001207">y_Lat</a>&nbsp;&nbsp;

        <a href="#M001211">y_Lat_Weight</a>&nbsp;&nbsp;

        <a href="#M001210">y_Lat_Weight</a>&nbsp;&nbsp;

        <a href="#M001200">ya_AvrLon_xya</a>&nbsp;&nbsp;

        <a href="#M001196">ya_IntLon_xya</a>&nbsp;&nbsp;
      </div>
    </div>


  </div>


    <!-- if includes -->

    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">

        <span class="include-name">dc_message</span>

        <span class="include-name"><a href="w_zonal_module.html">w_zonal_module</a></span>

        <span class="include-name"><a href="la_module.html">la_module</a></span>
      </div>
    </div>



    <div id="section">










      


    <!-- if method_list -->

    <div id="methods">


      <h3 class="section-bar">Public Instance methods</h3>


      <div id="method-M001251" class="method-detail">
        <a name="M001251"></a>

        <div class="method-heading">




          <span class="method-name">AvrLat_y</span><span class="method-args">( y_data ) result(AvrLat_y)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001250">AvrLat_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y_data(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(Y)格子点データの緯度(Y)方向平均.
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, y_Y_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="la_module.html#M000777">la_module#AvrLat_y</a>
</p>


        </div>
      </div>


      <div id="method-M001250" class="method-detail">
        <a name="M001250"></a>

        <div class="method-heading">




          <span class="method-name">AvrLat_y</span><span class="method-args">( y_data ) result(AvrLat_y)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001250">AvrLat_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y_data(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(Y)格子点データの緯度(Y)方向平均.
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, y_Y_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001909">w_zonal_module#AvrLat_y</a>
</p>


        </div>
      </div>


      <div id="method-M001246" class="method-detail">
        <a name="M001246"></a>

        <div class="method-heading">




          <span class="method-name">AvrLonLat_xy</span><span class="method-args">( xy_data ) result(AvrLonLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001246">AvrLonLat_xy</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの全領域平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた 総和を計算し,
x_X_Weight*y_Y_Weight の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001893">w_zonal_module#AvrLonLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001248" class="method-detail">
        <a name="M001248"></a>

        <div class="method-heading">




          <span class="method-name">AvrLon_x</span><span class="method-args">( x_data ) result(AvrLon_x)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001248">AvrLon_x</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>x_data(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(X)格子点データの経度(X)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, x_X_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001890">w_zonal_module#AvrLon_x</a>
</p>


        </div>
      </div>


      <div id="method-M001245" class="method-detail">
        <a name="M001245"></a>

        <div class="method-heading">




          <span class="method-name">IntLat_y</span><span class="method-args">( y_data ) result(IntLat_y)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001244">IntLat_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y_data(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元緯度(Y)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元緯度(Y)格子点データの Y 方向積分.
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="la_module.html#M000776">la_module#IntLat_y</a>
</p>


        </div>
      </div>


      <div id="method-M001244" class="method-detail">
        <a name="M001244"></a>

        <div class="method-heading">




          <span class="method-name">IntLat_y</span><span class="method-args">( y_data ) result(IntLat_y)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001244">IntLat_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y_data(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元緯度(Y)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元緯度(Y)格子点データの Y 方向積分.
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001908">w_zonal_module#IntLat_y</a>
</p>


        </div>
      </div>


      <div id="method-M001240" class="method-detail">
        <a name="M001240"></a>

        <div class="method-heading">




          <span class="method-name">IntLonLat_xy</span><span class="method-args">( xy_data ) result(IntLonLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001240">IntLonLat_xy</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの全領域積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた
総和を計算している.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001889">w_zonal_module#IntLonLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001242" class="method-detail">
        <a name="M001242"></a>

        <div class="method-heading">




          <span class="method-name">IntLon_x</span><span class="method-args">( x_data ) result(IntLon_x)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001242">IntLon_x</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>x_data(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元経度(X)格子点データの X 方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001886">w_zonal_module#IntLon_x</a>
</p>


        </div>
      </div>


      <div id="method-M001239" class="method-detail">
        <a name="M001239"></a>

        <div class="method-heading">




          <span class="method-name">Interpolate_w</span><span class="method-args">( w_data, alon, alat ) result(Interpolate_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001239">Interpolate_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間した値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>alon  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間する位置(経度)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>alat  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間する位置(緯度)

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001885">w_zonal_module#Interpolate_w</a>
</p>


        </div>
      </div>


      <div id="method-M001253" class="method-detail">
        <a name="M001253"></a>

        <div class="method-heading">




          <span class="method-name">a_AvrLat_ya</span><span class="method-args">( ya_data ) result(a_AvrLat_ya)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001253">a_AvrLat_ya</a>(size(ya_data,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ya_data(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 緯度鉛直格子点データ(1:jm,:)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度鉛直格子点データの緯度(Y)方向平均.
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, y_Y_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="la_module.html#M000764">la_module#a_AvrLat_ya</a>
</p>


        </div>
      </div>


      <div id="method-M001198" class="method-detail">
        <a name="M001198"></a>

        <div class="method-heading">


          <a href="#M001198" class="method-signature">



          <span class="method-name">a_AvrLonLat_xya</span><span class="method-args">( xya_data ) result(a_AvrLonLat_xya)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001198">a_AvrLonLat_xya</a>(size(xya_data,3))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値の並び(*)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xya_data(0:,:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データの並び(0:im-1,1:jm,*)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの全領域平均(多層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた 総和を計算し,
x_X_Weight*y_Y_Weight の総和で割ることで平均している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001198-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001198-source">
<pre>
    function a_AvrLonLat_xya(xya_data)
      !
      ! 2 次元緯度経度格子点データの全領域平均(多層用).
      !
      ! 実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた
      ! 総和を計算し, x_X_Weight*y_Y_Weight の総和で割ることで平均している. 
      !
      real(8), intent(in)   :: xya_data(0:,:,:)
      !(in) 2 次元経度緯度格子点データの並び(0:im-1,1:jm,*)

      real(8) :: a_AvrLonLat_xya(size(xya_data,3))
      !(out) 平均値の並び(*)

      a_AvrLonLat_xya = a_AvrLon_xa(xa_AvrLat_xya(xya_data))

    end function a_AvrLonLat_xya
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001201" class="method-detail">
        <a name="M001201"></a>

        <div class="method-heading">


          <a href="#M001201" class="method-signature">



          <span class="method-name">a_AvrLon_xa</span><span class="method-args">( xa_data ) result(a_AvrLon_xa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001201">a_AvrLon_xa</a>(size(xa_data,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値の並び(*)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xa_data(0:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元経度(X)格子点データの並び(0:im-1,*)

</td></tr>
</table>
</td></tr>
</table>
<p>
経度平均
</p>
<p>
1 次元(X)格子点データの経度(X)方向平均(多層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, x_X_Weight
の総和で割ることで平均している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001201-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001201-source">
<pre>
    function a_AvrLon_xa(xa_data)          ! 経度平均
      !
      ! 1 次元(X)格子点データの経度(X)方向平均(多層用).
      !
      ! 実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, 
      ! x_X_Weight の総和で割ることで平均している. 
      !
      real(8), intent(in) :: xa_data(0:,:)
      !(in)  1 次元経度(X)格子点データの並び(0:im-1,*)

      real(8)             :: a_AvrLon_xa(size(xa_data,2))
      !(out) 平均値の並び(*)

      a_AvrLon_xa = a_IntLon_xa(xa_data)/sum(x_Lon_Weight)

    end function a_AvrLon_xa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001252" class="method-detail">
        <a name="M001252"></a>

        <div class="method-heading">




          <span class="method-name">a_IntLat_ya</span><span class="method-args">( ya_data ) result(a_IntLat_ya)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001252">a_IntLat_ya</a>(size(ya_data,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ya_data(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 緯度鉛直格子点データ(1:jm,:)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度鉛直格子点データの緯度方向積分.
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="la_module.html#M000763">la_module#a_IntLat_ya</a>
</p>


        </div>
      </div>


      <div id="method-M001194" class="method-detail">
        <a name="M001194"></a>

        <div class="method-heading">


          <a href="#M001194" class="method-signature">



          <span class="method-name">a_IntLonLat_xya</span><span class="method-args">( xya_data ) result(a_IntLonLat_xya)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001194">a_IntLonLat_xya</a>(size(xya_data,3))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分されたデータの並び(*)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xya_data(0:,:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データの並び(0:im-1,1:jm,*)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの全領域積分(多層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた
総和を計算している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001194-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001194-source">
<pre>
    function a_IntLonLat_xya(xya_data)
      !
      ! 2 次元緯度経度格子点データの全領域積分(多層用). 
      !
      ! 実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた
      ! 総和を計算している. 
      !
      real(8), intent(in)   :: xya_data(0:,:,:)
      !(in) 2 次元経度緯度格子点データの並び(0:im-1,1:jm,*)
      real(8) :: a_IntLonLat_xya(size(xya_data,3))
      !(out) 積分されたデータの並び(*)

      a_IntLonLat_xya = a_IntLon_xa(xa_IntLat_xya(xya_data))

    end function a_IntLonLat_xya
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001197" class="method-detail">
        <a name="M001197"></a>

        <div class="method-heading">


          <a href="#M001197" class="method-signature">



          <span class="method-name">a_IntLon_xa</span><span class="method-args">( xa_data ) result(a_IntLon_xa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001197">a_IntLon_xa</a>(size(xa_data,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値の並び(*)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xa_data(0:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元経度(X)格子点データの並び(0:im-1,*)

</td></tr>
</table>
</td></tr>
</table>
<p>
経度積分
</p>
<p>
1 次元経度(X)格子点データの X 方向積分(多層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001197-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001197-source">
<pre>
    function a_IntLon_xa(xa_data)          ! 経度積分
      !
      ! 1 次元経度(X)格子点データの X 方向積分(多層用).
      !
      ! 実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している. 
      !
      real(8), intent(in) :: xa_data(0:,:)
      !(in)  1 次元経度(X)格子点データの並び(0:im-1,*)
      real(8)             :: a_IntLon_xa(size(xa_data,2))
      !(out) 積分値の並び(*)
      integer :: i

      a_IntLon_xa = 0.0D0
      do i=0,im-1
         a_IntLon_xa = a_IntLon_xa + xa_data(i,:) * x_Lon_Weight(i)
      enddo

    end function a_IntLon_xa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001193" class="method-detail">
        <a name="M001193"></a>

        <div class="method-heading">


          <a href="#M001193" class="method-signature">



          <span class="method-name">a_Interpolate_wa</span><span class="method-args">( wa_data, alon, alat ) result(a_Interpolate_wa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001193">a_Interpolate_wa</a>(size(wa_data,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間した値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_data(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>alon  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間する位置(経度)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>alat  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間する位置(緯度)

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度 alon, 経度 alat における関数値を その球面調和変換係数 wa_data
から補間計算する
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001193-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001193-source">
<pre>
    function a_Interpolate_wa(wa_data,alon,alat)
      !
      ! 緯度 alon, 経度 alat における関数値を
      ! その球面調和変換係数 wa_data から補間計算する
      !
      real(8), intent(IN) :: wa_data(:,:)             ! スペクトルデータ
      real(8), intent(IN) :: alon                     ! 補間する位置(経度)
      real(8), intent(IN) :: alat                     ! 補間する位置(緯度)
      real(8) :: a_Interpolate_wa(size(wa_data,2))    ! 補間した値

      integer :: k

      do k=1,size(wa_data,2)
         a_Interpolate_wa(k) = Interpolate_w(wa_data(:,k),alon,alat)
      enddo

    end function a_Interpolate_wa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001223" class="method-detail">
        <a name="M001223"></a>

        <div class="method-heading">




          <span class="method-name">irm</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001223">irm</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, allocatable</tt>

</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001869">w_zonal_module#irm</a>
</p>


        </div>
      </div>


      <div id="method-M001216" class="method-detail">
        <a name="M001216"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( n, m ) result(l_nm_array00)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array00  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>n  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>m  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m,ダミー)からそのスペクトルデータの格納位置を返す.
</p>
<p>
引数 n,m がともに整数値の場合, 整数値を返す.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001898">w_zonal_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M001217" class="method-detail">
        <a name="M001217"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( n, marray ) result(l_nm_array01)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array01(size(marray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>n  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>marray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置
</p>
<p>
全波数(n)と東西波数(m, ダミー)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1 引数 n が整数, 第 2 引数 marray が整数 1 次元配列の場合, marray
と同じ大きさの 1 次元整数配列を返す.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001898">w_zonal_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M001218" class="method-detail">
        <a name="M001218"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( narray, m ) result(l_nm_array10)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array10(size(narray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>narray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>m  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m,ダミー)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1 引数 narray が整数 1 次元配列, 第 2 引数 m が整数の場合, narray
と同じ大きさの 1 次元整数配列を返す.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001898">w_zonal_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M001219" class="method-detail">
        <a name="M001219"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( narray, marray ) result(l_nm_array11)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array11(size(narray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>narray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>marray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1,2 引数 narray, marray がともに整数 1 次元配列の場合, narray, marray
と同じ大きさの 1 次元整数配列を返す. narray, marray
は同じ大きさでなければならない.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001898">w_zonal_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M001255" class="method-detail">
        <a name="M001255"></a>

        <div class="method-heading">




          <span class="method-name">n_EnergyFromStreamfunc_w</span><span class="method-args">( w_Strfunc ) result(n_EnergyFromStreamfunc_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001255">n_EnergyFromStreamfunc_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトル (水平全波数 n 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_Strfunc(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータから各全波数のエネルギー成分(スペクトル)を
計算する(1 層用).
</p>
<pre>
 * 全波数 n の流線関数のスペクトル成分ψ(n,m) から
   エネルギースペクトルはΣ[m=-nm]^nm(1/2)n(n+1)ψ(n,m)^2
   と計算される.

 * 全てのエネルギースペクトル成分の和に 4πをかけたものが
   球面上での全エネルギーに等しい.
</pre>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001895">w_zonal_module#n_EnergyFromStreamfunc_w</a>
</p>


        </div>
      </div>


      <div id="method-M001257" class="method-detail">
        <a name="M001257"></a>

        <div class="method-heading">




          <span class="method-name">n_EnstrophyFromStreamfunc_w</span><span class="method-args">( w_Strfunc ) result(n_EnstrophyFromStreamfunc_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001257">n_EnstrophyFromStreamfunc_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エンストロフィースペクトル(水平全波数 n 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_Strfunc(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータから各全波数のエネルギー成分(スペクトル)を
計算する(1 層用)
</p>
<ul>
<li>全波数 n の流線関数のスペクトル成分ψ(n,m) からエンストロフィー
スペクトルはΣ[m=-nm]^nm(1/2)n^2(n+1)^2ψ(n,m)^2 と計算される.

</li>
<li>全てのエネルギースペクトル成分の和に 4π/R^2 をかけたものが
球面上での全エンストフィーに等しい.

</li>
</ul>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001897">w_zonal_module#n_EnstrophyFromStreamfunc_w</a>
</p>


        </div>
      </div>


      <div id="method-M001203" class="method-detail">
        <a name="M001203"></a>

        <div class="method-heading">


          <a href="#M001203" class="method-signature">



          <span class="method-name">na_EnergyFromStreamfunc_wa</span><span class="method-args">( wa_Strfunc ) result(na_EnergyFromStreamfunc_wa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001203">na_EnergyFromStreamfunc_wa</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,size(wa_Strfunc,2))</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトル (水平全波数 n 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_Strfunc(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータから各全波数のエネルギー成分(スペクトル)を
計算する(多層用).
</p>
<pre>
 * 全波数 n の流線関数のスペクトル成分ψ(n,m) から
   エネルギースペクトルはΣ[m=-nm]^nm(1/2)n(n+1)ψ(n,m)^2
   と計算される.

 * 全てのエネルギースペクトル成分の和に 4πをかけたものが
   球面上での全エネルギーに等しい.
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001203-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001203-source">
<pre>
    function na_EnergyFromStreamfunc_wa(wa_Strfunc)
      !
      ! 流線関数のスペクトルデータから各全波数のエネルギー成分(スペクトル)を
      ! 計算する(多層用).
      !
      !  * 全波数 n の流線関数のスペクトル成分ψ(n,m) から
      !    エネルギースペクトルはΣ[m=-nm]^nm(1/2)n(n+1)ψ(n,m)^2 
      !    と計算される.
      !
      !  * 全てのエネルギースペクトル成分の和に 4πをかけたものが
      !    球面上での全エネルギーに等しい.
      !
      real(8), intent(in)   :: wa_Strfunc(:,:)
      !(in) 流線関数(スペクトルデータ)

      real(8), dimension(0:nm,size(wa_Strfunc,2)) :: na_EnergyFromStreamfunc_wa
      !(out) エネルギースペクトル (水平全波数 n 空間) 

      integer :: n

      do n=0,nm
         na_EnergyFromStreamfunc_wa(n,:) = 0.5 * n*(n+1) * wa_StrFunc(l_nm(n,0),:)**2
      enddo

    end function na_EnergyFromStreamfunc_wa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001205" class="method-detail">
        <a name="M001205"></a>

        <div class="method-heading">


          <a href="#M001205" class="method-signature">



          <span class="method-name">na_EnstrophyFromStreamfunc_wa</span><span class="method-args">( wa_Strfunc ) result(na_EnstrophyFromStreamfunc_wa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001205">na_EnstrophyFromStreamfunc_wa</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,size(wa_Strfunc,2))</tt>

<table>
<tr><td valign="top"> :</td><td> エンストロフィースペクトル (out) エンストロフィースペクトル(水平全波数 n
空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_Strfunc(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータから各全波数のエネルギー成分(スペクトル)を
計算する(多層用)
</p>
<ul>
<li>全波数 n の流線関数のスペクトル成分ψ(n,m) からエンストロフィー
スペクトルはΣ[m=-nm]^nm(1/2)n^2(n+1)^2ψ(n,m)^2 と計算される.

</li>
<li>全てのエネルギースペクトル成分の和に 4π/R^2 をかけたものが
球面上での全エンストフィーに等しい.

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001205-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001205-source">
<pre>
    function na_EnstrophyFromStreamfunc_wa(wa_Strfunc)  ! 
      !
      ! 流線関数のスペクトルデータから各全波数のエネルギー成分(スペクトル)を
      ! 計算する(多層用)
      !
      ! * 全波数 n の流線関数のスペクトル成分ψ(n,m) からエンストロフィー
      !   スペクトルはΣ[m=-nm]^nm(1/2)n^2(n+1)^2ψ(n,m)^2 と計算される.
      !    
      ! * 全てのエネルギースペクトル成分の和に 4π/R^2 をかけたものが
      !   球面上での全エンストフィーに等しい.
      !
      real(8), intent(in)   :: wa_Strfunc(:,:)
      !(in) 流線関数(スペクトルデータ)

      real(8), dimension(0:nm,size(wa_Strfunc,2)) :: na_EnstrophyFromStreamfunc_wa      ! エンストロフィースペクトル
      !(out) エンストロフィースペクトル(水平全波数 n 空間)

      integer :: n

      do n=0,nm
         na_EnstrophyFromStreamfunc_wa(n,:) = 0.5 * n**2 * (n+1)**2 * wa_StrFunc(l_nm(n,0),:)**2
      enddo

    end function na_EnstrophyFromStreamfunc_wa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001254" class="method-detail">
        <a name="M001254"></a>

        <div class="method-heading">




          <span class="method-name">nm_EnergyFromStreamfunc_w</span><span class="method-args">( w_Strfunc ) result(nm_EnergyFromStreamfunc_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001254">nm_EnergyFromStreamfunc_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,-nm:nm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトル(水平全波数 n, 帯状波数 m 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_Strfunc(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータからエネルギーの球面調和函数成分
(スペクトル)を計算する(1 層用).
</p>
<pre>
 * 全波数 n, 帯状波数 m の流線関数のスペクトル成分ψ(n,m) から
   エネルギースペクトルは (1/2)n(n+1)ψ(n,m)^2 と計算される.

 * 全てのエネルギースペクトル成分の和に4πをかけたものが球面上での
   全エネルギーに等しい.

 * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
   欠損値の値はモジュール変数 w_spectrum_VMiss によって設定できる
   (初期値は -999.0)
</pre>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001894">w_zonal_module#nm_EnergyFromStreamfunc_w</a>
</p>


        </div>
      </div>


      <div id="method-M001256" class="method-detail">
        <a name="M001256"></a>

        <div class="method-heading">




          <span class="method-name">nm_EnstrophyFromStreamfunc_w</span><span class="method-args">( w_Strfunc ) result(nm_EnstrophyFromStreamfunc_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001256">nm_EnstrophyFromStreamfunc_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,-nm:nm)</tt>

<table>
<tr><td valign="top"> :</td><td> エンストロフィースペクトル (水平全波数 n, 帯状波数 m 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_Strfunc(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータからエンストロフィーの球面調和函数成分
(スペクトル)を計算する(1 層用).
</p>
<ul>
<li>全波数 n, 帯状波数 m の流線関数のスペクトル成分ψ(n,m) から

<pre>
 エンストロフィースペクトルは (1/2)n^2(n+1)^2ψ(n,m)^2 と計算される.
</pre>
</li>
<li>全てのエンストロフィースペクトル成分の和に4π/R^2をかけたものが
球面上での全エンストロフィーに等しい. ここで R は球面の半径である.

</li>
<li>データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
欠損値の値はモジュール変数 <a
href="wa_zonal_module.html#M001258">w_spectrum_VMiss</a> によって設定できる
(初期値は -999.0)

</li>
</ul>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001896">w_zonal_module#nm_EnstrophyFromStreamfunc_w</a>
</p>


        </div>
      </div>


      <div id="method-M001220" class="method-detail">
        <a name="M001220"></a>

        <div class="method-heading">




          <span class="method-name">nm_l</span><span class="method-args">( l ) result(nm_l_int)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>nm_l_int(2)  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全波数, 帯状波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>l  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置(l)から全波数(n)と東西波数(m)を返す.
</p>
<p>
引数 l が整数値の場合, 対応する全波数と帯状波数を 長さ 2 の 1
次元整数値を返す. <a href="wa_zonal_module.html#M001220">nm_l</a>(1)
が全波数, <a href="wa_zonal_module.html#M001220">nm_l</a>(2)
が帯状波数である.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001902">w_zonal_module#nm_l</a>
</p>


        </div>
      </div>


      <div id="method-M001221" class="method-detail">
        <a name="M001221"></a>

        <div class="method-heading">




          <span class="method-name">nm_l</span><span class="method-args">( larray ) result(nm_l_array)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>nm_l_array(size(larray),2)  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>larray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全波数, 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置(l)から全波数(n)と東西波数(m)を返す.
</p>
<p>
引数 larray が整数 1 次元配列の場合, larray に対応する n, m を格納した 2
次元整数配列を返す. nm_l_array(:,1) が全波数, nm_l_array(:,2)
が帯状波数である.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001902">w_zonal_module#nm_l</a>
</p>


        </div>
      </div>


      <div id="method-M001202" class="method-detail">
        <a name="M001202"></a>

        <div class="method-heading">


          <a href="#M001202" class="method-signature">



          <span class="method-name">nma_EnergyFromStreamfunc_wa</span><span class="method-args">( wa_Strfunc ) result(nma_EnergyFromStreamfunc_wa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001202">nma_EnergyFromStreamfunc_wa</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,-nm:nm,size(wa_Strfunc,2))</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトル(水平全波数 n, 帯状波数 m 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_Strfunc(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータからエネルギーの球面調和函数成分
(スペクトル)を計算する(多層用).
</p>
<pre>
 * 全波数 n, 帯状波数 m の流線関数のスペクトル成分ψ(n,m) から
   エネルギースペクトルは (1/2)n(n+1)ψ(n,m)^2 と計算される.

 * 全てのエネルギースペクトル成分の和に4πをかけたものが球面上での
   全エネルギーに等しい.

 * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
   欠損値の値はモジュール変数 wa_spectrum_VMiss によって設定できる
   (初期値は -999.0)
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001202-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001202-source">
<pre>
    function nma_EnergyFromStreamfunc_wa(wa_Strfunc)
      ! 
      ! 流線関数のスペクトルデータからエネルギーの球面調和函数成分
      ! (スペクトル)を計算する(多層用).
      !
      !  * 全波数 n, 帯状波数 m の流線関数のスペクトル成分ψ(n,m) から
      !    エネルギースペクトルは (1/2)n(n+1)ψ(n,m)^2 と計算される.
      !
      !  * 全てのエネルギースペクトル成分の和に4πをかけたものが球面上での
      !    全エネルギーに等しい.
      !
      !  * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
      !    欠損値の値はモジュール変数 wa_spectrum_VMiss によって設定できる
      !    (初期値は -999.0)
      !
      real(8), intent(in)   :: wa_Strfunc(:,:)
      !(in) 流線関数(スペクトルデータ)

      real(8), dimension(0:nm,-nm:nm,size(wa_Strfunc,2)) :: nma_EnergyFromStreamfunc_wa
      !(out) エネルギースペクトル(水平全波数 n, 帯状波数 m 空間)

      integer :: n, m

      nma_EnergyFromStreamfunc_wa = wa_spectrum_VMiss

      do n=0,nm
         do m=1,n
            nma_EnergyFromStreamfunc_wa(n,m,:)  = 0.0D0
            nma_EnergyFromStreamfunc_wa(n,-m,:) = 0.0D0
         enddo
         nma_EnergyFromStreamfunc_wa(n,0,:) = 0.5 * n*(n+1) * wa_Strfunc(l_nm(n,0),:)**2
      enddo

    end function nma_EnergyFromStreamfunc_wa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001204" class="method-detail">
        <a name="M001204"></a>

        <div class="method-heading">


          <a href="#M001204" class="method-signature">



          <span class="method-name">nma_EnstrophyFromStreamfunc_wa</span><span class="method-args">( wa_Strfunc ) result(nma_EnstrophyFromStreamfunc_wa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001204">nma_EnstrophyFromStreamfunc_wa</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,-nm:nm,size(wa_Strfunc,2))</tt>

<table>
<tr><td valign="top"> :</td><td> エンストロフィースペクトル (水平全波数 n, 帯状波数 m 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_Strfunc(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータからエンストロフィーの球面調和函数成分
(スペクトル)を計算する(多層用).
</p>
<ul>
<li>全波数 n, 帯状波数 m の流線関数のスペクトル成分ψ(n,m) から

<pre>
 エンストロフィースペクトルは (1/2)n^2(n+1)^2ψ(n,m)^2 と計算される.
</pre>
</li>
<li>全てのエンストロフィースペクトル成分の和に4π/R^2をかけたものが
球面上での全エンストロフィーに等しい. ここで R は球面の半径である.

</li>
<li>データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
欠損値の値はモジュール変数 <a
href="wa_zonal_module.html#M001178">wa_spectrum_VMiss</a>
によって設定できる (初期値は -999.0)

</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001204-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001204-source">
<pre>
    function nma_EnstrophyFromStreamfunc_wa(wa_Strfunc)  ! 
      !
      ! 流線関数のスペクトルデータからエンストロフィーの球面調和函数成分
      ! (スペクトル)を計算する(多層用). 
      !
      ! * 全波数 n, 帯状波数 m の流線関数のスペクトル成分ψ(n,m) から
      !    エンストロフィースペクトルは (1/2)n^2(n+1)^2ψ(n,m)^2 と計算される.
      !
      ! * 全てのエンストロフィースペクトル成分の和に4π/R^2をかけたものが
      !   球面上での全エンストロフィーに等しい. ここで R は球面の半径である.
      !
      ! * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
      !   欠損値の値はモジュール変数 wa_spectrum_VMiss によって設定できる
      !   (初期値は -999.0)
      !
      real(8), intent(in)   :: wa_Strfunc(:,:)
      !(in) 流線関数(スペクトルデータ)

      real(8), dimension(0:nm,-nm:nm,size(wa_Strfunc,2)) :: nma_EnstrophyFromStreamfunc_wa
      ! エンストロフィースペクトル (水平全波数 n, 帯状波数 m 空間)

      integer :: n, m

      nma_EnstrophyFromStreamfunc_wa = wa_spectrum_VMiss

      do n=0,nm
         do m=1,n
            nma_EnstrophyFromStreamfunc_wa(n,m,:) = 0.0
            nma_EnstrophyFromStreamfunc_wa(n,-m,:) = 0.0
         enddo
         nma_EnstrophyFromStreamfunc_wa(n,0,:) = 0.5 * n**2 * (n+1)**2 * wa_Strfunc(l_nm(n,0),:)**2
      enddo

    end function nma_EnstrophyFromStreamfunc_wa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001222" class="method-detail">
        <a name="M001222"></a>

        <div class="method-heading">




          <span class="method-name">rn</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001222">rn</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001868">w_zonal_module#rn</a>
</p>


        </div>
      </div>


      <div id="method-M001226" class="method-detail">
        <a name="M001226"></a>

        <div class="method-heading">




          <span class="method-name">w_DLon_w</span><span class="method-args">( w_data ) result(w_DLon_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001226">w_DLon_w</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの経度微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに経度微分 ∂/∂λ を作用させる(1 層用).
</p>
<p>
スペクトルデータの経度微分とは, 対応する格子点データに
経度微分∂/∂λを作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001874">w_zonal_module#w_DLon_w</a>
</p>


        </div>
      </div>


      <div id="method-M001235" class="method-detail">
        <a name="M001235"></a>

        <div class="method-heading">




          <span class="method-name">w_DivLambda_xy</span><span class="method-args">( xy_data ) result(w_DivLambda_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001235">w_DivLambda_xy</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型経度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型経度微分 1/(1-μ^2)・∂/∂λ (μ=sinφ)
を作用させてスペクトルデータに変換して返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001883">w_zonal_module#w_DivLambda_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001230" class="method-detail">
        <a name="M001230"></a>

        <div class="method-heading">




          <span class="method-name">w_DivLat_xy</span><span class="method-args">( xy_data ) result(w_DivLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001230">w_DivLat_xy</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型緯度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型緯度微分 1/cosφ・∂(f cosφ)/∂φ を作用させて
スペクトルデータに変換して返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001878">w_zonal_module#w_DivLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001229" class="method-detail">
        <a name="M001229"></a>

        <div class="method-heading">




          <span class="method-name">w_DivLon_xy</span><span class="method-args">( xy_data ) result(w_DivLon_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001229">w_DivLon_xy</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型経度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型経度微分 1/cosφ・∂/∂λ を作用させて
スペクトルデータに変換して返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001877">w_zonal_module#w_DivLon_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001236" class="method-detail">
        <a name="M001236"></a>

        <div class="method-heading">




          <span class="method-name">w_DivMu_xy</span><span class="method-args">( xy_data ) result(w_DivMu_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001236">w_DivMu_xy</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型緯度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型緯度微分 ∂/∂μ (μ=sinφ)を作用させて
スペクトルデータに変換して返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001884">w_zonal_module#w_DivMu_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001231" class="method-detail">
        <a name="M001231"></a>

        <div class="method-heading">




          <span class="method-name">w_Div_xy_xy</span><span class="method-args">( xy_u, xy_v ) result(w_Div_xy_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001231">w_Div_xy_xy</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 つの入力格子点データをベクトル成分とする発散のスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_u(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル経度成分の格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_v(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル緯度成分の格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 つの入力格子点データをベクトル成分とする発散を計算し,
スペクトルデータとして返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001879">w_zonal_module#w_Div_xy_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001232" class="method-detail">
        <a name="M001232"></a>

        <div class="method-heading">




          <span class="method-name">w_Jacobian_w_w</span><span class="method-args">( w_a, w_b ) result(w_Jacobian_w_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001232">w_Jacobian_w_w</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 つのスペクトルデータのヤコビアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_a((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1つ目の入力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_b((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2つ目の入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 つのスペクトルデータにヤコビアン
</p>
<pre>
  J(f,g) = ∂f/∂λ・∂g/∂μ - ∂g/∂λ・∂f/∂μ
         = ∂f/∂λ・1/cosφ・∂g/∂φ
            - ∂g/∂λ・1/cosφ・∂f/∂φ
</pre>
<p>
を作用させる(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001880">w_zonal_module#w_Jacobian_w_w</a>
</p>


        </div>
      </div>


      <div id="method-M001225" class="method-detail">
        <a name="M001225"></a>

        <div class="method-heading">




          <span class="method-name">w_LaplaInv_w</span><span class="method-args">( l_data ) result(l_LaplaInv_l)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_LaplaInv_l(0:nm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの逆ラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>l_data(0:nm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに逆ラプラシアン
</p>
<pre>
   ▽^{-2}
     =[1/cosφ・∂/∂φ(cosφ∂/∂φ)]^{-1}
</pre>
<p>
を作用する.
</p>
<p>
スペクトルデータの逆ラプラシアンとは, 対応する格子点データに
逆ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001907">w_zonal_module#w_LaplaInv_w</a>
</p>


        </div>
      </div>


      <div id="method-M001224" class="method-detail">
        <a name="M001224"></a>

        <div class="method-heading">




          <span class="method-name">w_Lapla_w</span><span class="method-args">( l_data ) result(l_Lapla_l)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_Lapla_l(0:nm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 入力スペクトルデータのラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>l_data(0:nm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータにラプラシアン
</p>
<pre>
   ▽^2 = 1/cosφ・∂/∂φ(cosφ∂/∂φ)
</pre>
<p>
を作用する.
</p>
<p>
スペクトルデータのラプラシアンとは, 対応する格子点データに
ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001906">w_zonal_module#w_Lapla_w</a>
</p>


        </div>
      </div>


      <div id="method-M001258" class="method-detail">
        <a name="M001258"></a>

        <div class="method-heading">




          <span class="method-name">w_spectrum_VMiss</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001258">w_spectrum_VMiss</a>  </tt></b>  <tt> = -999.000    </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 欠損値初期値

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001870">w_zonal_module#w_spectrum_VMiss</a>
</p>


        </div>
      </div>


      <div id="method-M001215" class="method-detail">
        <a name="M001215"></a>

        <div class="method-heading">




          <span class="method-name">w_xy</span><span class="method-args">( xy_data, [ipow], [iflag] ) result(w_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001215">w_xy</a>(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ipow  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 変換時に同時に作用させる 1/cosφ の次数. 省略時は 0.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>iflag  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> 変換の種類

<pre>
   0 : 通常の正変換
   1 : 緯度微分 1/cosφ・∂(f cos^2φ)/∂φ を作用させた正変換
  -1 : 緯度微分を作用させた正変換
   2 : sinφを作用させた正変換
 省略時は 0.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからスペクトルデータへ(正)変換する(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001873">w_zonal_module#w_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001182" class="method-detail">
        <a name="M001182"></a>

        <div class="method-heading">


          <a href="#M001182" class="method-signature">



          <span class="method-name">wa_DLon_wa</span><span class="method-args">( wa_data ) result(wa_DLon_wa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001182">wa_DLon_wa</a>(nm+1,size(wa_data,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの経度微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_data(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに経度微分 ∂/∂λ を作用させる(多層用).
</p>
<p>
スペクトルデータの経度微分とは, 対応する格子点データに
経度微分∂/∂λを作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001182-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001182-source">
<pre>
    function wa_DLon_wa(wa_data)
      !
      ! スペクトルデータに経度微分 ∂/∂λ を作用させる(多層用).
      !
      ! スペクトルデータの経度微分とは, 対応する格子点データに
      ! 経度微分∂/∂λを作用させたデータのスペクトル変換のことである.
      ! 
      real(8), intent(in)  :: wa_data(:,:)
      !(in) 入力スペクトルデータ
      real(8)              :: wa_DLon_wa(nm+1,size(wa_data,2))
      !(out) スペクトルデータの経度微分

      wa_DLon_wa = 0.0D0

    end function wa_DLon_wa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001191" class="method-detail">
        <a name="M001191"></a>

        <div class="method-heading">


          <a href="#M001191" class="method-signature">



          <span class="method-name">wa_DivLambda_xya</span><span class="method-args">( xya_data ) result(wa_DivLambda_xya)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001191">wa_DivLambda_xya</a>(nm+1,size(xya_data,3))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型経度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xya_data(0:,:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型経度微分 1/(1-μ^2)・∂/∂λ (μ=sinφ)
を作用させてスペクトルデータに変換して返す(多層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001191-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001191-source">
<pre>
    function wa_DivLambda_xya(xya_data)
      !
      ! 格子点データに発散型経度微分 1/(1-μ^2)・∂/∂λ (μ=sinφ) 
      ! を作用させてスペクトルデータに変換して返す(多層用).
      !
      real(8), intent(in)  :: xya_data(0:,:,:)
      !(in) 入力格子点データ
      real(8)              :: wa_DivLambda_xya(nm+1,size(xya_data,3))
      !(out) 格子点データを発散型経度微分したスペクトルデータ

      wa_DivLambda_xya = wa_xya(xya_data,ipow=2,iflag=-1)

    end function wa_DivLambda_xya
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001186" class="method-detail">
        <a name="M001186"></a>

        <div class="method-heading">


          <a href="#M001186" class="method-signature">



          <span class="method-name">wa_DivLat_xya</span><span class="method-args">( xya_data ) result(wa_DivLat_xya)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001186">wa_DivLat_xya</a>(nm+1,size(xya_data,3))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型緯度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xya_data(0:,:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型緯度微分 1/cosφ・∂(f cosφ)/∂φ を作用させて
スペクトルデータに変換して返す(多層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001186-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001186-source">
<pre>
    function wa_DivLat_xya(xya_data)
      !
      ! 格子点データに発散型緯度微分 1/cosφ・∂(f cosφ)/∂φ を作用させて
      ! スペクトルデータに変換して返す(多層用).
      !
      real(8), intent(in)  :: xya_data(0:,:,:)
      !(in) 入力格子点データ
      real(8)              :: wa_DivLat_xya(nm+1,size(xya_data,3))
      !(out) 格子点データを発散型緯度微分したスペクトルデータ

      wa_DivLat_xya = wa_xya(xya_data,ipow=1,iflag=1)

    end function wa_DivLat_xya
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001185" class="method-detail">
        <a name="M001185"></a>

        <div class="method-heading">


          <a href="#M001185" class="method-signature">



          <span class="method-name">wa_DivLon_xya</span><span class="method-args">( xya_data ) result(wa_DivLon_xya)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001185">wa_DivLon_xya</a>(nm+1,size(xya_data,3))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型経度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xya_data(0:,:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型経度微分 1/cosφ・∂/∂λ を作用させて
スペクトルデータに変換して返す(多層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001185-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001185-source">
<pre>
    function wa_DivLon_xya(xya_data)
      !
      ! 格子点データに発散型経度微分 1/cosφ・∂/∂λ を作用させて
      ! スペクトルデータに変換して返す(多層用).
      !
      real(8), intent(in)  :: xya_data(0:,:,:)
      !(in) 入力格子点データ
      real(8)              :: wa_DivLon_xya(nm+1,size(xya_data,3))
      !(out) 格子点データを発散型経度微分したスペクトルデータ

      wa_DivLon_xya = wa_xya(xya_data,ipow=1,iflag=-1)

    end function wa_DivLon_xya
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001192" class="method-detail">
        <a name="M001192"></a>

        <div class="method-heading">


          <a href="#M001192" class="method-signature">



          <span class="method-name">wa_DivMu_xya</span><span class="method-args">( xya_data ) result(wa_DivMu_xya)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001192">wa_DivMu_xya</a>(nm+1,size(xya_data,3))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型緯度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xya_data(0:,:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型緯度微分 ∂/∂μ (μ=sinφ)を作用させて
スペクトルデータに変換して返す(多層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001192-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001192-source">
<pre>
    function wa_DivMu_xya(xya_data)
      !
      ! 格子点データに発散型緯度微分 ∂/∂μ (μ=sinφ)を作用させて
      ! スペクトルデータに変換して返す(多層用).
      !
      real(8), intent(in)  :: xya_data(0:,:,:)
      !(in) 入力格子点データ
      real(8)              :: wa_DivMu_xya(nm+1,size(xya_data,3))
      !(out) 格子点データを発散型緯度微分したスペクトルデータ

      wa_DivMu_xya = wa_xya(xya_data,ipow=2,iflag=1)

    end function wa_DivMu_xya
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001187" class="method-detail">
        <a name="M001187"></a>

        <div class="method-heading">


          <a href="#M001187" class="method-signature">



          <span class="method-name">wa_Div_xya_xya</span><span class="method-args">( xya_u, xya_v ) result(wa_Div_xya_xya)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001187">wa_Div_xya_xya</a>(nm+1,size(xya_u,3))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 つの入力格子点データをベクトル成分とする発散のスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xya_u(0:,:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル経度成分の格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xya_v(0:,:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル緯度成分の格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 つの入力格子点データをベクトル成分とする発散を計算し,
スペクトルデータとして返す(多層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001187-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001187-source">
<pre>
    function wa_Div_xya_xya(xya_u,xya_v)
      !
      ! 2 つの入力格子点データをベクトル成分とする発散を計算し, 
      ! スペクトルデータとして返す(多層用).
      !
      real(8), intent(in)  :: xya_u(0:,:,:)
      !(in) ベクトル経度成分の格子点データ
      real(8), intent(in)  :: xya_v(0:,:,:)
      !(in) ベクトル緯度成分の格子点データ
      real(8)              :: wa_Div_xya_xya(nm+1,size(xya_u,3))
      !(out) 2 つの入力格子点データをベクトル成分とする発散のスペクトルデータ

      wa_Div_xya_xya = wa_DivLon_xya(xya_u) + wa_DivLat_xya(xya_v)

    end function wa_Div_xya_xya
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001179" class="method-detail">
        <a name="M001179"></a>

        <div class="method-heading">


          <a href="#M001179" class="method-signature">



          <span class="method-name">wa_Initial</span><span class="method-args">( n_in, i_in, j_in, k_in, [np_in] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>n_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 切断波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>i_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点数(東西)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>j_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点数(南北)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>k_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 最大データ数(層数)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>np_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> OPENMP での最大スレッド数

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル変換の格子点数, 波数, 最大データ数(層数)および OPENMP
使用時の最大スレッド数を設定する.
</p>
<p>
他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで初期設定を
しなければならない.
</p>
<p>
最大データ層数は <a href="wa_module.html">wa_module</a>
との互換性のためにおいている.
実際にはこの設定以上の層数のデータも正しく取り扱える.
</p>
<p>
np_in は <a href="wa_module.html">wa_module</a>
との互換性のためにおいているだけである. OPENMP 計算は実装されていない.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001179-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001179-source">
<pre>
    subroutine wa_Initial(n_in,i_in,j_in,k_in,np_in)
      !
      ! スペクトル変換の格子点数, 波数, 最大データ数(層数)および 
      ! OPENMP 使用時の最大スレッド数を設定する.
      !
      ! 他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで初期設定を
      ! しなければならない. 
      !
      ! 最大データ層数は wa_module との互換性のためにおいている. 
      ! 実際にはこの設定以上の層数のデータも正しく取り扱える. 
      !
      ! np_in は wa_module との互換性のためにおいているだけである. 
      ! OPENMP 計算は実装されていない. 
      !
      integer,intent(in) :: i_in                ! 格子点数(東西)
      integer,intent(in) :: j_in                ! 格子点数(南北)
      integer,intent(in) :: n_in                ! 切断波数
      integer,intent(in) :: k_in                ! 最大データ数(層数)
      integer,intent(in), optional :: np_in     ! OPENMP での最大スレッド数

      call w_Initial(n_in,i_in,j_in)
      call la_Initial(n_in,j_in,l_init=.false.)

      nm = n_in 
       im = i_in 
       jm = j_in 
       km = k_in

      call MessageNotify('M','wa_initial', 'wa_zonal_module (2009/01/08) is initialized')

    end subroutine wa_Initial
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001188" class="method-detail">
        <a name="M001188"></a>

        <div class="method-heading">


          <a href="#M001188" class="method-signature">



          <span class="method-name">wa_Jacobian_wa_wa</span><span class="method-args">( wa_a, wa_b ) result(wa_Jacobian_wa_wa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001188">wa_Jacobian_wa_wa</a>(nm+1,size(wa_a,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 つのスペクトルデータのヤコビアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_a(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1つ目の入力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_b(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2つ目の入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 つのスペクトルデータにヤコビアン
</p>
<pre>
  J(f,g) = ∂f/∂λ・∂g/∂μ - ∂g/∂λ・∂f/∂μ
         = ∂f/∂λ・1/cosφ・∂g/∂φ
            - ∂g/∂λ・1/cosφ・∂f/∂φ
</pre>
<p>
を作用させる(多層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001188-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001188-source">
<pre>
    function wa_Jacobian_wa_wa(wa_a,wa_b)
      ! 2 つのスペクトルデータにヤコビアン
      !
      !   J(f,g) = ∂f/∂λ・∂g/∂μ - ∂g/∂λ・∂f/∂μ
      !          = ∂f/∂λ・1/cosφ・∂g/∂φ
      !             - ∂g/∂λ・1/cosφ・∂f/∂φ
      !
      ! を作用させる(多層用).
      !
      real(8), intent(in) :: wa_a(:,:)
      !(in) 1つ目の入力スペクトルデータ
      real(8), intent(in) :: wa_b(:,:)
      !(in) 2つ目の入力スペクトルデータ
      real(8)             :: wa_Jacobian_wa_wa(nm+1,size(wa_a,2))
      !(out) 2 つのスペクトルデータのヤコビアン
      integer :: k

      do k=1,size(wa_a,2)
         wa_Jacobian_wa_wa(:,k) = w_Jacobian_w_w(wa_a(:,k),wa_b(:,k))
      end do
    end function wa_Jacobian_wa_wa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001238" class="method-detail">
        <a name="M001238"></a>

        <div class="method-heading">




          <span class="method-name">wa_LaplaInv_wa</span><span class="method-args">( la_data ) result(la_LaplaInv_la)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>la_LaplaInv_la(0:nm,size(la_data,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの逆ラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>la_data(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ(0:nm,:)

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに逆ラプラシアン
</p>
<pre>
   ▽^{-2}
     =[1/cosφ・∂/∂φ(cosφ∂/∂φ)]^{-1}
</pre>
<p>
を作用する(多層用).
</p>
<p>
スペクトルデータの逆ラプラシアンとは, 対応する格子点データに
逆ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="la_module.html#M000758">la_module#la_LaplaInv_la</a>
</p>


        </div>
      </div>


      <div id="method-M001237" class="method-detail">
        <a name="M001237"></a>

        <div class="method-heading">




          <span class="method-name">wa_Lapla_wa</span><span class="method-args">( la_data ) result(la_Lapla_la)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>la_Lapla_la(0:nm,size(la_data,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 入力スペクトルデータのラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>la_data(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ(0:nm,:)

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータにラプラシアン
</p>
<pre>
   ▽^2 = 1/cosφ・∂/∂φ(cosφ∂/∂φ)
</pre>
<p>
を作用する(多層用).
</p>
<p>
スペクトルデータのラプラシアンとは, 対応する格子点データに
ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="la_module.html#M000757">la_module#la_Lapla_la</a>
</p>


        </div>
      </div>


      <div id="method-M001178" class="method-detail">
        <a name="M001178"></a>

        <div class="method-heading">




          <span class="method-name">wa_spectrum_VMiss</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001178">wa_spectrum_VMiss</a>  </tt></b>  <tt> = -999.000   </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 欠損値初期値

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001181" class="method-detail">
        <a name="M001181"></a>

        <div class="method-heading">


          <a href="#M001181" class="method-signature">



          <span class="method-name">wa_xya</span><span class="method-args">( xya_data, [ipow], [iflag] ) result(wa_xya)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001181">wa_xya</a>(nm+1,size(xya_data,3))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ(nm+1,:)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xya_data(0:,:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ(0:im-1,1:jm,:)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ipow  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 変換時に同時に作用させる 1/cosφ の次数. 省略時は 0.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>iflag  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> 変換の種類

<pre>
   0 : 通常の正変換
  -1 : 経度微分を作用させた正変換
   1 : 緯度微分を作用させた正変換
   2 : sinφを作用させた正変換
 省略時は 0.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
格子点 -&gt; 球面調和関数スペクトル
</p>
<p>
格子データからスペクトルデータへ(正)変換する(多層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001181-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001181-source">
<pre>
    function wa_xya(xya_data,ipow,iflag) ! 格子点 -&gt; 球面調和関数スペクトル
      !
      ! 格子データからスペクトルデータへ(正)変換する(多層用).
      !
      real(8), intent(in)   :: xya_data(0:,:,:)
      !(in) 格子点データ(0:im-1,1:jm,:)

      real(8)               :: wa_xya(nm+1,size(xya_data,3))
      !(out) スペクトルデータ(nm+1,:)

      integer, intent(in), optional  :: ipow
      !(in) 変換時に同時に作用させる 1/cosφ の次数. 省略時は 0.

      integer, intent(in), optional  :: iflag
      ! 変換の種類
      !    0 : 通常の正変換
      !   -1 : 経度微分を作用させた正変換
      !    1 : 緯度微分を作用させた正変換
      !    2 : sinφを作用させた正変換
      !  省略時は 0.

      integer, parameter  :: ipow_default  = 0    ! スイッチデフォルト値
      integer, parameter  :: iflag_default = 0    ! スイッチデフォルト値

      integer ipval, ifval

      real(8)             :: xya_work(0:im-1,1:jm,size(xya_data,3))
      ! 格子点データ作業配列

      if (present(ipow)) then
         ipval = ipow
      else
         ipval = ipow_default
      endif

      if (present(iflag)) then
         ifval = iflag
      else
         ifval = iflag_default
      endif

      xya_work = xya_data/spread(cos(xy_Lat)**ipval,3,size(xya_data,3))

      if ( ifval == -1 ) then                         ! 経度微分は 0 
         wa_xya = 0.0D0        
      else if ( ifval == 1 ) then                     ! 緯度微分
         xya_work = xya_work * spread(cos(xy_Lat),3,size(xya_data,3))
         wa_xya = wa_DivLat_ya(xya_work(0,:,:))
      else if ( ifval == 2 ) then                     ! sinφ をかけた正変換
         xya_work = xya_work * spread(sin(xy_Lat),3,size(xya_data,3))
         wa_xya = wa_ya(xya_work(0,:,:))
      else
         wa_xya = wa_ya(xya_work(0,:,:))
      endif
      
    end function wa_xya
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001249" class="method-detail">
        <a name="M001249"></a>

        <div class="method-heading">




          <span class="method-name">x_AvrLat_xy</span><span class="method-args">( xy_data ) result(x_AvrLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001249">x_AvrLat_xy</a>(im)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの緯度(Y)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, y_Y_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001891">w_zonal_module#x_AvrLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001243" class="method-detail">
        <a name="M001243"></a>

        <div class="method-heading">




          <span class="method-name">x_IntLat_xy</span><span class="method-args">( xy_data ) result(x_IntLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001243">x_IntLat_xy</a>(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの緯度(Y)方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001887">w_zonal_module#x_IntLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001206" class="method-detail">
        <a name="M001206"></a>

        <div class="method-heading">




          <span class="method-name">x_Lon</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001206">x_Lon</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 経度経度

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001864">w_zonal_module#x_Lon</a>
</p>


        </div>
      </div>


      <div id="method-M001209" class="method-detail">
        <a name="M001209"></a>

        <div class="method-heading">




          <span class="method-name">x_Lon_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001209">x_Lon_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標重み

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001865">w_zonal_module#x_Lon_Weight</a>
</p>


        </div>
      </div>


      <div id="method-M001199" class="method-detail">
        <a name="M001199"></a>

        <div class="method-heading">


          <a href="#M001199" class="method-signature">



          <span class="method-name">xa_AvrLat_xya</span><span class="method-args">( xya_data ) result(xa_AvrLat_xya)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001199">xa_AvrLat_xya</a>(0:im-1,size(xya_data,3))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元経度(X)格子点データの並び(im,*)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xya_data(0:,:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データの並び(0:im-1,1:jm,*)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの緯度(Y)方向平均(多層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, y_Y_Weight
の総和で割ることで平均している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001199-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001199-source">
<pre>
    function xa_AvrLat_xya(xya_data)
      !
      ! 2 次元緯度経度格子点データの緯度(Y)方向平均(多層用).
      !
      ! 実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, 
      ! y_Y_Weight の総和で割ることで平均している. 
      !
      real(8), intent(in) :: xya_data(0:,:,:)
      !(in) 2 次元経度緯度格子点データの並び(0:im-1,1:jm,*)

      real(8)             :: xa_AvrLat_xya(0:im-1,size(xya_data,3))
      !(out) 平均された 1 次元経度(X)格子点データの並び(im,*)

      xa_AvrLat_xya = xa_IntLat_xya(xya_data)/sum(y_Lat_Weight)

    end function xa_AvrLat_xya
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001195" class="method-detail">
        <a name="M001195"></a>

        <div class="method-heading">


          <a href="#M001195" class="method-signature">



          <span class="method-name">xa_IntLat_xya</span><span class="method-args">( xya_data ) result(xa_IntLat_xya)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001195">xa_IntLat_xya</a>(0:im-1,size(xya_data,3))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元経度(X)格子点データの並び

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xya_data(0:,:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データの並び(0:im-1,1:jm,*)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの緯度(Y)方向積分(多層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001195-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001195-source">
<pre>
    function xa_IntLat_xya(xya_data)
      !
      ! 2 次元緯度経度格子点データの緯度(Y)方向積分(多層用).
      !
      ! 実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している. 
      !
      real(8), intent(in) :: xya_data(0:,:,:)
      !(in) 2 次元経度緯度格子点データの並び(0:im-1,1:jm,*)
      real(8)             :: xa_IntLat_xya(0:im-1,size(xya_data,3))
      !(out) 積分された 1 次元経度(X)格子点データの並び
      Integer :: j

      xa_IntLat_xya = 0.0D0
      do j=1,jm
         xa_IntLat_xya = xa_IntLat_xya + xya_data(:,j,:) * y_Lat_Weight(j)
      enddo

    end function xa_IntLat_xya
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001233" class="method-detail">
        <a name="M001233"></a>

        <div class="method-heading">




          <span class="method-name">xy_GradLambda_w</span><span class="method-args">( w_data ) result(xy_GradLambda_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001233">xy_GradLambda_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型経度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 ∂/∂λ を作用する(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001881">w_zonal_module#xy_GradLambda_w</a>
</p>


        </div>
      </div>


      <div id="method-M001228" class="method-detail">
        <a name="M001228"></a>

        <div class="method-heading">




          <span class="method-name">xy_GradLat_w</span><span class="method-args">( w_data ) result(xy_GradLat_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001228">xy_GradLat_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型緯度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型緯度微分 ∂/∂φ を作用させて
格子点データに変換して返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001876">w_zonal_module#xy_GradLat_w</a>
</p>


        </div>
      </div>


      <div id="method-M001227" class="method-detail">
        <a name="M001227"></a>

        <div class="method-heading">




          <span class="method-name">xy_GradLon_w</span><span class="method-args">( w_data ) result(xy_GradLon_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001227">xy_GradLon_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型経度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 1/cosφ・∂/∂λ を
作用させた格子点データを返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001875">w_zonal_module#xy_GradLon_w</a>
</p>


        </div>
      </div>


      <div id="method-M001234" class="method-detail">
        <a name="M001234"></a>

        <div class="method-heading">




          <span class="method-name">xy_GradMu_w</span><span class="method-args">( w_data ) result(xy_GradMu_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001234">xy_GradMu_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型緯度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型緯度微分 (1-μ^2)∂/∂μ (μ=sinφ)
を作用させて格子点データに変換して返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001882">w_zonal_module#xy_GradMu_w</a>
</p>


        </div>
      </div>


      <div id="method-M001213" class="method-detail">
        <a name="M001213"></a>

        <div class="method-heading">




          <span class="method-name">xy_Lat</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001213">xy_Lat</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001867">w_zonal_module#xy_Lat</a>
</p>


        </div>
      </div>


      <div id="method-M001212" class="method-detail">
        <a name="M001212"></a>

        <div class="method-heading">




          <span class="method-name">xy_Lon</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001212">xy_Lon</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001866">w_zonal_module#xy_Lon</a>
</p>


        </div>
      </div>


      <div id="method-M001214" class="method-detail">
        <a name="M001214"></a>

        <div class="method-heading">




          <span class="method-name">xy_w</span><span class="method-args">( w_data, [ipow], [iflag] ) result(xy_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001214">xy_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data(nm+1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ipow  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 作用させる 1/cosφ の次数. 省略時は 0.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>iflag  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 変換の種類

<pre>
   0 : 通常の正変換
   1 : 緯度微分 cosφ・∂/∂φ を作用させた逆変換
  -1 : 経度微分を作用させた逆変換
   2 : sinφを作用させた逆変換(非実装)
   省略時は 0.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子データへ変換する(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001872">w_zonal_module#xy_w</a>
</p>


        </div>
      </div>


      <div id="method-M001189" class="method-detail">
        <a name="M001189"></a>

        <div class="method-heading">


          <a href="#M001189" class="method-signature">



          <span class="method-name">xya_GradLambda_wa</span><span class="method-args">( wa_data ) result(xya_GradLambda_wa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001189">xya_GradLambda_wa</a>(0:im-1,1:jm,size(wa_data,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型経度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_data(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 ∂/∂λ を作用する(多層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001189-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001189-source">
<pre>
    function xya_GradLambda_wa(wa_data)
      !
      ! スペクトルデータに勾配型経度微分 ∂/∂λ を作用する(多層用).
      !
      real(8), intent(in)  :: wa_data(:,:)
      !(in) 入力スペクトルデータ
      real(8)              :: xya_GradLambda_wa(0:im-1,1:jm,size(wa_data,2))
      !(out) スペクトルデータを勾配型経度微分した格子点データ

      xya_GradLambda_wa = xya_wa(wa_data,ipow=0,iflag=-1)

    end function xya_GradLambda_wa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001184" class="method-detail">
        <a name="M001184"></a>

        <div class="method-heading">


          <a href="#M001184" class="method-signature">



          <span class="method-name">xya_GradLat_wa</span><span class="method-args">( wa_data ) result(xya_GradLat_wa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001184">xya_GradLat_wa</a>(0:im-1,1:jm,size(wa_data,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型緯度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_data(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型緯度微分 ∂/∂φ を作用させて
格子点データに変換して返す(多層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001184-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001184-source">
<pre>
    function xya_GradLat_wa(wa_data)
      !
      ! スペクトルデータに勾配型緯度微分 ∂/∂φ を作用させて
      ! 格子点データに変換して返す(多層用).
      !
      real(8), intent(in)  :: wa_data(:,:)
      !(in) 入力スペクトルデータ
      real(8)              :: xya_GradLat_wa(0:im-1,1:jm,size(wa_data,2))
      !(out) スペクトルデータを勾配型緯度微分した格子点データ

      xya_GradLat_wa = xya_wa(wa_data,ipow=1,iflag=1)

    end function xya_GradLat_wa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001183" class="method-detail">
        <a name="M001183"></a>

        <div class="method-heading">


          <a href="#M001183" class="method-signature">



          <span class="method-name">xya_GradLon_wa</span><span class="method-args">( wa_data ) result(xya_GradLon_wa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001183">xya_GradLon_wa</a>(0:im-1,1:jm,size(wa_data,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型経度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_data(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 1/cosφ・∂/∂λ を
作用させた格子点データを返す(多層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001183-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001183-source">
<pre>
    function xya_GradLon_wa(wa_data)
      !
      ! スペクトルデータに勾配型経度微分 1/cosφ・∂/∂λ を
      ! 作用させた格子点データを返す(多層用).
      !
      real(8), intent(in)  :: wa_data(:,:)
      !(in) 入力スペクトルデータ
      real(8)              :: xya_GradLon_wa(0:im-1,1:jm,size(wa_data,2))
      !(out) スペクトルデータを勾配型経度微分した格子点データ

      xya_GradLon_wa = xya_wa(wa_data,ipow=1,iflag=-1)

    end function xya_GradLon_wa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001190" class="method-detail">
        <a name="M001190"></a>

        <div class="method-heading">


          <a href="#M001190" class="method-signature">



          <span class="method-name">xya_GradMu_wa</span><span class="method-args">( wa_data ) result(xya_GradMu_wa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001190">xya_GradMu_wa</a>(0:im-1,1:jm,size(wa_data,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型緯度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_data(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型緯度微分 (1-μ^2)∂/∂μ (μ=sinφ)
を作用させて格子点データに変換して返す(多層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001190-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001190-source">
<pre>
    function xya_GradMu_wa(wa_data)
      !
      ! スペクトルデータに勾配型緯度微分 (1-μ^2)∂/∂μ  (μ=sinφ)
      ! を作用させて格子点データに変換して返す(多層用).
      !
      real(8), intent(in)  :: wa_data(:,:)
      !(in) 入力スペクトルデータ
      real(8)              :: xya_GradMu_wa(0:im-1,1:jm,size(wa_data,2))
      !(out) スペクトルデータを勾配型緯度微分した格子点データ

      xya_GradMu_wa = xya_wa(wa_data,ipow=0,iflag=1)

    end function xya_GradMu_wa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001180" class="method-detail">
        <a name="M001180"></a>

        <div class="method-heading">


          <a href="#M001180" class="method-signature">



          <span class="method-name">xya_wa</span><span class="method-args">( wa_data, [ipow], [iflag] ) result(xya_wa)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001180">xya_wa</a>(0:im-1,1:jm,size(wa_data,2))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ(0:im-1,1:jm,:)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_data(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ(nm+1,:)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ipow  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 作用させる 1/cosφ の次数. 省略時は 0.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>iflag  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 変換の種類

<pre>
   0 : 通常の正変換
   1 : 緯度微分 cosφ・∂/∂φ を作用させた逆変換
  -1 : 経度微分を作用させた逆変換
   2 : sinφを作用させた逆変換(非実装)
   省略時は 0.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子データへ変換する(多層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001180-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001180-source">
<pre>
    function xya_wa(wa_data,ipow,iflag)
      !
      ! スペクトルデータから格子データへ変換する(多層用).
      !
      real(8), intent(in)   :: wa_data(:,:)
      !(in) スペクトルデータ(nm+1,:)
      !
      real(8)               :: xya_wa(0:im-1,1:jm,size(wa_data,2))
      !(out) 格子点データ(0:im-1,1:jm,:)

      integer, intent(in), optional  :: ipow      
      !(in) 作用させる 1/cosφ の次数. 省略時は 0. 

      integer, intent(in), optional  :: iflag
      !(in) 変換の種類
      !    0 : 通常の正変換
      !    1 : 緯度微分 cosφ・∂/∂φ を作用させた逆変換
      !   -1 : 経度微分を作用させた逆変換
      !    2 : sinφを作用させた逆変換(非実装)
      !    省略時は 0.
      !
      integer, parameter  :: ipow_default  = 0
      integer, parameter  :: iflag_default = 0

      integer ipval, ifval, i

      if (present(ipow)) then
         ipval = ipow
      else
         ipval = ipow_default
      endif

      if (present(iflag)) then
         ifval = iflag
      else
         ifval = iflag_default
      endif

      if ( ifval == -1 ) then                        ! 経度微分は 0 
         xya_wa = 0.0D0        
      else if ( ifval == 1 ) then                    ! 緯度微分
         do i=0,im-1
            xya_wa(i,:,:) = ya_GradLat_wa(wa_data) * spread(cos(y_Lat),2,size(wa_data,2))
         enddo
      else if ( ifval == 2 ) then                     ! sinφ をかけた逆変換
         do i=0,im-1
            xya_wa(i,:,:) = ya_wa(wa_data)
         enddo
         xya_wa = xya_wa * spread(sin(xy_Lat),3,size(wa_data,2))
      else
         do i=0,im-1
            xya_wa(i,:,:) = ya_wa(wa_data)
         enddo
      endif

      if ( ipval /= 0 ) then
         xya_wa = xya_wa/spread(cos(xy_Lat)**ipval,3,size(wa_data,2))
      end if

    end function xya_wa
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001247" class="method-detail">
        <a name="M001247"></a>

        <div class="method-heading">




          <span class="method-name">y_AvrLon_xy</span><span class="method-args">( xy_data ) result(y_AvrLon_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001247">y_AvrLon_xy</a>(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元緯度(Y)格子点

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの経度(X)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, x_X_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001892">w_zonal_module#y_AvrLon_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001241" class="method-detail">
        <a name="M001241"></a>

        <div class="method-heading">




          <span class="method-name">y_IntLon_xy</span><span class="method-args">( xy_data ) result(y_IntLon_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001241">y_IntLon_xy</a>(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元緯度(Y)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの経度(X)方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001888">w_zonal_module#y_IntLon_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001208" class="method-detail">
        <a name="M001208"></a>

        <div class="method-heading">




          <span class="method-name">y_Lat</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001207">y_Lat</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 緯度経度

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="la_module.html#M000766">la_module#y_Lat</a>
</p>


        </div>
      </div>


      <div id="method-M001207" class="method-detail">
        <a name="M001207"></a>

        <div class="method-heading">




          <span class="method-name">y_Lat</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001207">y_Lat</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 緯度経度

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001904">w_zonal_module#y_Lat</a>
</p>


        </div>
      </div>


      <div id="method-M001211" class="method-detail">
        <a name="M001211"></a>

        <div class="method-heading">




          <span class="method-name">y_Lat_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001210">y_Lat_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標重み

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="la_module.html#M000767">la_module#y_Lat_Weight</a>
</p>


        </div>
      </div>


      <div id="method-M001210" class="method-detail">
        <a name="M001210"></a>

        <div class="method-heading">




          <span class="method-name">y_Lat_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001210">y_Lat_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標重み

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_zonal_module.html#M001905">w_zonal_module#y_Lat_Weight</a>
</p>


        </div>
      </div>


      <div id="method-M001200" class="method-detail">
        <a name="M001200"></a>

        <div class="method-heading">


          <a href="#M001200" class="method-signature">



          <span class="method-name">ya_AvrLon_xya</span><span class="method-args">( xya_data ) result(ya_AvrLon_xya)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001200">ya_AvrLon_xya</a>(1:jm,size(xya_data,3))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元緯度(Y)格子点の並び(1:jm,*)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xya_data(0:,:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データの並び(0:im-1,1:jm,*)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの経度(X)方向平均(多層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, x_X_Weight
の総和で割ることで平均している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001200-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001200-source">
<pre>
    function ya_AvrLon_xya(xya_data)
      !
      ! 2 次元緯度経度格子点データの経度(X)方向平均(多層用).
      !
      ! 実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, 
      ! x_X_Weight の総和で割ることで平均している. 
      !
      real(8), intent(in) :: xya_data(0:,:,:)
      !(in) 2 次元経度緯度格子点データの並び(0:im-1,1:jm,*)

      real(8)             :: ya_AvrLon_xya(1:jm,size(xya_data,3))
      !(out) 平均された 1 次元緯度(Y)格子点の並び(1:jm,*)

      ya_AvrLon_xya = ya_IntLon_xya(xya_data)/sum(x_Lon_Weight)

    end function ya_AvrLon_xya
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001196" class="method-detail">
        <a name="M001196"></a>

        <div class="method-heading">


          <a href="#M001196" class="method-signature">



          <span class="method-name">ya_IntLon_xya</span><span class="method-args">( xya_data ) result(ya_IntLon_xya)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wa_zonal_module.html#M001196">ya_IntLon_xya</a>(1:jm,size(xya_data,3))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元緯度(Y)格子点データの並び

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xya_data(0:,:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データの並び(0:im-1,1:jm,*)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの経度(X)方向積分(多層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001196-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001196-source">
<pre>
    function ya_IntLon_xya(xya_data)
      !
      ! 2 次元緯度経度格子点データの経度(X)方向積分(多層用).
      !
      ! 実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している. 
      !
      real(8), intent(in) :: xya_data(0:,:,:)
      !(in) 2 次元経度緯度格子点データの並び(0:im-1,1:jm,*)

      real(8)             :: ya_IntLon_xya(1:jm,size(xya_data,3))
      !(out) 積分された 1 次元緯度(Y)格子点データの並び

      integer :: i

      ya_IntLon_xya = 0.0D0
      do i=0,im-1
         ya_IntLon_xya = ya_IntLon_xya + xya_data(i,:,:) * x_Lon_Weight(i)
      enddo

    end function ya_IntLon_xya
</pre>
          </div>

        </div>
      </div>



    </div>



  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
