<?xml version="1.0" encoding="euc-jp"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: w_deriv_module</title>
  <meta http-equiv="Content-Type" content="text/html; charset=euc-jp" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">w_deriv_module</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../files/src/w_deriv_module_f90.html">

                src/w_deriv_module.f90

                </a>


        <br />
            </td>
        </tr>


        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">


  <div id="contextContent">



    <div id="description">
      <h1><a href="w_deriv_module.html">w_deriv_module</a></h1>
<table>
<tr><td valign="top">Authors:</td><td>Shin-ichi Takehiro, Youhei SASAKI

</td></tr>
<tr><td valign="top">Version:</td><td>$Id: <a
href="../files/src/w_deriv_module_f90.html">w_deriv_module.f90</a>,v 1.16
2009-02-28 21:33:47 uwabami Exp $

</td></tr>
<tr><td valign="top">Copyright&amp;License:</td><td>See <a href="../../COPYRIGHT">COPYRIGHT</a>

</td></tr>
</table>
<h2>概要</h2>
<p>
spml/w_deriv_module モジュールは球面上での 2 次元流体運動を
球面調和函数を用いたスペクトル法によって数値計算するための モジュール <a
href="w_module.html">w_module</a> の下部モジュールであり, スペクトル法の
微分計算のための Fortran90 関数を提供する.
</p>
<p>
内部で ISPACK の SPPACK と SNPACK の Fortran77 サブルーチンを呼んでいる.
スペクトルデータおよび格子点データの格納方法や変換の詳しい計算法に ついては
ISPACK/SNPACK,SPPACK のマニュアルを参照されたい.
</p>
<p>
このモジュールを使うためには前もって w_base_initial を呼んで 切断波数,
格子点数の設定をしておく必要がある.
</p>

    </div>





   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M002135">irm</a>&nbsp;&nbsp;

        <a href="#M002134">rn</a>&nbsp;&nbsp;

        <a href="#M002139">w_DLon_w</a>&nbsp;&nbsp;

        <a href="#M002148">w_DivLambda_xy</a>&nbsp;&nbsp;

        <a href="#M002143">w_DivLat_xy</a>&nbsp;&nbsp;

        <a href="#M002142">w_DivLon_xy</a>&nbsp;&nbsp;

        <a href="#M002149">w_DivMu_xy</a>&nbsp;&nbsp;

        <a href="#M002144">w_Div_xy_xy</a>&nbsp;&nbsp;

        <a href="#M002145">w_Jacobian_w_w</a>&nbsp;&nbsp;

        <a href="#M002138">w_LaplaInv_w</a>&nbsp;&nbsp;

        <a href="#M002137">w_Lapla_w</a>&nbsp;&nbsp;

        <a href="#M002136">w_deriv_initial</a>&nbsp;&nbsp;

        <a href="#M002146">xy_GradLambda_w</a>&nbsp;&nbsp;

        <a href="#M002141">xy_GradLat_w</a>&nbsp;&nbsp;

        <a href="#M002140">xy_GradLon_w</a>&nbsp;&nbsp;

        <a href="#M002147">xy_GradMu_w</a>&nbsp;&nbsp;
      </div>
    </div>


  </div>


    <!-- if includes -->

    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">

        <span class="include-name">dc_message</span>

        <span class="include-name"><a href="w_base_module.html">w_base_module</a></span>
      </div>
    </div>



    <div id="section">










      


    <!-- if method_list -->

    <div id="methods">


      <h3 class="section-bar">Public Instance methods</h3>


      <div id="method-M002135" class="method-detail">
        <a name="M002135"></a>

        <div class="method-heading">




          <span class="method-name">irm</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002135">irm</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 経度微分演算用配列

<p>
スペクトルデータの経度微分を計算するための係数. 配列サイズは (
(nm+1)*(nm+1),2 ) である.
</p>
<p>
L番目の格納位置のスペクトルが実部なら, <a
href="w_deriv_module.html#M002135">irm</a>(L,1)には対応する虚部の格納位置が,
<a href="w_deriv_module.html#M002135">irm</a>(L,2) には東西波数 m
が格納されている. また, L番目の格納位置のスペクトル が虚部なら, <a
href="w_deriv_module.html#M002135">irm</a>(L,1)には対応する実部の格納位置が,
<a href="w_deriv_module.html#M002135">irm</a>(L,2)には -m が格納され
ている.
</p>
</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M002134" class="method-detail">
        <a name="M002134"></a>

        <div class="method-heading">




          <span class="method-name">rn</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002134">rn</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> ラプラシアン演算用配列

<p>
スペクトルデータのラプラシアンを計算するための係数
配列のサイズは((nm+1)*(nm+1), 2)
</p>
<p>
r(L,1) には L 番目の格納位置のスペクトルに対するラプラシアン計算の 係数
-n(n+1) の値が格納されている.
</p>
</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M002139" class="method-detail">
        <a name="M002139"></a>

        <div class="method-heading">


          <a href="#M002139" class="method-signature">



          <span class="method-name">w_DLon_w</span><span class="method-args">( w_data ) result(w_DLon_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002139">w_DLon_w</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの経度微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに経度微分 ∂/∂λ を作用させる(1 層用).
</p>
<p>
スペクトルデータの経度微分とは, 対応する格子点データに
経度微分∂/∂λを作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002139-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002139-source">
<pre>
    function w_DLon_w(w_data)
      !
      ! スペクトルデータに経度微分 ∂/∂λ を作用させる(1 層用).
      !
      ! スペクトルデータの経度微分とは, 対応する格子点データに
      ! 経度微分∂/∂λを作用させたデータのスペクトル変換のことである.
      ! 
      real(8)              :: w_DLon_w((nm+1)*(nm+1))
      !(out) スペクトルデータの経度微分

      real(8), intent(in)  :: w_data((nm+1)*(nm+1))
      !(in) 入力スペクトルデータ

      call spclam(nm,w_data,w_DLon_w,irm)

    end function w_DLon_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002148" class="method-detail">
        <a name="M002148"></a>

        <div class="method-heading">


          <a href="#M002148" class="method-signature">



          <span class="method-name">w_DivLambda_xy</span><span class="method-args">( xy_data ) result(w_DivLambda_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002148">w_DivLambda_xy</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型経度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型経度微分 1/(1-μ^2)・∂/∂λ (μ=sinφ)
を作用させてスペクトルデータに変換して返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002148-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002148-source">
<pre>
    function w_DivLambda_xy(xy_data)
      !
      ! 格子点データに発散型経度微分 1/(1-μ^2)・∂/∂λ (μ=sinφ) 
      ! を作用させてスペクトルデータに変換して返す(1 層用).
      !
      real(8)              :: w_DivLambda_xy((nm+1)*(nm+1))
      !(out) 格子点データを発散型経度微分したスペクトルデータ

      real(8), intent(in)  :: xy_data(0:im-1,1:jm)
      !(in) 入力格子点データ

      w_DivLambda_xy = w_xy(xy_data,ipow=2,iflag=-1)

    end function w_DivLambda_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002143" class="method-detail">
        <a name="M002143"></a>

        <div class="method-heading">


          <a href="#M002143" class="method-signature">



          <span class="method-name">w_DivLat_xy</span><span class="method-args">( xy_data ) result(w_DivLat_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002143">w_DivLat_xy</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型緯度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型緯度微分 1/cosφ・∂(f cosφ)/∂φ を作用させて
スペクトルデータに変換して返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002143-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002143-source">
<pre>
    function w_DivLat_xy(xy_data)
      !
      ! 格子点データに発散型緯度微分 1/cosφ・∂(f cosφ)/∂φ を作用させて
      ! スペクトルデータに変換して返す(1 層用).
      !
      real(8)              :: w_DivLat_xy((nm+1)*(nm+1))
      !(out) 格子点データを発散型緯度微分したスペクトルデータ

      real(8), intent(in)  :: xy_data(0:im-1,1:jm)
      !(in) 入力格子点データ

      w_DivLat_xy = w_xy(xy_data,ipow=1,iflag=1)

    end function w_DivLat_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002142" class="method-detail">
        <a name="M002142"></a>

        <div class="method-heading">


          <a href="#M002142" class="method-signature">



          <span class="method-name">w_DivLon_xy</span><span class="method-args">( xy_data ) result(w_DivLon_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002142">w_DivLon_xy</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型経度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型経度微分 1/cosφ・∂/∂λ を作用させて
スペクトルデータに変換して返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002142-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002142-source">
<pre>
    function w_DivLon_xy(xy_data)
      !
      ! 格子点データに発散型経度微分 1/cosφ・∂/∂λ を作用させて
      ! スペクトルデータに変換して返す(1 層用).
      !
      real(8)              :: w_DivLon_xy((nm+1)*(nm+1))
      !(out) 格子点データを発散型経度微分したスペクトルデータ
      real(8), intent(in)  :: xy_data(0:im-1,1:jm)
      !(in) 入力格子点データ

      w_DivLon_xy = w_xy(xy_data,ipow=1,iflag=-1)

    end function w_DivLon_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002149" class="method-detail">
        <a name="M002149"></a>

        <div class="method-heading">


          <a href="#M002149" class="method-signature">



          <span class="method-name">w_DivMu_xy</span><span class="method-args">( xy_data ) result(w_DivMu_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002149">w_DivMu_xy</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型緯度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型緯度微分 ∂/∂μ (μ=sinφ)を作用させて
スペクトルデータに変換して返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002149-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002149-source">
<pre>
    function w_DivMu_xy(xy_data)
      !
      ! 格子点データに発散型緯度微分 ∂/∂μ (μ=sinφ)を作用させて
      ! スペクトルデータに変換して返す(1 層用).
      !
      real(8)              :: w_DivMu_xy((nm+1)*(nm+1))
      !(out) 格子点データを発散型緯度微分したスペクトルデータ

      real(8), intent(in)  :: xy_data(0:im-1,1:jm)
      !(in) 入力格子点データ

      w_DivMu_xy = w_xy(xy_data,ipow=2,iflag=1)

    end function w_DivMu_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002144" class="method-detail">
        <a name="M002144"></a>

        <div class="method-heading">


          <a href="#M002144" class="method-signature">



          <span class="method-name">w_Div_xy_xy</span><span class="method-args">( xy_u, xy_v ) result(w_Div_xy_xy)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002144">w_Div_xy_xy</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 つの入力格子点データをベクトル成分とする発散のスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_u(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル経度成分の格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_v(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル緯度成分の格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 つの入力格子点データをベクトル成分とする発散を計算し,
スペクトルデータとして返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002144-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002144-source">
<pre>
    function w_Div_xy_xy(xy_u,xy_v)
      !
      ! 2 つの入力格子点データをベクトル成分とする発散を計算し, 
      ! スペクトルデータとして返す(1 層用).
      !
      real(8)              :: w_Div_xy_xy((nm+1)*(nm+1))
      !(out) 2 つの入力格子点データをベクトル成分とする発散のスペクトルデータ

      real(8), intent(in)  :: xy_u(0:im-1,1:jm)
      !(in) ベクトル経度成分の格子点データ

      real(8), intent(in)  :: xy_v(0:im-1,1:jm)
      !(in) ベクトル緯度成分の格子点データ

      w_Div_xy_xy = w_Divlon_xy(xy_u) + w_Divlat_xy(xy_v)

    end function w_Div_xy_xy
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002145" class="method-detail">
        <a name="M002145"></a>

        <div class="method-heading">


          <a href="#M002145" class="method-signature">



          <span class="method-name">w_Jacobian_w_w</span><span class="method-args">( w_a, w_b ) result(w_Jacobian_w_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002145">w_Jacobian_w_w</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 つのスペクトルデータのヤコビアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_a((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1つ目の入力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_b((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2つ目の入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 つのスペクトルデータにヤコビアン
</p>
<pre>
  J(f,g) = ∂f/∂λ・∂g/∂μ - ∂g/∂λ・∂f/∂μ
         = ∂f/∂λ・1/cosφ・∂g/∂φ
            - ∂g/∂λ・1/cosφ・∂f/∂φ
</pre>
<p>
を作用させる(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002145-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002145-source">
<pre>
    function w_Jacobian_w_w(w_a,w_b)
      ! 2 つのスペクトルデータにヤコビアン
      !
      !   J(f,g) = ∂f/∂λ・∂g/∂μ - ∂g/∂λ・∂f/∂μ
      !          = ∂f/∂λ・1/cosφ・∂g/∂φ
      !             - ∂g/∂λ・1/cosφ・∂f/∂φ
      !
      ! を作用させる(1 層用).

      real(8)             :: w_Jacobian_w_w((nm+1)*(nm+1))
      !(out) 2 つのスペクトルデータのヤコビアン

      real(8), intent(in) :: w_a((nm+1)*(nm+1))
      !(in) 1つ目の入力スペクトルデータ
      
      real(8), intent(in) :: w_b((nm+1)*(nm+1))
      !(in) 2つ目の入力スペクトルデータ

      call spnjcb(nm,im,im,jm,jm,w_a,w_b,w_Jacobian_w_w, it,t,y,ip2,p2,r2,ip3,p3,r3,ia,a,q,ws,ww)

    end function w_Jacobian_w_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002138" class="method-detail">
        <a name="M002138"></a>

        <div class="method-heading">


          <a href="#M002138" class="method-signature">



          <span class="method-name">w_LaplaInv_w</span><span class="method-args">( w_data ) result(w_LaplaInv_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002138">w_LaplaInv_w</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの逆ラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに逆ラプラシアン
</p>
<pre>
   ▽^{-2}
     =[1/cos^2φ・∂^2/∂λ^2 + 1/cosφ・∂/∂φ(cosφ∂/∂φ)]^{-1}
</pre>
<p>
を作用する(1 層用).
</p>
<p>
スペクトルデータの逆ラプラシアンとは, 対応する格子点データに
逆ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002138-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002138-source">
<pre>
    function w_LaplaInv_w(w_data)
      !
      ! 入力スペクトルデータに逆ラプラシアン
      !
      !    ▽^{-2}
      !      =[1/cos^2φ・∂^2/∂λ^2 + 1/cosφ・∂/∂φ(cosφ∂/∂φ)]^{-1}
      !
      ! を作用する(1 層用).
      !
      ! スペクトルデータの逆ラプラシアンとは, 対応する格子点データに
      ! 逆ラプラシアンを作用させたデータのスペクトル変換のことである. 
      !
      real(8)              :: w_LaplaInv_w((nm+1)*(nm+1))
      !(out) スペクトルデータの逆ラプラシアン

      real(8), intent(in)  :: w_data((nm+1)*(nm+1))
      !(in) 入力スペクトルデータ

      call spclap(nm,w_data,w_LaplaInv_w,rn(1,2))
    end function w_LaplaInv_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002137" class="method-detail">
        <a name="M002137"></a>

        <div class="method-heading">


          <a href="#M002137" class="method-signature">



          <span class="method-name">w_Lapla_w</span><span class="method-args">( w_data ) result(w_Lapla_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002137">w_Lapla_w</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 入力スペクトルデータのラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータにラプラシアン
</p>
<pre>
   ▽^2 = 1/cos^2φ・∂^2/∂λ^2 + 1/cosφ・∂/∂φ(cosφ∂/∂φ)
</pre>
<p>
を作用する(1 層用).
</p>
<p>
スペクトルデータのラプラシアンとは, 対応する格子点データに
ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002137-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002137-source">
<pre>
    function w_Lapla_w(w_data)
      !
      ! 入力スペクトルデータにラプラシアン
      !
      !    ▽^2 = 1/cos^2φ・∂^2/∂λ^2 + 1/cosφ・∂/∂φ(cosφ∂/∂φ)
      !
      ! を作用する(1 層用).
      !
      ! スペクトルデータのラプラシアンとは, 対応する格子点データに
      ! ラプラシアンを作用させたデータのスペクトル変換のことである. 
      !
      real(8)              :: w_Lapla_w((nm+1)*(nm+1))
      !(out) 入力スペクトルデータのラプラシアン

      real(8), intent(in)  :: w_data((nm+1)*(nm+1))
      !(in) 入力スペクトルデータ

      call spclap(nm,w_data,w_Lapla_w,rn(1,1))
    end function w_Lapla_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002136" class="method-detail">
        <a name="M002136"></a>

        <div class="method-heading">


          <a href="#M002136" class="method-signature">



          <span class="method-name">w_deriv_initial</span><span class="method-args">( ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
</table>
<p>
スペクトル微分計算に必要となる作業領域を設定する.
</p>
<p>
他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで
初期設定をしなければならない.
</p>
<p>
このサブルーチンを単独で用いるのでなく, 上位サブルーチン w_Initial
を使用すること.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002136-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002136-source">
<pre>
    subroutine w_deriv_initial
      !
      ! スペクトル微分計算に必要となる作業領域を設定する. 
      !
      ! 他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで
      ! 初期設定をしなければならない. 
      !
      ! このサブルーチンを単独で用いるのでなく, 
      ! 上位サブルーチン w_Initial を使用すること.
      !
      integer iw

      allocate(rn((nm+1)*(nm+1),2))           ! ラプラシアン演算用配列
      allocate(irm((nm+1)*(nm+1),2))          ! 経度微分演算用配列
      call spnini(nm,rn)
      call spmini(nm,irm)

      allocate(ip2(2*((nm+1)/2+nm+1)*2))      ! ヤコビアン計算用配列
      allocate(p2(2*((nm+1)/2+nm+1)*jm))      ! ヤコビアン計算用配列
      allocate(r2(2*((nm+1)/2*2+3)*(nm/2+1))) ! ヤコビアン計算用配列
      allocate(ip3(3*((nm+1)/2+nm+1)*2))      ! ヤコビアン計算用配列
      allocate(p3(3*((nm+1)/2+nm+1)*jm))      ! ヤコビアン計算用配列
      allocate(r3(3*((nm+1)/2*2+3)*(nm/2+1))) ! ヤコビアン計算用配列
      call snkini(nm,jm,2,ip,p,r,ip2,p2,r2)
      call snkini(nm,jm,3,ip,p,r,ip3,p3,r3)

      allocate(q(3*((nm+1)/2+nm+1)*jm))       ! 作業用配列
      iw=3*max( ((nm+1)/2*2+3)*(nm/2+2)*2, jm*((nm+1)/2+nm+1)*2, jm*jm )
      allocate(ws(iw),ww(iw))                 ! 作業用配列

      call MessageNotify('M','w_deriv_initial', 'w_deriv_module (2009/01/09) is initialized')

    end subroutine w_deriv_initial
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002146" class="method-detail">
        <a name="M002146"></a>

        <div class="method-heading">


          <a href="#M002146" class="method-signature">



          <span class="method-name">xy_GradLambda_w</span><span class="method-args">( w_data ) result(xy_GradLambda_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002146">xy_GradLambda_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型経度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 ∂/∂λ を作用する(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002146-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002146-source">
<pre>
    function xy_GradLambda_w(w_data)
      !
      ! スペクトルデータに勾配型経度微分 ∂/∂λ を作用する(1 層用).
      !
      real(8)              :: xy_GradLambda_w(0:im-1,1:jm)
      !(out) スペクトルデータを勾配型経度微分した格子点データ

      real(8), intent(in)  :: w_data((nm+1)*(nm+1))
      !(in) 入力スペクトルデータ
      
      xy_GradLambda_w = xy_w(w_data,ipow=0,iflag=-1)

    end function xy_GradLambda_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002141" class="method-detail">
        <a name="M002141"></a>

        <div class="method-heading">


          <a href="#M002141" class="method-signature">



          <span class="method-name">xy_GradLat_w</span><span class="method-args">( w_data ) result(xy_GradLat_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002141">xy_GradLat_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型緯度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型緯度微分 ∂/∂φ を作用させて
格子点データに変換して返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002141-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002141-source">
<pre>
    function xy_GradLat_w(w_data)
      !
      ! スペクトルデータに勾配型緯度微分 ∂/∂φ を作用させて
      ! 格子点データに変換して返す(1 層用).
      !
      real(8)              :: xy_GradLat_w(0:im-1,1:jm)
      !(out) スペクトルデータを勾配型緯度微分した格子点データ

      real(8), intent(in)  :: w_data((nm+1)*(nm+1))
      !(in) 入力スペクトルデータ

      xy_GradLat_w = xy_w(w_data,ipow=1,iflag=1)

    end function xy_GradLat_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002140" class="method-detail">
        <a name="M002140"></a>

        <div class="method-heading">


          <a href="#M002140" class="method-signature">



          <span class="method-name">xy_GradLon_w</span><span class="method-args">( w_data ) result(xy_GradLon_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002140">xy_GradLon_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型経度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 1/cosφ・∂/∂λ を
作用させた格子点データを返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002140-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002140-source">
<pre>
    function xy_GradLon_w(w_data)
      !
      ! スペクトルデータに勾配型経度微分 1/cosφ・∂/∂λ を
      ! 作用させた格子点データを返す(1 層用).
      !
      real(8)              :: xy_GradLon_w(0:im-1,1:jm)
      !(out) スペクトルデータを勾配型経度微分した格子点データ

      real(8), intent(in)  :: w_data((nm+1)*(nm+1))
      !(in) 入力スペクトルデータ

      xy_GradLon_w = xy_w(w_data,ipow=1,iflag=-1)

    end function xy_GradLon_w
</pre>
          </div>

        </div>
      </div>


      <div id="method-M002147" class="method-detail">
        <a name="M002147"></a>

        <div class="method-heading">


          <a href="#M002147" class="method-signature">



          <span class="method-name">xy_GradMu_w</span><span class="method-args">( w_data ) result(xy_GradMu_w)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_deriv_module.html#M002147">xy_GradMu_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型緯度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型緯度微分 (1-μ^2)∂/∂μ (μ=sinφ)
を作用させて格子点データに変換して返す(1 層用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M002147-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M002147-source">
<pre>
    function xy_GradMu_w(w_data)
      !
      ! スペクトルデータに勾配型緯度微分 (1-μ^2)∂/∂μ  (μ=sinφ)
      ! を作用させて格子点データに変換して返す(1 層用).
      !
      real(8)              :: xy_GradMu_w(0:im-1,1:jm)
      !(out) スペクトルデータを勾配型緯度微分した格子点データ

      real(8), intent(in)  :: w_data((nm+1)*(nm+1))
      !(in) 入力スペクトルデータ

      xy_GradMu_w = xy_w(w_data,ipow=0,iflag=1)

    end function xy_GradMu_w
</pre>
          </div>

        </div>
      </div>



    </div>



  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
