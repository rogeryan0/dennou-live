<?xml version="1.0" encoding="euc-jp"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: au_module</title>
  <meta http-equiv="Content-Type" content="text/html; charset=euc-jp" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">au_module</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../files/src/au_module_f90.html">

                src/au_module.f90

                </a>


        <br />
            </td>
        </tr>


        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">


  <div id="contextContent">



    <div id="description">
      <h1><a href="au_module.html">au_module</a></h1>
<table>
<tr><td valign="top">Authors:</td><td>Shin-ichi Takehiro, Youhei SASAKI

</td></tr>
<tr><td valign="top">Version:</td><td>$Id: <a href="../files/src/au_module_f90.html">au_module.f90</a>,v 1.4
2009-02-28 21:33:46 uwabami Exp $

</td></tr>
<tr><td valign="top">Copyright&amp;License:</td><td>See <a href="../../COPYRIGHT">COPYRIGHT</a>

</td></tr>
</table>
<h2>概要</h2>
<p>
spml/au_module モジュールは 1 次元有限領域の下での流体運動を 2
次の引数のシフトされたチェビシェフ関数 T_k(2r^2/a^2-1)で
展開するスペクトル数値計算ための Fortran90 関数を提供する.
このルーチンは離散化にチェビシェフ&#8212;ガウス&#8212;ラダウ格子点を適用
しており, 主に 2 次元極座標, 円筒座標, 球座標の原点の
特異性を回避しながらスペクトル計算を行うために用いることを
念頭においている.
</p>
<p>
2 次元データの 1 次元に関して同時にスペクトル計算を実行するための
関数も提供しており, 2, 3 次元領域での計算のベースも提供する.
</p>
<p>
具体的な展開の仕方は
</p>
<pre>
        f(r)=Σf_k r^n T_k(2r^2/a^2-1)
</pre>
<p>
である. 1 次元チェビシェフデータが複数並んだ 2 次元データを
扱う際には重みの指数 n を各データ毎に設定できる.
</p>
<h2>関数・変数の名前と型について</h2>
<h3>命名法</h3>
<ul>
<li>関数名の先頭 (u_, g_, au_, ag_) は, 返す値の形を示している.

<table>
<tr><td valign="top">u_  :</td><td>チェビシェフデータ

</td></tr>
<tr><td valign="top">g_  :</td><td>1 次元格子点データ

</td></tr>
<tr><td valign="top">au_ :</td><td>1 次元チェビシェフデータが複数並んだ 2 次元データ

</td></tr>
<tr><td valign="top">ag_ :</td><td>1 次元格子点データが複数並んだ 2 次元データ.

</td></tr>
</table>
<p>
複数並んだ 2 次元データの第 1 次元の大きさは <a
href="au_module.html#M000261">au_Initial</a> で 設定する重みの指数の配列 nd
の大きさと同じでなければならない.
</p>
</li>
<li>関数名の間の文字列(Dr)は, その関数の作用を表している.

</li>
<li>関数名の最後 (_e,_au,_g, _ag) は, 入力変数の形がチェビシェフデータ
および格子点データであることを示している.

<pre>
 _u  :: チェビシェフデータ
 _g  :: 1 次元格子点データ
 _au :: 1 次元チェビシェフデータが複数並んだ 2 次元データ
 _ag :: 1 次元格子点データが複数並んだ 2 次元データ
</pre>
</li>
</ul>
<h3>各データの種類の説明</h3>
<ul>
<li>g : 1 次元格子点データ.

<ul>
<li>変数の種類と次元は real(8), dimension(0:im).

</li>
<li>im は R 座標の格子点数であり, サブルーチン <a
href="au_module.html#M000261">au_Initial</a> にて あらかじめ設定しておく.

</li>
</ul>
</li>
<li>u : チェビシェフデータ.

<ul>
<li>変数の種類と次元は real(8), dimension(0:km). km は R 方向の最大波数であり,
サブルーチン <a href="au_module.html#M000261">au_Initial</a> にて
あらかじめ設定しておく. スペクトルデータの格納のされ方については&#8230;

</li>
</ul>
</li>
<li>ag : 1 次元(R)格子点データの並んだ 2 次元データ.

<ul>
<li>変数の種類と次元は real(8), dimension(size(nd),0:im). 第 2 次元が R
方向を表す.

</li>
</ul>
</li>
<li>au : 1 次元チェビシェフデータの並んだ 2 次元データ.

<ul>
<li>変数の種類と次元は real(8), dimension(size(nd),0:km). 第 2
次元がスペクトルを表す.

</li>
</ul>
</li>
<li>g_ で始まる関数が返す値は 1 次元格子点データに同じ.

</li>
<li>u_ で始まる関数が返す値はチェビシェフデータに同じ.

</li>
<li>ag_ で始まる関数が返す値は 1 次元格子点データの並んだ 2 次元データに同じ.

</li>
<li>au_ で始まる関数が返す値は 1 次元チェビシェフデータの並んだ 2
次元データに同じ.

</li>
<li>チェビシェフデータに対する微分等の作用とは, 対応する格子点データに
微分などを作用させたデータをチェビシェフ変換したもののことである.

</li>
</ul>
<h2>変数・手続き群の要約</h2>
<h4>初期化</h4>
<table>
<tr><td valign="top"><a href="au_module.html#M000261">au_Initial</a>  :</td><td>チェビシェフ変換の格子点数, 波数, 領域の大きさの設定

</td></tr>
</table>
<h4>座標変数</h4>
<table>
<tr><td valign="top"><a href="au_module.html#M000259">g_R</a>        :</td><td>格子点座標(R)を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="au_module.html#M000260">g_R_Weight</a> :</td><td>重み座標を格納した 1 次元配列

</td></tr>
</table>
<h4>基本変換</h4>
<table>
<tr><td valign="top"><a href="au_module.html#M000263">g_u</a>, <a href="au_module.html#M000262">ag_au</a> :</td><td>チェビシェフデータから格子データへの変換

</td></tr>
<tr><td valign="top"><a href="au_module.html#M000265">u_g</a>, <a href="au_module.html#M000264">au_ag</a> :</td><td>格子データからチェビシェフデータへの変換

</td></tr>
</table>
<h4>微分</h4>
<table>
<tr><td valign="top"><a href="au_module.html#M000267">g_Dr_u</a>, <a href="au_module.html#M000266">ag_Dr_au</a>   :</td><td>チェビシェフデータに R 微分を作用させる

</td></tr>
<tr><td valign="top"><a href="au_module.html#M000269">g_Dr2_u</a>, <a href="au_module.html#M000268">ag_Dr2_au</a> :</td><td>チェビシェフデータに 2 階 R 微分を作用させる

</td></tr>
</table>
<h4>積分・平均</h4>
<table>
<tr><td valign="top"><a href="au_module.html#M000270">a_Int_ag</a>, <a href="au_module.html#M000272">a_Avr_ag</a> :</td><td>1 次元格子点データの並んだ 2 次元配列の積分および平均

</td></tr>
<tr><td valign="top"><a href="au_module.html#M000271">Int_g</a>, <a href="au_module.html#M000273">Avr_g</a>       :</td><td>1 次元格子点データの積分および平均

</td></tr>
</table>
<h4>境界値問題</h4>
<table>
<tr><td valign="top"><a href="au_module.html#M000274">au_Boundary_D</a>, <a href="au_module.html#M000276">au_Boundary_N</a>         :</td><td>ディリクレ,ノイマン外側境界条件

</td></tr>
<tr><td valign="top"><a href="au_module.html#M000278">au_BoundaryTau_D</a>, <a href="au_module.html#M000280">au_BoundaryTau_N</a>   :</td><td>ディリクレ,ノイマン外側境界条件

</td></tr>
<tr><td valign="top"><a href="au_module.html#M000282">au_BoundaryGrid_D</a>, <a href="au_module.html#M000284">au_BoundaryGrid_N</a> :</td><td>ディリクレ,ノイマン外側境界条件

</td></tr>
</table>

    </div>





   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M000273">Avr_g</a>&nbsp;&nbsp;

        <a href="#M000271">Int_g</a>&nbsp;&nbsp;

        <a href="#M000272">a_Avr_ag</a>&nbsp;&nbsp;

        <a href="#M000270">a_Int_ag</a>&nbsp;&nbsp;

        <a href="#M000268">ag_Dr2_au</a>&nbsp;&nbsp;

        <a href="#M000266">ag_Dr_au</a>&nbsp;&nbsp;

        <a href="#M000262">ag_au</a>&nbsp;&nbsp;

        <a href="#M000283">au_BoundaryGrid_D</a>&nbsp;&nbsp;

        <a href="#M000282">au_BoundaryGrid_D</a>&nbsp;&nbsp;

        <a href="#M000285">au_BoundaryGrid_N</a>&nbsp;&nbsp;

        <a href="#M000284">au_BoundaryGrid_N</a>&nbsp;&nbsp;

        <a href="#M000279">au_BoundaryTau_D</a>&nbsp;&nbsp;

        <a href="#M000278">au_BoundaryTau_D</a>&nbsp;&nbsp;

        <a href="#M000281">au_BoundaryTau_N</a>&nbsp;&nbsp;

        <a href="#M000280">au_BoundaryTau_N</a>&nbsp;&nbsp;

        <a href="#M000275">au_Boundary_D</a>&nbsp;&nbsp;

        <a href="#M000274">au_Boundary_D</a>&nbsp;&nbsp;

        <a href="#M000277">au_Boundary_N</a>&nbsp;&nbsp;

        <a href="#M000276">au_Boundary_N</a>&nbsp;&nbsp;

        <a href="#M000261">au_Initial</a>&nbsp;&nbsp;

        <a href="#M000264">au_ag</a>&nbsp;&nbsp;

        <a href="#M000269">g_Dr2_u</a>&nbsp;&nbsp;

        <a href="#M000267">g_Dr_u</a>&nbsp;&nbsp;

        <a href="#M000259">g_R</a>&nbsp;&nbsp;

        <a href="#M000260">g_R_Weight</a>&nbsp;&nbsp;

        <a href="#M000263">g_u</a>&nbsp;&nbsp;

        <a href="#M000265">u_g</a>&nbsp;&nbsp;
      </div>
    </div>


  </div>


    <!-- if includes -->

    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">

        <span class="include-name">dc_message</span>

        <span class="include-name"><a href="lumatrix.html">lumatrix</a></span>
      </div>
    </div>



    <div id="section">










      


    <!-- if method_list -->

    <div id="methods">


      <h3 class="section-bar">Public Instance methods</h3>


      <div id="method-M000273" class="method-detail">
        <a name="M000273"></a>

        <div class="method-heading">


          <a href="#M000273" class="method-signature">



          <span class="method-name">Avr_g</span><span class="method-args">( g ) result(Avr_g)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000273">Avr_g</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>g  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元格子点データの平均
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000273-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000273-source">
<pre>
    function Avr_g(g)
      !
      ! 1 次元格子点データの平均
      !
      real(8), dimension(0:im), intent(in)   :: g
      !(in) 格子点データ

      real(8)                                :: Avr_g
      !(out) 積分値

      Avr_g = Int_g(g)/sum(g_R_Weight)
    end function Avr_g
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000271" class="method-detail">
        <a name="M000271"></a>

        <div class="method-heading">


          <a href="#M000271" class="method-signature">



          <span class="method-name">Int_g</span><span class="method-args">( g ) result(Int_g)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000271">Int_g</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>g  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元格子点データの積分および平均.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000271-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000271-source">
<pre>
    function Int_g(g)
      !
      ! 1 次元格子点データの積分および平均.
      !
      real(8), dimension(0:im), intent(in)   :: g
      !(in) 格子点データ

      real(8)                                :: Int_g
      !(out) 積分値

      Int_g = sum(g*g_R_Weight)
    end function Int_g
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000272" class="method-detail">
        <a name="M000272"></a>

        <div class="method-heading">


          <a href="#M000272" class="method-signature">



          <span class="method-name">a_Avr_ag</span><span class="method-args">( ag ) result(a_Avr_ag)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000272">a_Avr_ag</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(ag,1))</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均したデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ag  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in)入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元格子点データが並んだ 2 次元配列の平均
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000272-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000272-source">
<pre>
    function a_Avr_ag(ag)
      !
      ! 1 次元格子点データが並んだ 2 次元配列の平均
      !
      real(8), dimension(:,0:), intent(in)   :: ag
      !(in)入力格子点データ

      real(8), dimension(size(ag,1))         :: a_Avr_ag
      !(out) 平均したデータ

      a_Avr_ag = a_Int_ag(ag)/sum(g_R_Weight)
    end function a_Avr_ag
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000270" class="method-detail">
        <a name="M000270"></a>

        <div class="method-heading">


          <a href="#M000270" class="method-signature">



          <span class="method-name">a_Int_ag</span><span class="method-args">( ag ) result(a_Int_ag)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000270">a_Int_ag</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(ag,1))</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分したデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ag  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in)入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元格子点データが並んだ 2 次元配列の積分
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000270-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000270-source">
<pre>
    function a_Int_ag(ag)
      !
      ! 1 次元格子点データが並んだ 2 次元配列の積分
      !
      real(8), dimension(:,0:), intent(in)     :: ag
      !(in)入力格子点データ

      real(8), dimension(size(ag,1))           :: a_Int_ag
      !(out) 積分したデータ
      integer :: i

      if ( size(ag,2) &lt; im+1 ) then
         call MessageNotify('E','a_Int_ag', 'The Grid points of input data too small.')
      elseif ( size(ag,2) &gt; im+1 ) then
         call MessageNotify('W','a_Int_ag', 'The Grid points of input data too large.')
      endif

      a_Int_ag = 0.0d0
      do i=0,im
         a_Int_ag(:) = a_Int_ag(:) + ag(:,i)*g_R_Weight(i)
      enddo
    end function a_Int_ag
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000268" class="method-detail">
        <a name="M000268"></a>

        <div class="method-heading">


          <a href="#M000268" class="method-signature">



          <span class="method-name">ag_Dr2_au</span><span class="method-args">( au_data ) result(ag_Dr2_au)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000268">ag_Dr2_au</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(au_data,1),0:im)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの 2 階 R 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>au_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力チェビシェフデータに 2 階 R 微分を作用する(2 次元配列用).
</p>
<p>
チェビシェフデータの 2 階 R 微分とは, 対応する格子点データに 2 階 R
微分を作用させたデータのチェビシェフ変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000268-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000268-source">
<pre>
  function ag_Dr2_au(au_data)
    !
    ! 入力チェビシェフデータに 2 階 R 微分を作用する(2 次元配列用).
    !
    ! チェビシェフデータの 2 階 R 微分とは, 対応する格子点データに
    ! 2 階 R 微分を作用させたデータのチェビシェフ変換のことである.
    !
    !
    real(8), dimension(:,0:), intent(in)     :: au_data
    !(in) 入力チェビシェフデータ

    real(8), dimension(size(au_data,1),0:im) :: ag_Dr2_au
    !(out) チェビシェフデータの 2 階 R 微分

    real(8), dimension(size(au_data,1),0:size(au_data,2)-1)  :: au_g
    real(8), dimension(size(au_data,1),0:size(au_data,2)-1)  :: au_h
    ! 作業配列

    integer :: nm

    nm=size(au_data,1)

    au_g = au_Dx_au(au_data)
    au_h = au_Dx_au(au_g)

    ag_Dr2_au = 16*spread(g_R,1,nm)**2/ra**4 * ag_au(au_h) + 4*spread(2*nd+1,2,im+1)/ra**2 * ag_au(au_g) + spread(nd*(nd-1),2,im+1)/spread(g_R**2,1,nm) * ag_au(au_data)
  end function ag_Dr2_au
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000266" class="method-detail">
        <a name="M000266"></a>

        <div class="method-heading">


          <a href="#M000266" class="method-signature">



          <span class="method-name">ag_Dr_au</span><span class="method-args">( au_data ) result(ag_Dr_au)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000266">ag_Dr_au</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(au_data,1),0:im)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの R 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>au_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力チェビシェフデータに R 微分を作用する(2 次元配列用).
</p>
<p>
チェビシェフデータの R 微分とは, 対応する格子点データに R 微分を
作用させたデータのチェビシェフ変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000266-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000266-source">
<pre>
  function ag_Dr_au(au_data)
    !
    ! 入力チェビシェフデータに R 微分を作用する(2 次元配列用).
    !
    ! チェビシェフデータの R 微分とは, 対応する格子点データに R 微分を
    ! 作用させたデータのチェビシェフ変換のことである.
    !
    !
    real(8), dimension(:,0:), intent(in)     :: au_data
    !(in) 入力チェビシェフデータ

    real(8), dimension(size(au_data,1),0:im) :: ag_Dr_au
    !(out) チェビシェフデータの R 微分

    integer :: nm

    nm=size(au_data,1)

    ag_Dr_au = ag_au(au_Dx_au(au_data)) * 4*spread(g_R,1,nm)/ra**2 + spread(nd,2,im+1)/spread(g_R,1,nm) * ag_au(au_data)
  end function ag_Dr_au
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000262" class="method-detail">
        <a name="M000262"></a>

        <div class="method-heading">


          <a href="#M000262" class="method-signature">



          <span class="method-name">ag_au</span><span class="method-args">( au_data ) result(ag_au)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000262">ag_au</a>  </tt></b>  <tt> </tt> :</td><td><tt>double precision, dimension(size(au_data,1),0:im)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>au_data  </tt></b>  <tt> </tt> :</td><td><tt>double precision, dimension(:,:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
チェビシェフデータから格子データへ変換する(2 次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000262-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000262-source">
<pre>
  function ag_au(au_data)
    !
    ! チェビシェフデータから格子データへ変換する(2 次元配列用).
    !
    double precision, dimension(:,:), intent(in)       :: au_data
    !(in) チェビシェフデータ

    double precision, dimension(size(au_data,1),0:im)  :: ag_au
    !(out) 格子点データ

    double precision, dimension(size(au_data,1),0:im)  :: au_work
    ! 作業用配列

    integer :: m, mm, i

    mm = size(au_data,1)
    if ( mm /= size(nd) ) then
       call MessageNotify('E','ag_au', '1st dim. of the Chebyshev data should be same as dim. of ND.')
    end if

    if ( size(au_data,2)-1 &lt; km ) then
       call MessageNotify('E','ag_au', 'The Chebyshev dimension of input data too small.')
    elseif ( size(au_data,2)-1 &gt; km ) then
       call MessageNotify('W','ag_au', 'The Chebyshev dimension of input data too large.')
    endif

    au_work = 0.0 
     au_work(:,0:km) = au_data
    do m=1,mm
       do i=0,im
          ag_au(m,i) = sum(CB(i,:)*au_work(m,:))*g_R(i)**nd(m)
       enddo
    enddo

  end function ag_au
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000283" class="method-detail">
        <a name="M000283"></a>

        <div class="method-heading">


          <a href="#M000283" class="method-signature">



          <span class="method-name">au_BoundaryGrid_D</span><span class="method-args">( au_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>au_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m)

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(実空間での評価, 2 次元配列用)
外側境界での値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000283-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000283-source">
<pre>
  subroutine au_BoundaryGrid_D_2d(au_data,value)
    !
    ! Dirichlet 型境界条件の適用(実空間での評価, 2 次元配列用)
    ! 外側境界での値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: au_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:), intent(in), optional    :: value
    !(in) 境界値(m)

    real(8), dimension(:,:,:), allocatable     :: alu
    integer, dimension(:,:), allocatable       :: kp
    real(8), dimension(size(au_data,1),0:im)   :: ag_data
    real(8), dimension(size(nd),0:km)          :: au_work
    real(8), dimension(size(au_data,1))        :: value0 ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( im /= km ) then
       call MessageNotify('E','au_BoundaryGrid_DD', 'Chebyshev truncation and number of grid points should be same.')
    endif

    if ( size(au_data,2)-1 &lt; km ) then
       call MessageNotify('E','au_BoundaryGrid_DD', 'The Chebyshev dimension of input data too small.')
    elseif ( size(au_data,2)-1 &gt; km ) then
       call MessageNotify('W','au_BoundaryGrid_DD', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(value)) then
       value0=0
    else
       value0=value   
    endif

    if ( first ) then
       first = .false.
       allocate(alu(size(nd),0:im,0:km),kp(size(nd),0:im))

       do k=0,km
          au_work = 0
          au_work(:,k)=1.0
          alu(:,:,k) = ag_au(au_work)
       enddo

       call ludecomp(alu,kp)
    endif

    ag_data = ag_au(au_data)
    ag_data(:,0)  = value0
    au_data = lusolve(alu,kp,ag_data)

  end subroutine au_BoundaryGrid_D_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000282" class="method-detail">
        <a name="M000282"></a>

        <div class="method-heading">


          <a href="#M000282" class="method-signature">



          <span class="method-name">au_BoundaryGrid_D</span><span class="method-args">( u_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>u_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(実空間での評価, 1 次元配列用)
外側境界での値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000282-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000282-source">
<pre>
  subroutine au_BoundaryGrid_D_1d(u_data,value)
    !
    ! Dirichlet 型境界条件の適用(実空間での評価, 1 次元配列用)
    ! 外側境界での値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: u_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), intent(in), optional                :: value
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: au_work
    real(8), dimension(1)                        :: vwork           ! 境界値

    if (.not. present(value)) then
       vwork(1)=0
    else
       vwork(1) = value
    endif

    au_work(1,:)=u_data
    call au_BoundaryGrid_D_2d(au_work,vwork)
    u_data=au_work(1,:)

  end subroutine au_BoundaryGrid_D_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000285" class="method-detail">
        <a name="M000285"></a>

        <div class="method-heading">


          <a href="#M000285" class="method-signature">



          <span class="method-name">au_BoundaryGrid_N</span><span class="method-args">( au_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>au_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m)

</td></tr>
</table>
</td></tr>
</table>
<p>
外側境界 Neumann 型境界条件の適用(実空間での評価, 2 次元配列用) i=0
で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000285-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000285-source">
<pre>
  subroutine au_BoundaryGrid_N_2d(au_data,value)
    !
    ! 外側境界 Neumann 型境界条件の適用(実空間での評価, 2 次元配列用)
    ! i=0 で勾配の値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: au_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:), intent(in), optional    :: value
    !(in) 境界値(m)

    real(8), dimension(:,:,:), allocatable   :: alu
    integer, dimension(:,:), allocatable     :: kp
    real(8), dimension(size(au_data,1),0:im) :: ag_data
    real(8), dimension(size(nd),0:km)        :: au_work
    real(8), dimension(size(nd),0:im)        :: ag_work
    real(8), dimension(size(au_data,1))      :: value0   ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( im /= km ) then
       call MessageNotify('E','au_BoundaryGrid_N', 'Chebyshev truncation and number of grid points should be same.')
    endif

    if ( size(au_data,2)-1 &lt; km ) then
       call MessageNotify('E','au_BoundaryGrid_N', 'The Chebyshev dimension of input data too small.')
    elseif ( size(au_data,2)-1 &gt; km ) then
       call MessageNotify('W','au_BoundaryGrid_DN', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(value)) then
       value0=0
    else
       value0 = value
    endif

    if ( first ) then
       first = .false.
       allocate(alu(size(nd),0:im,0:km),kp(size(nd),0:im))

       do k=0,km
          au_work = 0
          au_work(:,k)=1.0
          ag_work = ag_au(au_work)
          alu(:,:,k) = ag_work
       enddo

       do k=0,km
          au_work = 0
          au_work(:,k)=1.0
          ag_work = ag_Dr_au(au_work)
          alu(:,0,k) = ag_work(:,0)
       enddo

       call ludecomp(alu,kp)
    endif

    ag_data = ag_au(au_data)
    ag_data(:,0)  = value0
    au_data = lusolve(alu,kp,ag_data)

  end subroutine au_BoundaryGrid_N_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000284" class="method-detail">
        <a name="M000284"></a>

        <div class="method-heading">


          <a href="#M000284" class="method-signature">



          <span class="method-name">au_BoundaryGrid_N</span><span class="method-args">( u_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>u_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
外側境界 Neumann 型境界条件の適用(実空間での評価, 1 次元配列用) i=0
で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000284-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000284-source">
<pre>
  subroutine au_BoundaryGrid_N_1d(u_data,value)
    !
    ! 外側境界 Neumann 型境界条件の適用(実空間での評価, 1 次元配列用)
    ! i=0 で勾配の値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: u_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), intent(in), optional                :: value
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: au_work
    real(8), dimension(1)                        :: vwork           ! 境界値

    if (.not. present(value)) then
       vwork(1)=0
    else
       vwork(1) = value
    endif

    au_work(1,:)=u_data
    call au_BoundaryGrid_N_2d(au_work,vwork)
    u_data=au_work(1,:)

  end subroutine au_BoundaryGrid_N_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000279" class="method-detail">
        <a name="M000279"></a>

        <div class="method-heading">


          <a href="#M000279" class="method-signature">



          <span class="method-name">au_BoundaryTau_D</span><span class="method-args">( au_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>au_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> データ(m,0:km) (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m)

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
外側境界(i=0)での値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000279-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000279-source">
<pre>
  subroutine au_BoundaryTau_D_2d(au_data,value)
    !
    ! Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
    ! 外側境界(i=0)での値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: au_data ! データ(m,0:km)
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:), intent(in), optional  :: value
    !(in) 境界値(m)

    real(8), dimension(:,:,:), allocatable  :: alu
    integer, dimension(:,:), allocatable    :: kp
    real(8), dimension(size(nd),0:km)        :: au_work
    real(8), dimension(size(nd),0:im)        :: ag_work
    real(8), dimension(size(au_data,1))   :: value0           ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( size(au_data,2)-1 &lt; km ) then
       call MessageNotify('E','au_BoundaryTau_D', 'The Chebyshev dimension of input data too small.')
    elseif ( size(au_data,2)-1 &gt; km ) then
       call MessageNotify('W','au_BoundaryTau_D', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(value)) then
       value0=0
    else
       value0 = value
    endif

    if ( first ) then
       first = .false.

       allocate(alu(size(nd),0:km,0:km),kp(size(nd),0:km))

       alu=0.0D0
       do k=0,km
          alu(:,k,k) = 1.0D0
       enddo

       do k=0,km
          au_work = 0.0
          au_work(:,k) = 1.0
          ag_work = ag_au(au_work)
          alu(:,km,k) = ag_work(:,0)
       enddo

       call ludecomp(alu,kp)
    endif

    au_data(:,km)   = value0
    au_data = lusolve(alu,kp,au_data)

  end subroutine au_BoundaryTau_D_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000278" class="method-detail">
        <a name="M000278"></a>

        <div class="method-heading">


          <a href="#M000278" class="method-signature">



          <span class="method-name">au_BoundaryTau_D</span><span class="method-args">( u_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>u_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 1 次元配列用) 両境界での値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000278-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000278-source">
<pre>
  subroutine au_BoundaryTau_D_1d(u_data,value)
    !
    ! Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
    ! 両境界での値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: u_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), intent(in), optional                :: value
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: au_work
    real(8), dimension(1)                        :: vwork           ! 境界値

    if (.not. present(value)) then
       vwork(1)=0
    else
       vwork(1) = value
    endif

    au_work(1,:)=u_data
    call au_BoundaryTau_D_2d(au_work,vwork)
    u_data=au_work(1,:)

  end subroutine au_BoundaryTau_D_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000281" class="method-detail">
        <a name="M000281"></a>

        <div class="method-heading">


          <a href="#M000281" class="method-signature">



          <span class="method-name">au_BoundaryTau_N</span><span class="method-args">( au_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>au_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m)

</td></tr>
</table>
</td></tr>
</table>
<p>
外側境界 Neumann 型境界条件の適用(タウ法, 2 次元配列用) i=0
で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000281-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000281-source">
<pre>
  subroutine au_BoundaryTau_N_2d(au_data,value)
    !
    ! 外側境界 Neumann 型境界条件の適用(タウ法, 2 次元配列用)
    ! i=0 で勾配の値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: au_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:), intent(in), optional    :: value
    !(in) 境界値(m)

    real(8), dimension(:,:,:), allocatable  :: alu
    integer, dimension(:,:), allocatable    :: kp
    real(8), dimension(size(nd),0:km)        :: au_work
    real(8), dimension(size(nd),0:im)        :: ag_work
    real(8), dimension(size(au_data,1))   :: value0           ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( size(au_data,2)-1 &lt; km ) then
       call MessageNotify('E','au_BoundaryTau_DN', 'The Chebyshev dimension of input data too small.')
    elseif ( size(au_data,2)-1 &gt; km ) then
       call MessageNotify('W','au_BoundaryTau_DN', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(value)) then
       value0=0
    else
       value0 = value
    endif

    if ( first ) then
       first = .false.
       allocate(alu(size(nd),0:km,0:km),kp(size(nd),0:km))

       alu=0.0D0
       do k=0,km
          alu(:,k,k) = 1.0D0
       enddo

       do k=0,km
          au_work = 0.0
          au_work(:,k) = 1.0
          ag_work = ag_Dr_au(au_work)
          alu(:,km,k) = ag_work(:,0)
       enddo

       call ludecomp(alu,kp)
    endif

    au_data(:,km)   = value0
    au_data = lusolve(alu,kp,au_data)

  end subroutine au_BoundaryTau_N_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000280" class="method-detail">
        <a name="M000280"></a>

        <div class="method-heading">


          <a href="#M000280" class="method-signature">



          <span class="method-name">au_BoundaryTau_N</span><span class="method-args">( u_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>u_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet/Neumann 型境界条件の適用(タウ法, 1 次元配列用) i=0
で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000280-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000280-source">
<pre>
  subroutine au_BoundaryTau_N_1d(u_data,value)
    !
    ! Dirichlet/Neumann 型境界条件の適用(タウ法, 1 次元配列用)
    ! i=0 で勾配の値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: u_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), intent(in), optional                :: value
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: au_work
    real(8), dimension(1)                        :: vwork           ! 境界値

    if (.not. present(value)) then
       vwork(1)=0
    else
       vwork(1) = value
    endif

    au_work(1,:)=u_data
    call au_BoundaryTau_N_2d(au_work,vwork)
    u_data=au_work(1,:)

  end subroutine au_BoundaryTau_N_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000275" class="method-detail">
        <a name="M000275"></a>

        <div class="method-heading">


          <a href="#M000275" class="method-signature">



          <span class="method-name">au_Boundary_D</span><span class="method-args">( au_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>au_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> データ(m,0:km) (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m)

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
外側境界(i=0)での値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000275-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000275-source">
<pre>
  subroutine au_BoundaryTau_D_2d(au_data,value)
    !
    ! Dirichlet 型境界条件の適用(タウ法, 2 次元配列用)
    ! 外側境界(i=0)での値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: au_data ! データ(m,0:km)
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:), intent(in), optional  :: value
    !(in) 境界値(m)

    real(8), dimension(:,:,:), allocatable  :: alu
    integer, dimension(:,:), allocatable    :: kp
    real(8), dimension(size(nd),0:km)        :: au_work
    real(8), dimension(size(nd),0:im)        :: ag_work
    real(8), dimension(size(au_data,1))   :: value0           ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( size(au_data,2)-1 &lt; km ) then
       call MessageNotify('E','au_BoundaryTau_D', 'The Chebyshev dimension of input data too small.')
    elseif ( size(au_data,2)-1 &gt; km ) then
       call MessageNotify('W','au_BoundaryTau_D', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(value)) then
       value0=0
    else
       value0 = value
    endif

    if ( first ) then
       first = .false.

       allocate(alu(size(nd),0:km,0:km),kp(size(nd),0:km))

       alu=0.0D0
       do k=0,km
          alu(:,k,k) = 1.0D0
       enddo

       do k=0,km
          au_work = 0.0
          au_work(:,k) = 1.0
          ag_work = ag_au(au_work)
          alu(:,km,k) = ag_work(:,0)
       enddo

       call ludecomp(alu,kp)
    endif

    au_data(:,km)   = value0
    au_data = lusolve(alu,kp,au_data)

  end subroutine au_BoundaryTau_D_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000274" class="method-detail">
        <a name="M000274"></a>

        <div class="method-heading">


          <a href="#M000274" class="method-signature">



          <span class="method-name">au_Boundary_D</span><span class="method-args">( u_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>u_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet 型境界条件の適用(タウ法, 1 次元配列用) 両境界での値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000274-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000274-source">
<pre>
  subroutine au_BoundaryTau_D_1d(u_data,value)
    !
    ! Dirichlet 型境界条件の適用(タウ法, 1 次元配列用)
    ! 両境界での値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: u_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), intent(in), optional                :: value
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: au_work
    real(8), dimension(1)                        :: vwork           ! 境界値

    if (.not. present(value)) then
       vwork(1)=0
    else
       vwork(1) = value
    endif

    au_work(1,:)=u_data
    call au_BoundaryTau_D_2d(au_work,vwork)
    u_data=au_work(1,:)

  end subroutine au_BoundaryTau_D_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000277" class="method-detail">
        <a name="M000277"></a>

        <div class="method-heading">


          <a href="#M000277" class="method-signature">



          <span class="method-name">au_Boundary_N</span><span class="method-args">( au_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>au_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(m,0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値(m)

</td></tr>
</table>
</td></tr>
</table>
<p>
外側境界 Neumann 型境界条件の適用(タウ法, 2 次元配列用) i=0
で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000277-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000277-source">
<pre>
  subroutine au_BoundaryTau_N_2d(au_data,value)
    !
    ! 外側境界 Neumann 型境界条件の適用(タウ法, 2 次元配列用)
    ! i=0 で勾配の値を与える.
    !
    real(8), dimension(:,0:),intent(inout)         :: au_data
    !(inout) 境界条件を適用するチェビシェフデータ(m,0:km)

    real(8), dimension(:), intent(in), optional    :: value
    !(in) 境界値(m)

    real(8), dimension(:,:,:), allocatable  :: alu
    integer, dimension(:,:), allocatable    :: kp
    real(8), dimension(size(nd),0:km)        :: au_work
    real(8), dimension(size(nd),0:im)        :: ag_work
    real(8), dimension(size(au_data,1))   :: value0           ! 境界値

    logical :: first = .true.
    integer :: k
    save    :: alu, kp, first

    if ( size(au_data,2)-1 &lt; km ) then
       call MessageNotify('E','au_BoundaryTau_DN', 'The Chebyshev dimension of input data too small.')
    elseif ( size(au_data,2)-1 &gt; km ) then
       call MessageNotify('W','au_BoundaryTau_DN', 'The Chebyshev dimension of input data too large.')
    endif

    if (.not. present(value)) then
       value0=0
    else
       value0 = value
    endif

    if ( first ) then
       first = .false.
       allocate(alu(size(nd),0:km,0:km),kp(size(nd),0:km))

       alu=0.0D0
       do k=0,km
          alu(:,k,k) = 1.0D0
       enddo

       do k=0,km
          au_work = 0.0
          au_work(:,k) = 1.0
          ag_work = ag_Dr_au(au_work)
          alu(:,km,k) = ag_work(:,0)
       enddo

       call ludecomp(alu,kp)
    endif

    au_data(:,km)   = value0
    au_data = lusolve(alu,kp,au_data)

  end subroutine au_BoundaryTau_N_2d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000276" class="method-detail">
        <a name="M000276"></a>

        <div class="method-heading">


          <a href="#M000276" class="method-signature">



          <span class="method-name">au_Boundary_N</span><span class="method-args">( u_data, [value] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>u_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するチェビシェフデータ(0:km)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>value  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界値

</td></tr>
</table>
</td></tr>
</table>
<p>
Dirichlet/Neumann 型境界条件の適用(タウ法, 1 次元配列用) i=0
で勾配の値を与える.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000276-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000276-source">
<pre>
  subroutine au_BoundaryTau_N_1d(u_data,value)
    !
    ! Dirichlet/Neumann 型境界条件の適用(タウ法, 1 次元配列用)
    ! i=0 で勾配の値を与える.
    !
    real(8), dimension(0:km),intent(inout)       :: u_data
    !(inout) 境界条件を適用するチェビシェフデータ(0:km)

    real(8), intent(in), optional                :: value
    !(in) 境界値

    real(8), dimension(1,0:km)                   :: au_work
    real(8), dimension(1)                        :: vwork           ! 境界値

    if (.not. present(value)) then
       vwork(1)=0
    else
       vwork(1) = value
    endif

    au_work(1,:)=u_data
    call au_BoundaryTau_N_2d(au_work,vwork)
    u_data=au_work(1,:)

  end subroutine au_BoundaryTau_N_1d
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000261" class="method-detail">
        <a name="M000261"></a>

        <div class="method-heading">


          <a href="#M000261" class="method-signature">



          <span class="method-name">au_Initial</span><span class="method-args">( i_in, k_in, r_in, nd_in ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>i_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>k_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 切断波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>r_in  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 外側境界の座標(半径)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>nd_in(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 重み r^n の指数

</td></tr>
</table>
</td></tr>
</table>
<p>
チェビシェフ変換の格子点数, 波数, 領域の大きさ, 重みを設定する.
</p>
<p>
他の関数や変数を呼ぶ前に, 最初にこのサブルーチンを呼んで
初期設定をしなければならない.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000261-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000261-source">
<pre>
  subroutine au_Initial(i_in,k_in,r_in,nd_in)
    !
    ! チェビシェフ変換の格子点数, 波数, 領域の大きさ, 重みを設定する.
    ! 
    ! 他の関数や変数を呼ぶ前に, 最初にこのサブルーチンを呼んで
    ! 初期設定をしなければならない.
    !
    integer,intent(in) :: i_in              !(in) 格子点数
    integer,intent(in) :: k_in              !(in) 切断波数
    real(8),intent(in) :: r_in              !(in) 外側境界の座標(半径)
    integer,intent(in) :: nd_in(:)          !(in) 重み r^n の指数

    real(8), allocatable :: c(:), w(:)   ! 重み関数
    real(8) :: t
    integer :: ii,kk

    im=i_in 
     km=k_in 
     ra = r_in

    if ( km .gt. im ) then
       call MessageNotify('E','au_initial','KM shoud be less equal to IM')
    endif

    if ( allocated(nd) ) deallocate(nd)
    allocate(nd(size(nd_in)))
    nd = nd_in

    if ( allocated(CF) ) deallocate(CF)
    if ( allocated(CB) ) deallocate(CB)
    allocate(CF(0:im,0:im),CB(0:im,0:im))

    if ( allocated(C) ) deallocate(W)
    if ( allocated(W) ) deallocate(W)
    allocate(c(0:im),w(0:im))

    c = 1.0D0 
     c(0) = 2.0D0
    w = 2*pi/(2*im+1) 
     w(0) = pi/(2*im+1)

    do ii=0,im
       do kk=0,im
          CF(kk,ii)=2.0D0/(pi*c(kk))*cos(2*pi*ii*kk/(2*im+1))*w(ii)
       enddo
    enddo

    do kk=0,im
       do ii=0,im
          CB(ii,kk)=cos(2*pi*ii*kk/(2*im+1))
       enddo
    enddo

    if ( allocated(g_R) ) deallocate(g_R)
    allocate(g_R(0:im))

    do ii=0,im
       t = 2*pi*ii/(2*im+1)
       g_R(ii) = ra*sqrt((1+cos(t))/2)    ! cos(t) = 2(r/a)^2 - 1
    enddo

    if ( allocated(g_R_Weight) ) deallocate(g_R_Weight)
    allocate(g_R_Weight(0:im))
    do ii=0,im
       g_R_Weight(ii) = 0.0
       do kk=0,km
          g_R_Weight(ii) = g_R_Weight(ii) + 1.0D0/(1.0D0/4.0D0-kk**2) * cos(2*kk*ii*pi/(2*im+1))/c(kk)
       enddo
       g_R_Weight(ii) = ra/(2*pi) * g_R_Weight(ii)* w(ii)
    enddo

    deallocate(c,w)

    call MessageNotify('M','au_initial','au_module (2009/01/09) is initialized')
  end subroutine au_Initial
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000264" class="method-detail">
        <a name="M000264"></a>

        <div class="method-heading">


          <a href="#M000264" class="method-signature">



          <span class="method-name">au_ag</span><span class="method-args">( ag_data ) result(au_ag)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000264">au_ag</a>  </tt></b>  <tt> </tt> :</td><td><tt>double precision, dimension(size(ag_data,1),0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ag_data  </tt></b>  <tt> </tt> :</td><td><tt>double precision, dimension(:,:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからチェビシェフデータへ変換する(2 次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000264-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000264-source">
<pre>
  function au_ag(ag_data)
    !
    ! 格子データからチェビシェフデータへ変換する(2 次元配列用).
    !
    double precision, dimension(:,:), intent(in)      :: ag_data
    !(in) 格子点データ

    double precision, dimension(size(ag_data,1),0:km) :: au_ag
    !(out) チェビシェフデータ

    double precision, dimension(size(ag_data,1),0:im) :: au_work
    !作業用配列

    integer :: m, mm, k

    mm = size(ag_data,1)
    if ( mm /= size(nd) ) then
       call MessageNotify('E','ag_au', '1st dim. of the Chebyshev data should be same as dim. of ND.')
    end if

    if ( size(ag_data,2)-1 &lt; im ) then
       call MessageNotify('E','au_ag', 'The Grid points of input data too small.')
    elseif ( size(ag_data,2)-1 &gt; im ) then
       call MessageNotify('W','au_ag', 'The Grid points of input data too large.')
    endif

    do m=1,mm
       do k=0,im
          au_work(m,k) = sum(CF(k,:)*ag_data(m,:)/g_R**nd(m))
       enddo
    enddo
    au_ag = au_work(:,0:km)

  end function au_ag
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000269" class="method-detail">
        <a name="M000269"></a>

        <div class="method-heading">


          <a href="#M000269" class="method-signature">



          <span class="method-name">g_Dr2_u</span><span class="method-args">( u_data ) result(g_Dr2_u)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000269">g_Dr2_u</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの 2 階 R 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>u_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力チェビシェフデータに 2 階 R 微分を作用する(1 次元配列用).
</p>
<p>
チェビシェフデータの 2 階 R 微分とは, 対応する格子点データに 2 階 R
微分を作用させたデータのチェビシェフ変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000269-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000269-source">
<pre>
  function g_Dr2_u(u_data)
    !
    ! 入力チェビシェフデータに 2 階 R 微分を作用する(1 次元配列用).
    !
    ! チェビシェフデータの 2 階 R 微分とは, 対応する格子点データに 
    ! 2 階 R 微分を作用させたデータのチェビシェフ変換のことである.
    !
    !
    real(8), dimension(:), intent(in)   :: u_data
    !(in) 入力チェビシェフデータ

    real(8), dimension(0:im)            :: g_Dr2_u
    !(out) チェビシェフデータの 2 階 R 微分

    real(8), dimension(1,size(u_data))  :: au_work
    ! 作業用配列

    real(8), dimension(1,0:im)          :: ag_work
    ! 作業用配列
    
    au_work(1,:) = u_data
    ag_work = ag_Dr2_au(au_work)
    g_Dr2_u = ag_work(1,:)

  end function g_Dr2_u
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000267" class="method-detail">
        <a name="M000267"></a>

        <div class="method-heading">


          <a href="#M000267" class="method-signature">



          <span class="method-name">g_Dr_u</span><span class="method-args">( u_data ) result(g_Dr_u)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000267">g_Dr_u</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの R 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>u_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力チェビシェフデータに R 微分を作用する(1 次元配列用).
</p>
<p>
チェビシェフデータの R 微分とは, 対応する格子点データに R 微分を
作用させたデータのチェビシェフ変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000267-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000267-source">
<pre>
  function g_Dr_u(u_data)
    !
    ! 入力チェビシェフデータに R 微分を作用する(1 次元配列用).
    !
    ! チェビシェフデータの R 微分とは, 対応する格子点データに R 微分を
    ! 作用させたデータのチェビシェフ変換のことである.
    !
    !
    real(8), dimension(:), intent(in)   :: u_data
    !(in) 入力チェビシェフデータ

    real(8), dimension(0:im)            :: g_Dr_u
    !(out) チェビシェフデータの R 微分

    real(8), dimension(1,size(u_data))  :: au_work
    ! 作業用配列

    real(8), dimension(1,0:im)          :: ag_work
    ! 作業用配列
    
    au_work(1,:) = u_data
    ag_work = ag_Dr_au(au_work)
    g_Dr_u = ag_work(1,:)

  end function g_Dr_u
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000259" class="method-detail">
        <a name="M000259"></a>

        <div class="method-heading">




          <span class="method-name">g_R</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000259">g_R</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点座標 Chebyshev-Gauss-Radau 格子点

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M000260" class="method-detail">
        <a name="M000260"></a>

        <div class="method-heading">




          <span class="method-name">g_R_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000260">g_R_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点重み座標 各格子点における積分のための重みが格納してある

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M000263" class="method-detail">
        <a name="M000263"></a>

        <div class="method-heading">


          <a href="#M000263" class="method-signature">



          <span class="method-name">g_u</span><span class="method-args">( u_data ) result(g_u)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000263">g_u</a>  </tt></b>  <tt> </tt> :</td><td><tt>double precision, dimension(0:im)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>u_data  </tt></b>  <tt> </tt> :</td><td><tt>double precision, dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
チェビシェフデータから格子データへ変換する(1 次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000263-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000263-source">
<pre>
  function g_u(u_data)
    !
    ! チェビシェフデータから格子データへ変換する(1 次元配列用).
    !
    double precision, dimension(:), intent(in)  :: u_data
    !(in) チェビシェフデータ

    double precision, dimension(0:im)           :: g_u
    !(out) 格子点データ

    double precision, dimension(1,size(u_data)) :: u_work
    ! 作業用配列
    double precision, dimension(1,0:im)         :: g_work
    ! 作業用配列

    u_work(1,:) = u_data  
    g_work = ag_au(u_work)
    g_u = g_work(1,:)

  end function g_u
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000265" class="method-detail">
        <a name="M000265"></a>

        <div class="method-heading">


          <a href="#M000265" class="method-signature">



          <span class="method-name">u_g</span><span class="method-args">( g_data ) result(u_g)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="au_module.html#M000265">u_g</a>  </tt></b>  <tt> </tt> :</td><td><tt>double precision, dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>g_data  </tt></b>  <tt> </tt> :</td><td><tt>double precision, dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子 -&gt; スペクトル
</p>
<p>
格子データからチェビシェフデータへ変換する(1 次元配列用).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000265-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000265-source">
<pre>
  function u_g(g_data)  ! 格子 -&gt; スペクトル
    !
    ! 格子データからチェビシェフデータへ変換する(1 次元配列用).
    !
    double precision, dimension(:), intent(in)     :: g_data
    !(in) 格子点データ

    double precision, dimension(0:km)              :: u_g
    !(out) チェビシェフデータ

    real(8), dimension(1,size(g_data)) :: ag_work
    real(8), dimension(1,0:km)         :: au_work

    ag_work(1,:) = g_data
    au_work = au_ag(ag_work)
    u_g = au_work(1,:)
    
  end function u_g
</pre>
          </div>

        </div>
      </div>



    </div>



  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
