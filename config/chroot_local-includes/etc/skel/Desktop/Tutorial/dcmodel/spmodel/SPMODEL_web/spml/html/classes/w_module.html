<?xml version="1.0" encoding="euc-jp"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: w_module</title>
  <meta http-equiv="Content-Type" content="text/html; charset=euc-jp" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">w_module</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../files/src/w_module_f90.html">

                src/w_module.f90

                </a>


        <br />
            </td>
        </tr>


        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">


  <div id="contextContent">



    <div id="description">
      <h1><a href="w_module.html">w_module</a></h1>
<table>
<tr><td valign="top">Authors:</td><td>Shin-ichi Takehiro, Youhei SASAKI

</td></tr>
<tr><td valign="top">Version:</td><td>$Id: <a href="../files/src/w_module_f90.html">w_module.f90</a>,v 1.19
2009-02-28 21:33:47 uwabami Exp $

</td></tr>
<tr><td valign="top">Copyright&amp;License:</td><td>See <a href="../../COPYRIGHT">COPYRIGHT</a>

</td></tr>
</table>
<h2>概要</h2>
<p>
spml/w_module モジュールは球面上での 2 次元流体運動を
球面調和函数を用いたスペクトル法によって数値計算するための Fortran90
関数を提供する.
</p>
<p>
<a href="w_module.html">w_module</a> は実際には基本変換, 微分計算,
積分・平均計算, スペクトル解析 をそれぞれ担っている下部モジュール <a
href="w_base_module.html">w_base_module</a>, <a
href="w_deriv_module.html">w_deriv_module</a>, <a
href="w_integral_module.html">w_integral_module</a>, <a
href="w_spectrum_module.html">w_spectrum_module</a> からなっている.
</p>
<p>
内部で ISPACK の SPPACK と SNPACK の Fortran77 サブルーチンを呼んでいる.
スペクトルデータおよび格子点データの格納方法や変換の詳しい計算法に ついては
ISPACK/SNPACK,SPPACK のマニュアルを参照されたい.
</p>
<h2>関数・変数の名前と型について</h2>
<h3>命名法</h3>
<ul>
<li>関数名の先頭 (w_, nm_, n_, xy_, x_, y_) は, 返す値の形を示している.

<table>
<tr><td valign="top">w_  :</td><td>スペクトルデータ

</td></tr>
<tr><td valign="top">xy_ :</td><td>2 次元格子点データ

</td></tr>
<tr><td valign="top">nm_ :</td><td>スペクトルデータの並んだ 3 次元配列(スペクトルデータの並びは 全波数 n,
帯状波数 m で指定される 2 次元配列)

</td></tr>
<tr><td valign="top">n_  :</td><td>スペクトルデータの並んだ 2 次元配列 (スペクトルデータの並びは 全波数 n
で指定される 1 次元配列)

</td></tr>
<tr><td valign="top">x_  :</td><td>経度方向 1 次元格子点データ

</td></tr>
<tr><td valign="top">y_  :</td><td>緯度方向 1 次元格子点データ

</td></tr>
</table>
</li>
<li>関数名の間の文字列(DLon, GradLat, GradLat, DivLon, DivLat, Lapla, LaplaInv,
Jacobian)は, その関数の作用を表している.

</li>
<li>関数名の最後 (_w_w, _w, _xy, _x, _y) は, 入力変数の形スペクトルデータ
および格子点データであることを示している.

<table>
<tr><td valign="top">_w   :</td><td>スペクトルデータ

</td></tr>
<tr><td valign="top">_w_w :</td><td>2 つのスペクトルデータ

</td></tr>
<tr><td valign="top">_xy  :</td><td>2 次元格子点データ

</td></tr>
<tr><td valign="top">_x   :</td><td>経度方向 1 次元格子点データ

</td></tr>
<tr><td valign="top">_y   :</td><td>緯度方向 1 次元格子点データ

</td></tr>
</table>
</li>
</ul>
<h3>各データの種類の説明</h3>
<ul>
<li>xy : 2 次元格子点データ.

<ul>
<li>変数の種類と次元は real(8), dimension(0:im-1,1:jm).

</li>
<li>im, jm はそれぞれ経度, 緯度座標の格子点数であり, サブルーチン <a
href="w_module.html#M000599">w_Initial</a> にてあらかじめ設定しておく.

</li>
</ul>
</li>
<li>w : スペクトルデータ.

<ul>
<li>変数の種類と次元は real(8), dimension((nm+1)*(nm+1)).

</li>
<li>nm は球面調和函数の最大全波数であり, サブルーチン <a
href="w_module.html#M000599">w_Initial</a> にて あらかじめ設定しておく.

</li>
<li>スペクトルデータの格納のされ方は関数 <a
href="w_module.html#M000608">l_nm</a>, <a
href="w_module.html#M000612">nm_l</a> によって 調べることができる.

</li>
</ul>
</li>
<li>nm : スペクトルデータの並んだ 2 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(0:nm,-nm:nm). 第 1 次元が水平全波数,
第 2 次元が帯状波数を表す.

</li>
<li>nm は球面調和函数の最大全波数であり, サブルーチン <a
href="w_module.html#M000599">w_Initial</a> にて あらかじめ設定しておく.

</li>
</ul>
</li>
<li>n : スペクトルデータの並んだ 1 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(0:nm).

</li>
<li>第 1 次元が水平全波数を表す. nm は球面調和函数の最大全波数であり,
サブルーチン <a href="w_module.html#M000599">w_Initial</a>
にてあらかじめ設定しておく.

</li>
</ul>
</li>
<li>x, y : 経度, 緯度方向 1 次元格子点データ.

<ul>
<li>変数の種類と次元はそれぞれ real(8), dimension(0:im-1) および real(8),
dimension(1:jm).

</li>
</ul>
</li>
<li>w_ で始まる関数が返す値はスペクトルデータに同じ.

</li>
<li>xy_ で始まる関数が返す値は 2 次元格子点データに同じ.

</li>
<li>x_, y_ で始まる関数が返す値は 1 次元格子点データに同じ.

</li>
<li>スペクトルデータに対する微分等の作用とは, 対応する格子点データに
微分などを作用させたデータをスペクトル変換したものことである.

</li>
</ul>
<h2>変数・手続き群の要約</h2>
<h4>初期化</h4>
<table>
<tr><td valign="top"><a href="w_module.html#M000599">w_Initial</a> :</td><td>スペクトル変換の格子点数, 波数, 領域の大きさの設定

</td></tr>
</table>
<h4>座標変数</h4>
<table>
<tr><td valign="top"><a href="w_module.html#M000600">x_Lon</a>, <a href="w_module.html#M000601">y_Lat</a>     :</td><td>格子点座標(緯度, 経度座標)を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000602">x_Lon_Weight</a>, <a href="w_module.html#M000603">y_Lat_Weight</a> :</td><td>重み座標を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000604">xy_Lon</a>, <a href="w_module.html#M000605">xy_Lat</a>   :</td><td>格子点データの経度・緯度座標(X,Y) (格子点データ型 2 次元配列)

</td></tr>
</table>
<h4>基本変換</h4>
<table>
<tr><td valign="top"><a href="w_module.html#M000606">xy_w</a> :</td><td>スペクトルデータから格子データへの変換

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000607">w_xy</a> :</td><td>格子データからスペクトルデータへの変換

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000608">l_nm</a>, <a href="w_module.html#M000612">nm_l</a> :</td><td>スペクトルデータの格納位置と全波数・帯状波数の変換

</td></tr>
</table>
<h4>微分</h4>
<table>
<tr><td valign="top"><a href="w_module.html#M000616">w_Lapla_w</a>       :</td><td>スペクトルデータにラプラシアンを作用させる

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000614">rn</a>              :</td><td>スペクトルデータのラプラシアンを計算するための係数.

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000615">irm</a>             :</td><td>経度微分演算用配列

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000617">w_LaplaInv_w</a>    :</td><td>スペクトルデータにラプラシアンの逆変換を作用させる

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000618">w_DLon_w</a>        :</td><td>スペクトルデータに経度微分∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000619">xy_GradLon_w</a>    :</td><td>スペクトルデータに 勾配型経度微分 1/cosφ・∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000620">xy_GradLat_w</a>    :</td><td>スペクトルデータに勾配型緯度微分∂/∂φを作用させる

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000621">w_DivLon_xy</a>     :</td><td>格子データに発散型経度微分 1/cosφ・∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000622">w_DivLat_xy</a>     :</td><td>格子データに 発散型緯度微分 1/cosφ・∂(g cosφ)/∂φを作用させる

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000623">w_Div_xy_xy</a>     :</td><td>ベクトル成分である 2 つの格子データに発散を作用させる

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000624">w_Jacobian_w_w</a>  :</td><td>2 つのスペクトルデータからヤコビアンを計算する

</td></tr>
</table>
<h4>微分(λ,μ=sinφ 座標)</h4>
<table>
<tr><td valign="top"><a href="w_module.html#M000625">xy_GradLambda_w</a> :</td><td>スペクトルデータに勾配型経度微分∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000626">xy_GradMu_w</a>     :</td><td>スペクトルデータに 勾配型緯度微分 (1-μ^2)∂/∂μを作用させる

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000627">w_DivLambda_xy</a>  :</td><td>格子データに 発散型経度微分 1/(1-μ^2)・∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000628">w_DivMu_xy</a>      :</td><td>格子データに発散型緯度微分∂/∂μを作用させる

</td></tr>
</table>
<h4>補間</h4>
<table>
<tr><td valign="top"><a href="w_module.html#M000629">Interpolate_w</a> :</td><td>スペクトルデータから任意の点での値を求める.

</td></tr>
</table>
<h4>積分・平均</h4>
<table>
<tr><td valign="top"><a href="w_module.html#M000630">IntLonLat_xy</a>, <a href="w_module.html#M000635">AvrLonLat_xy</a> :</td><td>2 次元格子点データの全領域積分および平均

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000631">y_IntLon_xy</a>, <a href="w_module.html#M000636">y_AvrLon_xy</a>   :</td><td>2 次元格子点データの経度方向積分および平均

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000632">IntLon_x</a>, <a href="w_module.html#M000637">AvrLon_x</a>         :</td><td>1 次元(X)格子点データの経度方向積分および平均

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000633">x_IntLat_xy</a>, <a href="w_module.html#M000638">x_AvrLat_xy</a>   :</td><td>2 次元格子点データの緯度方向積分および平均

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000634">IntLat_y</a>, <a href="w_module.html#M000639">AvrLat_y</a>         :</td><td>1 次元(Y)格子点データの緯度方向積分および平均

</td></tr>
</table>
<h4>スペクトル解析</h4>
<table>
<tr><td valign="top"><a href="w_module.html#M000641">nm_EnergyFromStreamfunc_w</a>  :</td><td>流線関数からエネルギースペクトルを計算する (水平全波数 n, 帯状波数 m 空間)

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000642">n_EnergyFromStreamfunc_w</a>   :</td><td>流線関数からエネルギースペクトルを計算する (水平全波数 n 空間)

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000643">nm_EnstrophyFromStreamfunc_w</a>  :</td><td>流線関数からエンストロフィースペクトルを 計算する (水平全波数 n, 帯状波数 m
空間)

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000644">n_EnstrophyFromStreamfunc_w</a>   :</td><td>流線関数からエンストロフィースペクトルを 計算する (水平全波数 n 空間)

</td></tr>
<tr><td valign="top"><a href="w_module.html#M000640">w_spectrum_VMiss</a>              :</td><td>欠損値

</td></tr>
</table>

    </div>





   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M000639">AvrLat_y</a>&nbsp;&nbsp;

        <a href="#M000635">AvrLonLat_xy</a>&nbsp;&nbsp;

        <a href="#M000637">AvrLon_x</a>&nbsp;&nbsp;

        <a href="#M000634">IntLat_y</a>&nbsp;&nbsp;

        <a href="#M000630">IntLonLat_xy</a>&nbsp;&nbsp;

        <a href="#M000632">IntLon_x</a>&nbsp;&nbsp;

        <a href="#M000629">Interpolate_w</a>&nbsp;&nbsp;

        <a href="#M000615">irm</a>&nbsp;&nbsp;

        <a href="#M000608">l_nm</a>&nbsp;&nbsp;

        <a href="#M000609">l_nm</a>&nbsp;&nbsp;

        <a href="#M000610">l_nm</a>&nbsp;&nbsp;

        <a href="#M000611">l_nm</a>&nbsp;&nbsp;

        <a href="#M000642">n_EnergyFromStreamfunc_w</a>&nbsp;&nbsp;

        <a href="#M000644">n_EnstrophyFromStreamfunc_w</a>&nbsp;&nbsp;

        <a href="#M000641">nm_EnergyFromStreamfunc_w</a>&nbsp;&nbsp;

        <a href="#M000643">nm_EnstrophyFromStreamfunc_w</a>&nbsp;&nbsp;

        <a href="#M000612">nm_l</a>&nbsp;&nbsp;

        <a href="#M000613">nm_l</a>&nbsp;&nbsp;

        <a href="#M000614">rn</a>&nbsp;&nbsp;

        <a href="#M000618">w_DLon_w</a>&nbsp;&nbsp;

        <a href="#M000627">w_DivLambda_xy</a>&nbsp;&nbsp;

        <a href="#M000622">w_DivLat_xy</a>&nbsp;&nbsp;

        <a href="#M000621">w_DivLon_xy</a>&nbsp;&nbsp;

        <a href="#M000628">w_DivMu_xy</a>&nbsp;&nbsp;

        <a href="#M000623">w_Div_xy_xy</a>&nbsp;&nbsp;

        <a href="#M000624">w_Jacobian_w_w</a>&nbsp;&nbsp;

        <a href="#M000617">w_LaplaInv_w</a>&nbsp;&nbsp;

        <a href="#M000616">w_Lapla_w</a>&nbsp;&nbsp;

        <a href="#M000599">w_initial</a>&nbsp;&nbsp;

        <a href="#M000640">w_spectrum_VMiss</a>&nbsp;&nbsp;

        <a href="#M000607">w_xy</a>&nbsp;&nbsp;

        <a href="#M000638">x_AvrLat_xy</a>&nbsp;&nbsp;

        <a href="#M000633">x_IntLat_xy</a>&nbsp;&nbsp;

        <a href="#M000600">x_Lon</a>&nbsp;&nbsp;

        <a href="#M000602">x_Lon_Weight</a>&nbsp;&nbsp;

        <a href="#M000625">xy_GradLambda_w</a>&nbsp;&nbsp;

        <a href="#M000620">xy_GradLat_w</a>&nbsp;&nbsp;

        <a href="#M000619">xy_GradLon_w</a>&nbsp;&nbsp;

        <a href="#M000626">xy_GradMu_w</a>&nbsp;&nbsp;

        <a href="#M000605">xy_Lat</a>&nbsp;&nbsp;

        <a href="#M000604">xy_Lon</a>&nbsp;&nbsp;

        <a href="#M000606">xy_w</a>&nbsp;&nbsp;

        <a href="#M000636">y_AvrLon_xy</a>&nbsp;&nbsp;

        <a href="#M000631">y_IntLon_xy</a>&nbsp;&nbsp;

        <a href="#M000601">y_Lat</a>&nbsp;&nbsp;

        <a href="#M000603">y_Lat_Weight</a>&nbsp;&nbsp;
      </div>
    </div>


  </div>


    <!-- if includes -->

    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">

        <span class="include-name"><a href="w_base_module.html">w_base_module</a></span>

        <span class="include-name"><a href="w_deriv_module.html">w_deriv_module</a></span>

        <span class="include-name"><a href="w_integral_module.html">w_integral_module</a></span>

        <span class="include-name"><a href="w_spectrum_module.html">w_spectrum_module</a></span>

        <span class="include-name"><a href="w_interpolate_module.html">w_interpolate_module</a></span>
      </div>
    </div>



    <div id="section">










      


    <!-- if method_list -->

    <div id="methods">


      <h3 class="section-bar">Public Instance methods</h3>


      <div id="method-M000639" class="method-detail">
        <a name="M000639"></a>

        <div class="method-heading">




          <span class="method-name">AvrLat_y</span><span class="method-args">( y_data ) result(AvrLat_y)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000639">AvrLat_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y_data(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(Y)格子点データの緯度(Y)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, y_Y_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="w_integral_module.html#M000254">w_integral_module#AvrLat_y</a>
</p>


        </div>
      </div>


      <div id="method-M000635" class="method-detail">
        <a name="M000635"></a>

        <div class="method-heading">




          <span class="method-name">AvrLonLat_xy</span><span class="method-args">( xy_data ) result(AvrLonLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000635">AvrLonLat_xy</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの全領域平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた 総和を計算し,
x_X_Weight*y_Y_Weight の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="w_integral_module.html#M000258">w_integral_module#AvrLonLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M000637" class="method-detail">
        <a name="M000637"></a>

        <div class="method-heading">




          <span class="method-name">AvrLon_x</span><span class="method-args">( x_data ) result(AvrLon_x)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000637">AvrLon_x</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>x_data(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(X)格子点データの経度(X)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, x_X_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="w_integral_module.html#M000255">w_integral_module#AvrLon_x</a>
</p>


        </div>
      </div>


      <div id="method-M000634" class="method-detail">
        <a name="M000634"></a>

        <div class="method-heading">




          <span class="method-name">IntLat_y</span><span class="method-args">( y_data ) result(IntLat_y)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000634">IntLat_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y_data(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元緯度(Y)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元緯度(Y)格子点データの Y 方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="w_integral_module.html#M000249">w_integral_module#IntLat_y</a>
</p>


        </div>
      </div>


      <div id="method-M000630" class="method-detail">
        <a name="M000630"></a>

        <div class="method-heading">




          <span class="method-name">IntLonLat_xy</span><span class="method-args">( xy_data ) result(IntLonLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000630">IntLonLat_xy</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの全領域積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた
総和を計算している.
</p>
<p>
Original external subprogram is <a
href="w_integral_module.html#M000253">w_integral_module#IntLonLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M000632" class="method-detail">
        <a name="M000632"></a>

        <div class="method-heading">




          <span class="method-name">IntLon_x</span><span class="method-args">( x_data ) result(IntLon_x)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000632">IntLon_x</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>x_data(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元経度(X)格子点データの X 方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="w_integral_module.html#M000250">w_integral_module#IntLon_x</a>
</p>


        </div>
      </div>


      <div id="method-M000629" class="method-detail">
        <a name="M000629"></a>

        <div class="method-heading">




          <span class="method-name">Interpolate_w</span><span class="method-args">( w_data, alon, alat ) result(Interpolate_array00_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>Interpolate_array00_w  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間した値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>alon  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間する位置(経度)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>alat  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間する位置(緯度)

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度 alat, 経度 alon における関数値を その球面調和変換係数 w_data
から補間計算する
</p>
<p>
Original external subprogram is <a
href="w_interpolate_module.html#M000204">w_interpolate_module#Interpolate_w</a>
</p>


        </div>
      </div>


      <div id="method-M000615" class="method-detail">
        <a name="M000615"></a>

        <div class="method-heading">




          <span class="method-name">irm</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000615">irm</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 経度微分演算用配列

<p>
スペクトルデータの経度微分を計算するための係数. 配列サイズは (
(nm+1)*(nm+1),2 ) である.
</p>
<p>
L番目の格納位置のスペクトルが実部なら, <a
href="w_module.html#M000615">irm</a>(L,1)には対応する虚部の格納位置が, <a
href="w_module.html#M000615">irm</a>(L,2) には東西波数 m が格納されている.
また, L番目の格納位置のスペクトル が虚部なら, <a
href="w_module.html#M000615">irm</a>(L,1)には対応する実部の格納位置が, <a
href="w_module.html#M000615">irm</a>(L,2)には -m が格納され ている.
</p>
</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002135">w_deriv_module#irm</a>
</p>


        </div>
      </div>


      <div id="method-M000608" class="method-detail">
        <a name="M000608"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( n, m ) result(l_nm_array00)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array00  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>n  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>m  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
引数 n,m がともに整数値の場合, 整数値を返す.
</p>
<p>
Original external subprogram is <a
href="w_base_module.html#M001525">w_base_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M000609" class="method-detail">
        <a name="M000609"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( n, marray ) result(l_nm_array01)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array01(size(marray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>n  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>marray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置
</p>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1 引数 n が整数, 第 2 引数 marray が整数 1 次元配列の場合, marray
と同じ大きさの 1 次元整数配列を返す.
</p>
<p>
Original external subprogram is <a
href="w_base_module.html#M001525">w_base_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M000610" class="method-detail">
        <a name="M000610"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( narray, m ) result(l_nm_array10)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array10(size(narray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>narray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>m  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1 引数 narray が整数 1 次元配列, 第 2 引数 m が整数の場合, narray
と同じ大きさの 1 次元整数配列を返す.
</p>
<p>
Original external subprogram is <a
href="w_base_module.html#M001525">w_base_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M000611" class="method-detail">
        <a name="M000611"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( narray, marray ) result(l_nm_array11)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array11(size(narray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>narray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>marray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1,2 引数 narray, marray がともに整数 1 次元配列の場合, narray, marray
と同じ大きさの 1 次元整数配列を返す. narray, marray
は同じ大きさでなければならない.
</p>
<p>
Original external subprogram is <a
href="w_base_module.html#M001525">w_base_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M000642" class="method-detail">
        <a name="M000642"></a>

        <div class="method-heading">




          <span class="method-name">n_EnergyFromStreamfunc_w</span><span class="method-args">( w_Strfunc ) result(n_EnergyFromStreamfunc_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000642">n_EnergyFromStreamfunc_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトル (水平全波数 n 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_Strfunc(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータから各全波数のエネルギー成分(スペクトル)を
計算する(1 層用).
</p>
<pre>
 * 全波数 n の流線関数のスペクトル成分ψ(n,m) から
   エネルギースペクトルはΣ[m=-nm]^nm(1/2)n(n+1)ψ(n,m)^2
   と計算される.

 * 全てのエネルギースペクトル成分の和に 4πをかけたものが
   球面上での全エネルギーに等しい.
</pre>
<p>
Original external subprogram is <a
href="w_spectrum_module.html#M000201">w_spectrum_module#n_EnergyFromStreamfunc_w</a>
</p>


        </div>
      </div>


      <div id="method-M000644" class="method-detail">
        <a name="M000644"></a>

        <div class="method-heading">




          <span class="method-name">n_EnstrophyFromStreamfunc_w</span><span class="method-args">( w_Strfunc ) result(n_EnstrophyFromStreamfunc_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000644">n_EnstrophyFromStreamfunc_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エンストロフィースペクトル(水平全波数 n 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_Strfunc(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータから各全波数のエネルギー成分(スペクトル)を
計算する(1 層用)
</p>
<ul>
<li>全波数 n の流線関数のスペクトル成分ψ(n,m) からエンストロフィー
スペクトルはΣ[m=-nm]^nm(1/2)n^2(n+1)^2ψ(n,m)^2 と計算される.

</li>
<li>全てのエネルギースペクトル成分の和に 4π/R^2 をかけたものが
球面上での全エンストフィーに等しい.

</li>
</ul>
<p>
Original external subprogram is <a
href="w_spectrum_module.html#M000203">w_spectrum_module#n_EnstrophyFromStreamfunc_w</a>
</p>


        </div>
      </div>


      <div id="method-M000641" class="method-detail">
        <a name="M000641"></a>

        <div class="method-heading">




          <span class="method-name">nm_EnergyFromStreamfunc_w</span><span class="method-args">( w_Strfunc ) result(nm_EnergyFromStreamfunc_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000641">nm_EnergyFromStreamfunc_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,-nm:nm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトル(水平全波数 n, 帯状波数 m 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_Strfunc(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータからエネルギーの球面調和函数成分
(スペクトル)を計算する(1 層用).
</p>
<pre>
 * 全波数 n, 帯状波数 m の流線関数のスペクトル成分ψ(n,m) から
   エネルギースペクトルは (1/2)n(n+1)ψ(n,m)^2 と計算される.

 * 全てのエネルギースペクトル成分の和に4πをかけたものが球面上での
   全エネルギーに等しい.

 * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
   欠損値の値はモジュール変数 w_spectrum_VMiss によって設定できる
   (初期値は -999.0)
</pre>
<p>
Original external subprogram is <a
href="w_spectrum_module.html#M000200">w_spectrum_module#nm_EnergyFromStreamfunc_w</a>
</p>


        </div>
      </div>


      <div id="method-M000643" class="method-detail">
        <a name="M000643"></a>

        <div class="method-heading">




          <span class="method-name">nm_EnstrophyFromStreamfunc_w</span><span class="method-args">( w_Strfunc ) result(nm_EnstrophyFromStreamfunc_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000643">nm_EnstrophyFromStreamfunc_w</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,-nm:nm)</tt>

<table>
<tr><td valign="top"> :</td><td> エンストロフィースペクトル (水平全波数 n, 帯状波数 m 空間)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_Strfunc(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 流線関数(スペクトルデータ)

</td></tr>
</table>
</td></tr>
</table>
<p>
流線関数のスペクトルデータからエンストロフィーの球面調和函数成分
(スペクトル)を計算する(1 層用).
</p>
<ul>
<li>全波数 n, 帯状波数 m の流線関数のスペクトル成分ψ(n,m) から

<pre>
 エンストロフィースペクトルは (1/2)n^2(n+1)^2ψ(n,m)^2 と計算される.
</pre>
</li>
<li>全てのエンストロフィースペクトル成分の和に4π/R^2をかけたものが
球面上での全エンストロフィーに等しい. ここで R は球面の半径である.

</li>
<li>データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
欠損値の値はモジュール変数 <a
href="w_module.html#M000640">w_spectrum_VMiss</a> によって設定できる
(初期値は -999.0)

</li>
</ul>
<p>
Original external subprogram is <a
href="w_spectrum_module.html#M000202">w_spectrum_module#nm_EnstrophyFromStreamfunc_w</a>
</p>


        </div>
      </div>


      <div id="method-M000612" class="method-detail">
        <a name="M000612"></a>

        <div class="method-heading">




          <span class="method-name">nm_l</span><span class="method-args">( l ) result(nm_l_int)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>nm_l_int(2)  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全波数, 帯状波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>l  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置(l)から全波数(n)と東西波数(m)を返す.
</p>
<p>
引数 l が整数値の場合, 対応する全波数と帯状波数を 長さ 2 の 1
次元整数値を返す. <a href="w_module.html#M000612">nm_l</a>(1) が全波数, <a
href="w_module.html#M000612">nm_l</a>(2) が帯状波数である.
</p>
<p>
Original external subprogram is <a
href="w_base_module.html#M001529">w_base_module#nm_l</a>
</p>


        </div>
      </div>


      <div id="method-M000613" class="method-detail">
        <a name="M000613"></a>

        <div class="method-heading">




          <span class="method-name">nm_l</span><span class="method-args">( larray ) result(nm_l_array)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>nm_l_array(size(larray),2)  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>larray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全波数, 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置(l)から全波数(n)と東西波数(m)を返す.
</p>
<p>
引数 larray が整数 1 次元配列の場合, larray に対応する n, m を格納した 2
次元整数配列を返す. nm_l_array(:,1) が全波数, nm_l_array(:,2)
が帯状波数である.
</p>
<p>
Original external subprogram is <a
href="w_base_module.html#M001529">w_base_module#nm_l</a>
</p>


        </div>
      </div>


      <div id="method-M000614" class="method-detail">
        <a name="M000614"></a>

        <div class="method-heading">




          <span class="method-name">rn</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000614">rn</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> ラプラシアン演算用配列

<p>
スペクトルデータのラプラシアンを計算するための係数
配列のサイズは((nm+1)*(nm+1), 2)
</p>
<p>
r(L,1) には L 番目の格納位置のスペクトルに対するラプラシアン計算の 係数
-n(n+1) の値が格納されている.
</p>
</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002134">w_deriv_module#rn</a>
</p>


        </div>
      </div>


      <div id="method-M000618" class="method-detail">
        <a name="M000618"></a>

        <div class="method-heading">




          <span class="method-name">w_DLon_w</span><span class="method-args">( w_data ) result(w_DLon_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000618">w_DLon_w</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの経度微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに経度微分 ∂/∂λ を作用させる(1 層用).
</p>
<p>
スペクトルデータの経度微分とは, 対応する格子点データに
経度微分∂/∂λを作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002139">w_deriv_module#w_DLon_w</a>
</p>


        </div>
      </div>


      <div id="method-M000627" class="method-detail">
        <a name="M000627"></a>

        <div class="method-heading">




          <span class="method-name">w_DivLambda_xy</span><span class="method-args">( xy_data ) result(w_DivLambda_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000627">w_DivLambda_xy</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型経度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型経度微分 1/(1-μ^2)・∂/∂λ (μ=sinφ)
を作用させてスペクトルデータに変換して返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002148">w_deriv_module#w_DivLambda_xy</a>
</p>


        </div>
      </div>


      <div id="method-M000622" class="method-detail">
        <a name="M000622"></a>

        <div class="method-heading">




          <span class="method-name">w_DivLat_xy</span><span class="method-args">( xy_data ) result(w_DivLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000622">w_DivLat_xy</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型緯度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型緯度微分 1/cosφ・∂(f cosφ)/∂φ を作用させて
スペクトルデータに変換して返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002143">w_deriv_module#w_DivLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M000621" class="method-detail">
        <a name="M000621"></a>

        <div class="method-heading">




          <span class="method-name">w_DivLon_xy</span><span class="method-args">( xy_data ) result(w_DivLon_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000621">w_DivLon_xy</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型経度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型経度微分 1/cosφ・∂/∂λ を作用させて
スペクトルデータに変換して返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002142">w_deriv_module#w_DivLon_xy</a>
</p>


        </div>
      </div>


      <div id="method-M000628" class="method-detail">
        <a name="M000628"></a>

        <div class="method-heading">




          <span class="method-name">w_DivMu_xy</span><span class="method-args">( xy_data ) result(w_DivMu_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000628">w_DivMu_xy</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データを発散型緯度微分したスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型緯度微分 ∂/∂μ (μ=sinφ)を作用させて
スペクトルデータに変換して返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002149">w_deriv_module#w_DivMu_xy</a>
</p>


        </div>
      </div>


      <div id="method-M000623" class="method-detail">
        <a name="M000623"></a>

        <div class="method-heading">




          <span class="method-name">w_Div_xy_xy</span><span class="method-args">( xy_u, xy_v ) result(w_Div_xy_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000623">w_Div_xy_xy</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 つの入力格子点データをベクトル成分とする発散のスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_u(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル経度成分の格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_v(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル緯度成分の格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 つの入力格子点データをベクトル成分とする発散を計算し,
スペクトルデータとして返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002144">w_deriv_module#w_Div_xy_xy</a>
</p>


        </div>
      </div>


      <div id="method-M000624" class="method-detail">
        <a name="M000624"></a>

        <div class="method-heading">




          <span class="method-name">w_Jacobian_w_w</span><span class="method-args">( w_a, w_b ) result(w_Jacobian_w_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000624">w_Jacobian_w_w</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 つのスペクトルデータのヤコビアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_a((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1つ目の入力スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_b((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2つ目の入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 つのスペクトルデータにヤコビアン
</p>
<pre>
  J(f,g) = ∂f/∂λ・∂g/∂μ - ∂g/∂λ・∂f/∂μ
         = ∂f/∂λ・1/cosφ・∂g/∂φ
            - ∂g/∂λ・1/cosφ・∂f/∂φ
</pre>
<p>
を作用させる(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002145">w_deriv_module#w_Jacobian_w_w</a>
</p>


        </div>
      </div>


      <div id="method-M000617" class="method-detail">
        <a name="M000617"></a>

        <div class="method-heading">




          <span class="method-name">w_LaplaInv_w</span><span class="method-args">( w_data ) result(w_LaplaInv_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000617">w_LaplaInv_w</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの逆ラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに逆ラプラシアン
</p>
<pre>
   ▽^{-2}
     =[1/cos^2φ・∂^2/∂λ^2 + 1/cosφ・∂/∂φ(cosφ∂/∂φ)]^{-1}
</pre>
<p>
を作用する(1 層用).
</p>
<p>
スペクトルデータの逆ラプラシアンとは, 対応する格子点データに
逆ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002138">w_deriv_module#w_LaplaInv_w</a>
</p>


        </div>
      </div>


      <div id="method-M000616" class="method-detail">
        <a name="M000616"></a>

        <div class="method-heading">




          <span class="method-name">w_Lapla_w</span><span class="method-args">( w_data ) result(w_Lapla_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000616">w_Lapla_w</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 入力スペクトルデータのラプラシアン

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータにラプラシアン
</p>
<pre>
   ▽^2 = 1/cos^2φ・∂^2/∂λ^2 + 1/cosφ・∂/∂φ(cosφ∂/∂φ)
</pre>
<p>
を作用する(1 層用).
</p>
<p>
スペクトルデータのラプラシアンとは, 対応する格子点データに
ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002137">w_deriv_module#w_Lapla_w</a>
</p>


        </div>
      </div>


      <div id="method-M000599" class="method-detail">
        <a name="M000599"></a>

        <div class="method-heading">


          <a href="#M000599" class="method-signature">



          <span class="method-name">w_initial</span><span class="method-args">( n_in, i_in, j_in, [np_in] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>n_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 切断波数の設定

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>i_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点数(東西)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>j_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点数(南北)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>np_in  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) OPENMP での最大スレッド数

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル変換の格子点数, 波数および OPENMP 使用時の
最大スレッド数を設定する.
</p>
<p>
他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで初期設定を
しなければならない.
</p>
<p>
np_in に 1 より大きな値を指定すれば ISPACK の球面調和函数変換 OPENMP
並列計算ルーチンが用いられる. 並列計算を実行するには, 実行時に環境変数
OMP_NUM_THREADS を np_in 以下の数字に設定する等の
システムに応じた準備が必要となる.
</p>
<p>
np_in に 1 より大きな値を指定しなければ並列計算ルーチンは呼ばれない.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000599-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000599-source">
<pre>
    subroutine w_initial(n_in,i_in,j_in,np_in)
      !
      ! スペクトル変換の格子点数, 波数および OPENMP 使用時の
      ! 最大スレッド数を設定する.
      !
      ! 他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで初期設定を
      ! しなければならない. 
      !
      ! np_in に 1 より大きな値を指定すれば ISPACK の球面調和函数変換 
      ! OPENMP 並列計算ルーチンが用いられる. 並列計算を実行するには, 
      ! 実行時に環境変数 OMP_NUM_THREADS を np_in 以下の数字に設定する等の
      ! システムに応じた準備が必要となる. 
      !
      ! np_in に 1 より大きな値を指定しなければ並列計算ルーチンは呼ばれない.
      !
      integer,intent(in) :: i_in              !(in) 格子点数(東西)
      integer,intent(in) :: j_in              !(in) 格子点数(南北)
      integer,intent(in) :: n_in              !(in) 切断波数の設定
      integer,intent(in), optional :: np_in   !(in) OPENMP での最大スレッド数

      integer iw

      if ( present (np_in) )then
         call w_base_initial(n_in,i_in,j_in,np_in)
      else
         call w_base_initial(n_in,i_in,j_in)
      endif

      call w_deriv_initial

    end subroutine w_initial
</pre>
          </div>

        </div>
      </div>


      <div id="method-M000640" class="method-detail">
        <a name="M000640"></a>

        <div class="method-heading">




          <span class="method-name">w_spectrum_VMiss</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000640">w_spectrum_VMiss</a>  </tt></b>  <tt> = -999.000    </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 欠損値初期値

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_spectrum_module.html#M000199">w_spectrum_module#w_spectrum_VMiss</a>
</p>


        </div>
      </div>


      <div id="method-M000607" class="method-detail">
        <a name="M000607"></a>

        <div class="method-heading">




          <span class="method-name">w_xy</span><span class="method-args">( xy_data, [ipow], [iflag] ) result(w_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000607">w_xy</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ipow  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 変換時に同時に作用させる 1/cosφ の次数. 省略時は 0.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>iflag  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> 変換の種類

<pre>
   0 : 通常の正変換
  -1 : 経度微分を作用させた正変換
   1 : 緯度微分 1/cosφ・∂(f cos^2φ)/∂φ を作用させた正変換
   2 : sinφを作用させた正変換
 省略時は 0.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからスペクトルデータへ(正)変換する(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_base_module.html#M001524">w_base_module#w_xy</a>
</p>


        </div>
      </div>


      <div id="method-M000638" class="method-detail">
        <a name="M000638"></a>

        <div class="method-heading">




          <span class="method-name">x_AvrLat_xy</span><span class="method-args">( xy_data ) result(x_AvrLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000638">x_AvrLat_xy</a>(im)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの緯度(Y)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, y_Y_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="w_integral_module.html#M000256">w_integral_module#x_AvrLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M000633" class="method-detail">
        <a name="M000633"></a>

        <div class="method-heading">




          <span class="method-name">x_IntLat_xy</span><span class="method-args">( xy_data ) result(x_IntLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000633">x_IntLat_xy</a>(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの緯度(Y)方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="w_integral_module.html#M000251">w_integral_module#x_IntLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M000600" class="method-detail">
        <a name="M000600"></a>

        <div class="method-heading">




          <span class="method-name">x_Lon</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000600">x_Lon</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 緯度経度

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_base_module.html#M001516">w_base_module#x_Lon</a>
</p>


        </div>
      </div>


      <div id="method-M000602" class="method-detail">
        <a name="M000602"></a>

        <div class="method-heading">




          <span class="method-name">x_Lon_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000602">x_Lon_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標重み

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_base_module.html#M001518">w_base_module#x_Lon_Weight</a>
</p>


        </div>
      </div>


      <div id="method-M000625" class="method-detail">
        <a name="M000625"></a>

        <div class="method-heading">




          <span class="method-name">xy_GradLambda_w</span><span class="method-args">( w_data ) result(xy_GradLambda_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000625">xy_GradLambda_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型経度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 ∂/∂λ を作用する(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002146">w_deriv_module#xy_GradLambda_w</a>
</p>


        </div>
      </div>


      <div id="method-M000620" class="method-detail">
        <a name="M000620"></a>

        <div class="method-heading">




          <span class="method-name">xy_GradLat_w</span><span class="method-args">( w_data ) result(xy_GradLat_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000620">xy_GradLat_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型緯度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型緯度微分 ∂/∂φ を作用させて
格子点データに変換して返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002141">w_deriv_module#xy_GradLat_w</a>
</p>


        </div>
      </div>


      <div id="method-M000619" class="method-detail">
        <a name="M000619"></a>

        <div class="method-heading">




          <span class="method-name">xy_GradLon_w</span><span class="method-args">( w_data ) result(xy_GradLon_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000619">xy_GradLon_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型経度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 1/cosφ・∂/∂λ を
作用させた格子点データを返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002140">w_deriv_module#xy_GradLon_w</a>
</p>


        </div>
      </div>


      <div id="method-M000626" class="method-detail">
        <a name="M000626"></a>

        <div class="method-heading">




          <span class="method-name">xy_GradMu_w</span><span class="method-args">( w_data ) result(xy_GradMu_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000626">xy_GradMu_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータを勾配型緯度微分した格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力スペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型緯度微分 (1-μ^2)∂/∂μ (μ=sinφ)
を作用させて格子点データに変換して返す(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_deriv_module.html#M002147">w_deriv_module#xy_GradMu_w</a>
</p>


        </div>
      </div>


      <div id="method-M000605" class="method-detail">
        <a name="M000605"></a>

        <div class="method-heading">




          <span class="method-name">xy_Lat</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000605">xy_Lat</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_base_module.html#M001521">w_base_module#xy_Lat</a>
</p>


        </div>
      </div>


      <div id="method-M000604" class="method-detail">
        <a name="M000604"></a>

        <div class="method-heading">




          <span class="method-name">xy_Lon</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000604">xy_Lon</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_base_module.html#M001520">w_base_module#xy_Lon</a>
</p>


        </div>
      </div>


      <div id="method-M000606" class="method-detail">
        <a name="M000606"></a>

        <div class="method-heading">




          <span class="method-name">xy_w</span><span class="method-args">( w_data, [ipow], [iflag] ) result(xy_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000606">xy_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ipow  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 作用させる 1/cosφ の次数. 省略時は 0.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>iflag  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 変換の種類

<pre>
   0 : 通常の正変換
  -1 : 経度微分を作用させた逆変換
   1 : 緯度微分 cosφ・∂/∂φ を作用させた逆変換
   2 : sinφを作用させた逆変換
   省略時は 0.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子データへ変換する(1 層用).
</p>
<p>
Original external subprogram is <a
href="w_base_module.html#M001523">w_base_module#xy_w</a>
</p>


        </div>
      </div>


      <div id="method-M000636" class="method-detail">
        <a name="M000636"></a>

        <div class="method-heading">




          <span class="method-name">y_AvrLon_xy</span><span class="method-args">( xy_data ) result(y_AvrLon_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000636">y_AvrLon_xy</a>(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元緯度(Y)格子点

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの経度(X)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, x_X_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="w_integral_module.html#M000257">w_integral_module#y_AvrLon_xy</a>
</p>


        </div>
      </div>


      <div id="method-M000631" class="method-detail">
        <a name="M000631"></a>

        <div class="method-heading">




          <span class="method-name">y_IntLon_xy</span><span class="method-args">( xy_data ) result(y_IntLon_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000631">y_IntLon_xy</a>(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元緯度(Y)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの経度(X)方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="w_integral_module.html#M000252">w_integral_module#y_IntLon_xy</a>
</p>


        </div>
      </div>


      <div id="method-M000601" class="method-detail">
        <a name="M000601"></a>

        <div class="method-heading">




          <span class="method-name">y_Lat</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000601">y_Lat</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 緯度経度

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_base_module.html#M001517">w_base_module#y_Lat</a>
</p>


        </div>
      </div>


      <div id="method-M000603" class="method-detail">
        <a name="M000603"></a>

        <div class="method-heading">




          <span class="method-name">y_Lat_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="w_module.html#M000603">y_Lat_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標重み

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="w_base_module.html#M001519">w_base_module#y_Lat_Weight</a>
</p>


        </div>
      </div>



    </div>



  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
