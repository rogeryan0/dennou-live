<?xml version="1.0" encoding="euc-jp"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: wt_module</title>
  <meta http-equiv="Content-Type" content="text/html; charset=euc-jp" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">wt_module</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../files/src/wt_module_f90.html">

                src/wt_module.f90

                </a>


        <br />
            </td>
        </tr>


        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">


  <div id="contextContent">



    <div id="description">
      <h1><a href="wt_module.html">wt_module</a></h1>
<table>
<tr><td valign="top">Authors:</td><td>Shin-ichi Takehiro, Youhei SASAKI

</td></tr>
<tr><td valign="top">Version:</td><td>$Id: <a href="../files/src/wt_module_f90.html">wt_module.f90</a>,v 1.41
2009-02-28 21:33:48 uwabami Exp $

</td></tr>
<tr><td valign="top">Copyright&amp;License:</td><td>See <a href="../../COPYRIGHT">COPYRIGHT</a>

</td></tr>
</table>
<h2>概要</h2>
<p>
spml/wt_module モジュールは球面上および球殻内での流体運動を
スペクトル法によって数値計算するための Fortran90 関数を提供する ものである.
</p>
<p>
水平方向に球面調和函数変換および上下の境界壁を扱うための
チェビシェフ変換を用いる場合のスペクトル計算のためのさまざまな
関数を提供する.
</p>
<p>
内部で <a href="wa_module.html">wa_module</a>, <a
href="at_module.html">at_module</a> を用いている. 最下部では球面調和変換
およびチェビシェフ変換のエンジンとして ISPACK の Fortran77
サブルーチンを用いている.
</p>
<h2>関数・変数の名前と型について</h2>
<h3>命名法</h3>
<ul>
<li>関数名の先頭 (wt_, nmz_, nz_, xyz_, wz_, w_, xy_, x_, y_, z_, a_) は,
返す値の形を示している.

<table>
<tr><td valign="top">wt_  :</td><td>スペクトルデータ(球面調和函数・チェビシェフ変換)

</td></tr>
<tr><td valign="top">nmz_ :</td><td>水平スペクトルデータ(全波数 n, 帯状波数各成分, 動径)

</td></tr>
<tr><td valign="top">nz_  :</td><td>水平スペクトルデータ(全波数 n, 動径)

</td></tr>
<tr><td valign="top">xyz_ :</td><td>3 次元格子点データ(経度・緯度・動径)

</td></tr>
<tr><td valign="top">wz_  :</td><td>水平スペクトル, 動径格子点データ

</td></tr>
</table>
</li>
<li>関数名の間の文字列(DLon, GradLat, GradLat, DivLon, DivLat, Lapla,..) は,
その関数の作用を表している.

</li>
<li>関数名の最後 (wt_, xyz_, wz_, w_, xy_, x_, y_, z_, a_) は, 入力変数の
形がスペクトルデータおよび格子点データであることを示している.

<table>
<tr><td valign="top">_wt      :</td><td>スペクトルデータ

</td></tr>
<tr><td valign="top">_xyz     :</td><td>3 次元格子点データ

</td></tr>
<tr><td valign="top">_xyz_xyz :</td><td>2 つの3 次元格子点データ, &#8230;

</td></tr>
</table>
</li>
</ul>
<h3>各データの種類の説明</h3>
<ul>
<li>xyz : 3 次元格子点データ(経度・緯度・動径)

<ul>
<li>変数の種類と次元は real(8), dimension(0:im-1,1:jm,0:km).

</li>
<li>im, jm, km はそれぞれ経度, 緯度, 動径座標の格子点数であり, サブルーチン <a
href="wt_module.html#M001396">wt_Initial</a> にてあらかじめ設定しておく.

</li>
</ul>
</li>
<li>wt : スペクトルデータ

<ul>
<li>変数の種類と次元は real(8), dimension((nm+1)*(nm+1),0:lm).

</li>
<li>nm は球面調和函数の最大全波数, lm はチェビシェフ多項式の最大次数 であり,
サブルーチン <a href="wt_module.html#M001396">wt_Initial</a>
にてあらかじめ設定しておく.

</li>
<li>水平スペクトルデータの格納のされ方は関数 <a
href="wt_module.html#M001479">l_nm</a>, <a
href="wt_module.html#M001483">nm_l</a> によって調べる ことができる.

</li>
</ul>
</li>
<li>nmz : 水平スペクトルデータの並んだ 3 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(0:nm,-nm:nm,0:km).

</li>
<li>第 1 次元が水平全波数, 第 2 次元が帯状波数, 第 3 次元が動径座標を表す.

</li>
<li>nm は球面調和函数の最大全波数であり, サブルーチン <a
href="wt_module.html#M001396">wt_Initial</a> にて あらかじめ設定しておく.

</li>
</ul>
</li>
<li>nz : スペクトルデータの並んだ 2 次元配列.

<ul>
<li>変数の種類と次元は real(8), dimension(0:nm,0:km).

</li>
<li>第 1 次元が水平全波数を表す. nm は球面調和函数の最大全波数であり,
サブルーチン <a href="wt_module.html#M001396">wt_Initial</a>
にてあらかじめ設定しておく.

</li>
</ul>
</li>
<li>wz : 水平スペクトル, 動径格子点データ.

<ul>
<li>変数の種類と次元は real(8), dimension((nm+1)*(nm+1),0:km).

</li>
</ul>
</li>
<li>wt_ で始まる関数が返す値はスペクトルデータに同じ.

</li>
<li>xyz_ で始まる関数が返す値は 3 次元格子点データに同じ.

</li>
<li>wz_ で始まる関数が返す値は水平スペクトル, 動径格子点データに同じ.

</li>
<li>スペクトルデータに対する微分等の作用とは, 対応する格子点データに
微分などを作用させたデータをスペクトル変換したものことである.

</li>
</ul>
<h2>変数・手続き群の要約</h2>
<h4>初期化</h4>
<table>
<tr><td valign="top"><a href="wt_module.html#M001396">wt_Initial</a> :</td><td>スペクトル変換の格子点数, 波数, 領域の大きさの設定

</td></tr>
</table>
<h4>座標変数</h4>
<table>
<tr><td valign="top"><a href="wt_module.html#M001473">x_Lon</a>, <a href="wt_module.html#M001475">y_Lat</a>, <a href="wt_module.html#M001477">z_Rad</a>          :</td><td>格子点座標(緯度, 経度, 動径座標)を 格納した1 次元配列

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001474">x_Lon_Weight</a>, <a href="wt_module.html#M001476">y_Lat_Weight</a>, <a href="wt_module.html#M001478">z_Rad_Weight</a> :</td><td>重み座標を格納した 1 次元配列

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001391">xyz_Lon</a>, <a href="wt_module.html#M001392">xyz_Lat</a>, <a href="wt_module.html#M001393">xyz_Rad</a>    :</td><td>格子点データの経度・緯度・動径座標(X,Y,Z) (格子点データ型 3 次元配列)

</td></tr>
</table>
<h4>基本変換</h4>
<table>
<tr><td valign="top"><a href="wt_module.html#M001397">xyz_wt</a>, <a href="wt_module.html#M001398">wt_xyz</a> :</td><td>スペクトルデータと 3 次元格子データの間の変換 (球面調和函数,
チェビシェフ変換)

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001399">xyz_wz</a>, <a href="wt_module.html#M001400">wz_xyz</a> :</td><td>3 次元格子データと水平スペクトル・動径格子データとの間 の変換
(球面調和函数)

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001401">wz_wt</a>, <a href="wt_module.html#M001402">wt_wz</a>   :</td><td>スペクトルデータと水平スペクトル・動径格子データとの間 の変換
(チェビシェフ変換)

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001487">w_xy</a>, <a href="wt_module.html#M001488">xy_w</a>     :</td><td>スペクトルデータと 2 次元水平格子データの間の変換 (球面調和函数変換)

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001491">az_at</a>, <a href="wt_module.html#M001492">at_az</a>   :</td><td>同時に複数個行う (チェビシェフ変換)格子データと
チェビシェフデータの間の変換を

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001479">l_nm</a>, <a href="wt_module.html#M001483">nm_l</a>     :</td><td>スペクトルデータの格納位置と全波数・帯状波数の変換

</td></tr>
</table>
<h4>微分</h4>
<table>
<tr><td valign="top"><a href="wt_module.html#M001403">wt_DRad_wt</a>          :</td><td>スペクトルデータに動径微分∂/∂r を作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001404">wt_DivRad_wt</a>        :</td><td>スペクトルデータに発散型動径微分 1/r^2 ∂/∂r r^2 = ∂/∂r + 2/r
を作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001405">wt_RotRad_wt</a>        :</td><td>スペクトルデータに回転型動径微分 1/r ∂/∂rr = ∂/∂r + 1/r を作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001406">wt_Lapla_wt</a>         :</td><td>スペクトルデータにラプラシアンを作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001407">xyz_GradLon_wt</a>      :</td><td>スペクトルデータに勾配型経度微分 1/rcosφ・∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001408">xyz_GradLat_wt</a>      :</td><td>スペクトルデータに勾配型緯度微分 1/r・∂/∂φを作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001409">wt_DivLon_xyz</a>       :</td><td>格子データに発散型経度微分 1/rcosφ・∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001410">wt_DivLat_xyz</a>       :</td><td>格子データに発散型緯度微分 1/rcosφ・∂(g cosφ)/∂φを作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001411">wt_Div_xyz_xyz_xyz</a>  :</td><td>ベクトル成分である 3 つの格子データに 発散を作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001412">xyz_Div_xyz_xyz_xyz</a> :</td><td>ベクトル成分である 3 つの格子データに 発散を作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001413">xyz_RotLon_wt_wt</a>    :</td><td>ベクトル場の回転の経度成分を計算する

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001414">xyz_RotLat_wt_wt</a>    :</td><td>ベクトル場の回転の緯度成分を計算する

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001415">wt_RotRad_xyz_xyz</a>   :</td><td>ベクトル場の回転の動径成分を計算する

</td></tr>
</table>
<h4>トロイダルポロイダル計算用微分</h4>
<table>
<tr><td valign="top"><a href="wt_module.html#M001444">wt_KxRGrad_wt</a>            :</td><td>スペクトルデータに 経度微分 k×r・▽ = ∂/∂λを作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001445">xyz_KGrad_wt</a>             :</td><td>スペクトルデータに軸方向微分 k・▽ = cosφ/r ∂/∂φ + sinφ∂/∂r を
作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001446">wt_L2_wt</a>                 :</td><td>スペクトルデータに L2 演算子 = -水平ラプラシアンを作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001447">wt_L2Inv_wt</a>              :</td><td>スペクトルデータに L2 演算子の逆 = -逆水平ラプラシアンを作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001448">wt_QOperator_wt</a>          :</td><td>スペクトルデータに 演算子 Q=(k・▽-1/2(L2 k・▽+ k・▽L2)) を 作用させる

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001449">wt_RadRot_xyz_xyz</a>        :</td><td>ベクトル v の渦度と動径ベクトル r の内積 r・(▽×v) を計算する

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001450">wt_RadRotRot_xyz_xyz_xyz</a> :</td><td>ベクトルの v の r・(▽×▽×v) を計算する

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001451">wt_Potential2Vector</a>      :</td><td>トロイダルポロイダルポテンシャルから ベクトル場を計算する

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001452">wt_Potential2Rotation</a>    :</td><td>トロイダルポロイダルポテンシャルで表される
非発散ベクトル場の回転の各成分を計算する

</td></tr>
</table>
<h4>非線形計算</h4>
<table>
<tr><td valign="top"><a href="wt_module.html#M001453">wt_VGradV</a>    :</td><td>ベクトル v から v・▽v を計算する

</td></tr>
</table>
<h4>ポロイダル/トロイダルモデル用スペクトル解析</h4>
<table>
<tr><td valign="top"><a href="wt_module.html#M001455">nmz_ToroidalEnergySpectrum_wt</a>, <a href="wt_module.html#M001456">nz_ToroidalEnergySpectrum_wt</a>   :</td><td>トロイダルポテンシャルからエネルギーの球面調和函数各成分を計算する

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001457">nmz_PoloidalEnergySpectrum_wt</a>, <a href="wt_module.html#M001458">nz_PoloidalEnergySpectrum_wt</a>   :</td><td>ポロイダルポテンシャルからエネルギーの球面調和函数各成分を計算する

</td></tr>
</table>
<h4>境界値問題</h4>
<table>
<tr><td valign="top"><a href="wt_module.html#M001459">wt_BoundariesTau</a>, <a href="wt_module.html#M001460">wt_BoundariesGrid</a>, <a href="wt_module.html#M001469">wt_Boundaries</a>                   :</td><td>ディリクレ, ノイマン境界条件を適用する(タウ法, 選点法)

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001461">wt_TorBoundariesTau</a>, <a href="wt_module.html#M001462">wt_TorBoundariesGrid</a>, <a href="wt_module.html#M001470">wt_TorBoundaries</a>          :</td><td>速度トロイダルポテンシャルの境界条件を適用する(タウ法,選点法)

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001463">wz_LaplaPol2Pol_wz</a>, wt_LaplaPol2Pol_wt                               :</td><td>速度ポロイダルポテンシャルΦを▽^2Φから求める
(入出力がそれぞれチェビシェフ格子点,チェビシェフ係数)

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001465">wt_TorMagBoundariesTau</a>, <a href="wt_module.html#M001466">wt_TorMagBoundariesGrid</a>, <a href="wt_module.html#M001471">wt_TorMagBoundaries</a> :</td><td>磁場トロイダルポテンシャルの境界条件を適用する(タウ法, 選点法)

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001467">wt_PolMagBoundariesTau</a>, <a href="wt_module.html#M001468">wt_PolMagBoundariesGrid</a>, <a href="wt_module.html#M001472">wt_PolMagBoundaries</a> :</td><td>磁場トロイダルポテンシャル境界の境界条件を適用する(タウ法, 選点法)

</td></tr>
</table>
<h4>積分・平均(3 次元データ)</h4>
<table>
<tr><td valign="top"><a href="wt_module.html#M001422">IntLonLatRad_xyz</a>, <a href="wt_module.html#M001436">AvrLonLatRad_xyz</a> :</td><td>3 次元格子点データの 全領域積分および平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001421">z_IntLonLat_xyz</a>, <a href="wt_module.html#M001435">z_AvrLonLat_xyz</a>   :</td><td>3 次元格子点データの 緯度経度(水平・球面)積分および平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001420">y_IntLonRad_xyz</a>, <a href="wt_module.html#M001434">y_AvrLonRad_xyz</a>   :</td><td>3 次元格子点データの 緯度動径積分および平均

</td></tr>
<tr><td valign="top">z_IntLatRad_xyz, z_AvrLatRad_xyz   :</td><td>3 次元格子点データの 経度動径(子午面)積分および平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001416">yz_IntLon_xyz</a>, <a href="wt_module.html#M001430">yz_AvrLon_xyz</a>       :</td><td>3 次元格子点データの 経度方向積分および平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001417">xz_IntLat_xyz</a>, <a href="wt_module.html#M001431">xz_AvrLat_xyz</a>       :</td><td>3 次元格子点データの 緯度方向積分および平均

</td></tr>
<tr><td valign="top">xz_IntRad_xyz, xz_AvrRad_xyz       :</td><td>3 次元格子点データの 動径方向積分および平均

</td></tr>
</table>
<h4>積分・平均(2 次元データ)</h4>
<table>
<tr><td valign="top"><a href="wt_module.html#M001495">IntLonLat_xy</a>, <a href="wt_module.html#M001500">AvrLonLat_xy</a> :</td><td>2 次元格子点データの水平(球面)積分および平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001428">IntLonRad_xz</a>, <a href="wt_module.html#M001442">AvrLonRad_xz</a> :</td><td>2 次元(XZ)格子点データの経度動径積分 および平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001425">IntLatRad_yz</a>, <a href="wt_module.html#M001439">AvrLatRad_yz</a> :</td><td>2 次元(YZ)格子点データの緯度動径(子午面) 積分および平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001494">y_IntLon_xy</a>, <a href="wt_module.html#M001499">y_AvrLon_xy</a>   :</td><td>水平 2 次元(球面)格子点データの経度方向 積分および平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001493">x_IntLat_xy</a>, <a href="wt_module.html#M001498">x_AvrLat_xy</a>   :</td><td>水平2 次元(球面)格子点データの緯度方向積分 および平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001426">z_IntLon_xz</a>, <a href="wt_module.html#M001440">z_AvrLon_xz</a>   :</td><td>2 次元(XZ)格子点データの経度方向積分および 平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001427">x_IntRad_xz</a>, <a href="wt_module.html#M001441">x_AvrRad_xz</a>   :</td><td>2 次元(XZ)格子点データの動径方向積分および 平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001423">z_IntLat_yz</a>, <a href="wt_module.html#M001437">z_AvrLat_yz</a>   :</td><td>2 次元(YZ)格子点データの緯度方向積分および 平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001424">y_IntRad_yz</a>, <a href="wt_module.html#M001438">y_AvrRad_yz</a>   :</td><td>2 次元(YZ)格子点データの動径方向積分および 平均

</td></tr>
</table>
<h4>積分・平均(1 次元データ)</h4>
<table>
<tr><td valign="top"><a href="wt_module.html#M001496">IntLon_x</a>, <a href="wt_module.html#M001501">AvrLon_x</a>  :</td><td>1 次元(X)格子点データの経度方向積分および平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001497">IntLat_y</a>, <a href="wt_module.html#M001502">AvrLat_y</a>  :</td><td>1 次元(Y)格子点データの緯度方向積分および平均

</td></tr>
<tr><td valign="top"><a href="wt_module.html#M001429">IntRad_z</a>, <a href="wt_module.html#M001443">AvrRad_z</a>  :</td><td>1 次元(Z)格子点データの動径方向積分および平均

</td></tr>
</table>
<h4>補間計算</h4>
<table>
<tr><td valign="top"><a href="wt_module.html#M001454">Interpolate_wt</a> :</td><td>スペクトルデータから任意の点の値を補間する.

</td></tr>
</table>

    </div>





   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M001439">AvrLatRad_yz</a>&nbsp;&nbsp;

        <a href="#M001502">AvrLat_y</a>&nbsp;&nbsp;

        <a href="#M001436">AvrLonLatRad_xyz</a>&nbsp;&nbsp;

        <a href="#M001500">AvrLonLat_xy</a>&nbsp;&nbsp;

        <a href="#M001442">AvrLonRad_xz</a>&nbsp;&nbsp;

        <a href="#M001501">AvrLon_x</a>&nbsp;&nbsp;

        <a href="#M001443">AvrRad_z</a>&nbsp;&nbsp;

        <a href="#M001425">IntLatRad_yz</a>&nbsp;&nbsp;

        <a href="#M001497">IntLat_y</a>&nbsp;&nbsp;

        <a href="#M001422">IntLonLatRad_xyz</a>&nbsp;&nbsp;

        <a href="#M001495">IntLonLat_xy</a>&nbsp;&nbsp;

        <a href="#M001428">IntLonRad_xz</a>&nbsp;&nbsp;

        <a href="#M001496">IntLon_x</a>&nbsp;&nbsp;

        <a href="#M001429">IntRad_z</a>&nbsp;&nbsp;

        <a href="#M001454">Interpolate_wt</a>&nbsp;&nbsp;

        <a href="#M001489">at_Dr_at</a>&nbsp;&nbsp;

        <a href="#M001492">at_az</a>&nbsp;&nbsp;

        <a href="#M001491">az_at</a>&nbsp;&nbsp;

        <a href="#M001479">l_nm</a>&nbsp;&nbsp;

        <a href="#M001480">l_nm</a>&nbsp;&nbsp;

        <a href="#M001481">l_nm</a>&nbsp;&nbsp;

        <a href="#M001482">l_nm</a>&nbsp;&nbsp;

        <a href="#M001483">nm_l</a>&nbsp;&nbsp;

        <a href="#M001484">nm_l</a>&nbsp;&nbsp;

        <a href="#M001457">nmz_PoloidalEnergySpectrum_wt</a>&nbsp;&nbsp;

        <a href="#M001455">nmz_ToroidalEnergySpectrum_wt</a>&nbsp;&nbsp;

        <a href="#M001458">nz_PoloidalEnergySpectrum_wt</a>&nbsp;&nbsp;

        <a href="#M001456">nz_ToroidalEnergySpectrum_wt</a>&nbsp;&nbsp;

        <a href="#M001490">t_Dr_t</a>&nbsp;&nbsp;

        <a href="#M001487">w_xy</a>&nbsp;&nbsp;

        <a href="#M001469">wt_Boundaries</a>&nbsp;&nbsp;

        <a href="#M001460">wt_BoundariesGrid</a>&nbsp;&nbsp;

        <a href="#M001459">wt_BoundariesTau</a>&nbsp;&nbsp;

        <a href="#M001403">wt_DRad_wt</a>&nbsp;&nbsp;

        <a href="#M001410">wt_DivLat_xyz</a>&nbsp;&nbsp;

        <a href="#M001409">wt_DivLon_xyz</a>&nbsp;&nbsp;

        <a href="#M001404">wt_DivRad_wt</a>&nbsp;&nbsp;

        <a href="#M001411">wt_Div_xyz_xyz_xyz</a>&nbsp;&nbsp;

        <a href="#M001396">wt_Initial</a>&nbsp;&nbsp;

        <a href="#M001444">wt_KxRGrad_wt</a>&nbsp;&nbsp;

        <a href="#M001447">wt_L2Inv_wt</a>&nbsp;&nbsp;

        <a href="#M001446">wt_L2_wt</a>&nbsp;&nbsp;

        <a href="#M001464">wt_LaplaPol2PolGrid_wt</a>&nbsp;&nbsp;

        <a href="#M001406">wt_Lapla_wt</a>&nbsp;&nbsp;

        <a href="#M001472">wt_PolMagBoundaries</a>&nbsp;&nbsp;

        <a href="#M001468">wt_PolmagBoundariesGrid</a>&nbsp;&nbsp;

        <a href="#M001467">wt_PolmagBoundariesTau</a>&nbsp;&nbsp;

        <a href="#M001452">wt_Potential2Rotation</a>&nbsp;&nbsp;

        <a href="#M001451">wt_Potential2Vector</a>&nbsp;&nbsp;

        <a href="#M001448">wt_QOperator_wt</a>&nbsp;&nbsp;

        <a href="#M001450">wt_RadRotRot_xyz_xyz_xyz</a>&nbsp;&nbsp;

        <a href="#M001449">wt_RadRot_xyz_xyz</a>&nbsp;&nbsp;

        <a href="#M001405">wt_RotRad_wt</a>&nbsp;&nbsp;

        <a href="#M001415">wt_RotRad_xyz_xyz</a>&nbsp;&nbsp;

        <a href="#M001470">wt_TorBoundaries</a>&nbsp;&nbsp;

        <a href="#M001462">wt_TorBoundariesGrid</a>&nbsp;&nbsp;

        <a href="#M001461">wt_TorBoundariesTau</a>&nbsp;&nbsp;

        <a href="#M001471">wt_TorMagBoundaries</a>&nbsp;&nbsp;

        <a href="#M001466">wt_TormagBoundariesGrid</a>&nbsp;&nbsp;

        <a href="#M001465">wt_TormagBoundariesTau</a>&nbsp;&nbsp;

        <a href="#M001453">wt_VGradV</a>&nbsp;&nbsp;

        <a href="#M001395">wt_VMiss</a>&nbsp;&nbsp;

        <a href="#M001402">wt_wz</a>&nbsp;&nbsp;

        <a href="#M001398">wt_xyz</a>&nbsp;&nbsp;

        <a href="#M001463">wz_LaplaPol2Pol_wz</a>&nbsp;&nbsp;

        <a href="#M001394">wz_RAD</a>&nbsp;&nbsp;

        <a href="#M001401">wz_wt</a>&nbsp;&nbsp;

        <a href="#M001400">wz_xyz</a>&nbsp;&nbsp;

        <a href="#M001433">x_AvrLatRad_xyz</a>&nbsp;&nbsp;

        <a href="#M001498">x_AvrLat_xy</a>&nbsp;&nbsp;

        <a href="#M001441">x_AvrRad_xz</a>&nbsp;&nbsp;

        <a href="#M001419">x_IntLatRad_xyz</a>&nbsp;&nbsp;

        <a href="#M001493">x_IntLat_xy</a>&nbsp;&nbsp;

        <a href="#M001427">x_IntRad_xz</a>&nbsp;&nbsp;

        <a href="#M001473">x_Lon</a>&nbsp;&nbsp;

        <a href="#M001474">x_Lon_Weight</a>&nbsp;&nbsp;

        <a href="#M001432">xy_AvrRad_xyz</a>&nbsp;&nbsp;

        <a href="#M001418">xy_IntRad_xyz</a>&nbsp;&nbsp;

        <a href="#M001486">xy_Lat</a>&nbsp;&nbsp;

        <a href="#M001485">xy_Lon</a>&nbsp;&nbsp;

        <a href="#M001488">xy_w</a>&nbsp;&nbsp;

        <a href="#M001412">xyz_Div_xyz_xyz_xyz</a>&nbsp;&nbsp;

        <a href="#M001408">xyz_GradLat_wt</a>&nbsp;&nbsp;

        <a href="#M001407">xyz_GradLon_wt</a>&nbsp;&nbsp;

        <a href="#M001445">xyz_KGrad_wt</a>&nbsp;&nbsp;

        <a href="#M001392">xyz_LAT</a>&nbsp;&nbsp;

        <a href="#M001391">xyz_LON</a>&nbsp;&nbsp;

        <a href="#M001393">xyz_RAD</a>&nbsp;&nbsp;

        <a href="#M001414">xyz_RotLat_wt_wt</a>&nbsp;&nbsp;

        <a href="#M001413">xyz_RotLon_wt_wt</a>&nbsp;&nbsp;

        <a href="#M001397">xyz_wt</a>&nbsp;&nbsp;

        <a href="#M001399">xyz_wz</a>&nbsp;&nbsp;

        <a href="#M001431">xz_AvrLat_xyz</a>&nbsp;&nbsp;

        <a href="#M001417">xz_IntLat_xyz</a>&nbsp;&nbsp;

        <a href="#M001434">y_AvrLonRad_xyz</a>&nbsp;&nbsp;

        <a href="#M001499">y_AvrLon_xy</a>&nbsp;&nbsp;

        <a href="#M001438">y_AvrRad_yz</a>&nbsp;&nbsp;

        <a href="#M001420">y_IntLonRad_xyz</a>&nbsp;&nbsp;

        <a href="#M001494">y_IntLon_xy</a>&nbsp;&nbsp;

        <a href="#M001424">y_IntRad_yz</a>&nbsp;&nbsp;

        <a href="#M001475">y_Lat</a>&nbsp;&nbsp;

        <a href="#M001476">y_Lat_Weight</a>&nbsp;&nbsp;

        <a href="#M001430">yz_AvrLon_xyz</a>&nbsp;&nbsp;

        <a href="#M001416">yz_IntLon_xyz</a>&nbsp;&nbsp;

        <a href="#M001437">z_AvrLat_yz</a>&nbsp;&nbsp;

        <a href="#M001435">z_AvrLonLat_xyz</a>&nbsp;&nbsp;

        <a href="#M001440">z_AvrLon_xz</a>&nbsp;&nbsp;

        <a href="#M001423">z_IntLat_yz</a>&nbsp;&nbsp;

        <a href="#M001421">z_IntLonLat_xyz</a>&nbsp;&nbsp;

        <a href="#M001426">z_IntLon_xz</a>&nbsp;&nbsp;

        <a href="#M001477">z_RAD</a>&nbsp;&nbsp;

        <a href="#M001478">z_RAD_WEIGHT</a>&nbsp;&nbsp;
      </div>
    </div>


  </div>


    <!-- if includes -->

    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">

        <span class="include-name">dc_message</span>

        <span class="include-name"><a href="lumatrix.html">lumatrix</a></span>

        <span class="include-name"><a href="wa_module.html">wa_module</a></span>

        <span class="include-name"><a href="at_module.html">at_module</a></span>
      </div>
    </div>



    <div id="section">










      


    <!-- if method_list -->

    <div id="methods">


      <h3 class="section-bar">Public Instance methods</h3>


      <div id="method-M001439" class="method-detail">
        <a name="M001439"></a>

        <div class="method-heading">


          <a href="#M001439" class="method-signature">



          <span class="method-name">AvrLatRad_yz</span><span class="method-args">( yz ) result(AvrLatRad_yz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001439">AvrLatRad_yz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径(子午面)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度動径(子午面)積分
</p>
<p>
2 次元(YZ)格子点データの緯度動径(子午面)平均
</p>
<p>
2 次元データ f(φ,r) に対して
</p>
<pre>
   ∫f(φ,r) r^2cosφ dφdr /(2(r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001439-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001439-source">
<pre>
    function AvrLatRad_yz(yz)  ! 緯度動径(子午面)積分
      !
      ! 2 次元(YZ)格子点データの緯度動径(子午面)平均
      !
      ! 2 次元データ f(φ,r) に対して
      !
      !    ∫f(φ,r) r^2cosφ dφdr /(2(r[o]^3-r[i]^3)/3)
      !
      ! を計算する.
      !
      real(8), dimension(1:jm,0:km), intent(in) :: yz
      !(in) 2 次元緯度動径(子午面)格子点データ

      real(8)                   :: AvrLatRad_yz
      !(out) 平均値

      AvrLatRad_yz = IntLatRad_yz(yz)/(sum(y_Lat_Weight)*sum(z_Rad_Weight))

    end function AvrLatRad_yz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001502" class="method-detail">
        <a name="M001502"></a>

        <div class="method-heading">




          <span class="method-name">AvrLat_y</span><span class="method-args">( y_data ) result(AvrLat_y)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001502">AvrLat_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y_data(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(Y)格子点データの緯度(Y)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, y_Y_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000924">wa_module#AvrLat_y</a>
</p>


        </div>
      </div>


      <div id="method-M001436" class="method-detail">
        <a name="M001436"></a>

        <div class="method-heading">


          <a href="#M001436" class="method-signature">



          <span class="method-name">AvrLonLatRad_xyz</span><span class="method-args">( xyz ) result(AvrLonLatRad_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001436">AvrLonLatRad_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全球平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度経度動径(全球)積分
</p>
<p>
3 次元格子点データの緯度経度動径(全球)積分
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
   ∫f(λ,φ,r) r^2cosφ dλdφdr /(4π(r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001436-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001436-source">
<pre>
    function AvrLonLatRad_xyz(xyz) ! 緯度経度動径(全球)積分
      !
      ! 3 次元格子点データの緯度経度動径(全球)積分
      !
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !    ∫f(λ,φ,r) r^2cosφ dλdφdr /(4π(r[o]^3-r[i]^3)/3) 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ

      real(8)                     :: AvrLonLatRad_xyz
      !(out) 全球平均値

      AvrLonLatRad_xyz = IntLonLatRad_xyz(xyz) /(sum(x_Lon_Weight)*sum(y_Lat_Weight) * sum(z_Rad_Weight))

    end function AvrLonLatRad_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001500" class="method-detail">
        <a name="M001500"></a>

        <div class="method-heading">




          <span class="method-name">AvrLonLat_xy</span><span class="method-args">( xy_data ) result(AvrLonLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001500">AvrLonLat_xy</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの全領域平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた 総和を計算し,
x_X_Weight*y_Y_Weight の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000920">wa_module#AvrLonLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001442" class="method-detail">
        <a name="M001442"></a>

        <div class="method-heading">


          <a href="#M001442" class="method-signature">



          <span class="method-name">AvrLonRad_xz</span><span class="method-args">( xz ) result(AvrLonRad_xz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001442">AvrLonRad_xz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
経度動径(緯度円)積分
</p>
<p>
2 次元(XZ)格子点データの経度動径平均
</p>
<p>
2 次元データ f(λ,r) に対して
</p>
<pre>
   ∫f(λ,r) r^2dλdr /(2π(r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001442-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001442-source">
<pre>
    function AvrLonRad_xz(xz)  ! 経度動径(緯度円)積分
      !
      ! 2 次元(XZ)格子点データの経度動径平均
      !
      ! 2 次元データ f(λ,r) に対して 
      ! 
      !    ∫f(λ,r) r^2dλdr /(2π(r[o]^3-r[i]^3)/3)
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,0:km), intent(in) :: xz    
      ! (in) 2 次元格子点データ
      real(8)                                 :: AvrLonRad_xz      
      ! 積分値

      AvrLonRad_xz = IntLonRad_xz(xz)/(sum(x_Lon_Weight)*sum(z_Rad_Weight))

    end function AvrLonRad_xz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001501" class="method-detail">
        <a name="M001501"></a>

        <div class="method-heading">




          <span class="method-name">AvrLon_x</span><span class="method-args">( x_data ) result(AvrLon_x)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001501">AvrLon_x</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>x_data(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(X)格子点データの経度(X)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, x_X_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000922">wa_module#AvrLon_x</a>
</p>


        </div>
      </div>


      <div id="method-M001443" class="method-detail">
        <a name="M001443"></a>

        <div class="method-heading">


          <a href="#M001443" class="method-signature">



          <span class="method-name">AvrRad_z</span><span class="method-args">( z ) result(AvrRad_z)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001443">AvrRad_z</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>z  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元(Z)格子点データの動径方向域平均.
</p>
<p>
1 次元データ f(r) に対して ∫f(r) r^2dr /((r[o]^3-r[i]^3)/3) を 計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001443-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001443-source">
<pre>
    function AvrRad_z(z)
      !
      ! 1 次元(Z)格子点データの動径方向域平均.
      !
      ! 1 次元データ f(r) に対して ∫f(r) r^2dr /((r[o]^3-r[i]^3)/3) を
      ! 計算する.
      !
      real(8), dimension(0:km), intent(in) :: z
      !(in) 1 次元動径格子点データ
      real(8)                              :: AvrRad_z
      !(out) 平均値

      AvrRad_z = IntRad_z(z)/sum(z_Rad_Weight)

    end function AvrRad_z
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001425" class="method-detail">
        <a name="M001425"></a>

        <div class="method-heading">


          <a href="#M001425" class="method-signature">



          <span class="method-name">IntLatRad_yz</span><span class="method-args">( yz ) result(IntLatRad_yz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001425">IntLatRad_yz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径(子午面)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元(YZ)格子点データの緯度動径積分(子午面)および平均
</p>
<p>
2 次元データ f(φ,r) に対して ∫f(φ,r) r^2cosφ dφdr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001425-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001425-source">
<pre>
    function IntLatRad_yz(yz)
      !
      ! 2 次元(YZ)格子点データの緯度動径積分(子午面)および平均
      !
      ! 2 次元データ f(φ,r) に対して ∫f(φ,r) r^2cosφ dφdr を計算する.
      !
      real(8), dimension(1:jm,0:km), intent(in) :: yz
      !(in) 2 次元緯度動径(子午面)格子点データ

      real(8)                   :: IntLatRad_yz
      !(out) 積分値
      integer :: j, k

      IntLatRad_yz = 0
      do k=0,km
         do j=1,jm
            IntLatRad_yz = IntLatRad_yz + yz(j,k) * y_Lat_Weight(j) * z_Rad_Weight(k)
         enddo
      enddo
    end function IntLatRad_yz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001497" class="method-detail">
        <a name="M001497"></a>

        <div class="method-heading">




          <span class="method-name">IntLat_y</span><span class="method-args">( y_data ) result(IntLat_y)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001497">IntLat_y</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>y_data(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元緯度(Y)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元緯度(Y)格子点データの Y 方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000919">wa_module#IntLat_y</a>
</p>


        </div>
      </div>


      <div id="method-M001422" class="method-detail">
        <a name="M001422"></a>

        <div class="method-heading">


          <a href="#M001422" class="method-signature">



          <span class="method-name">IntLonLatRad_xyz</span><span class="method-args">( xyz ) result(IntLonLatRad_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001422">IntLonLatRad_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全球積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度経度動径(全球)積分
</p>
<p>
3 次元格子点データの緯度経度動径(全球)積分
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
    ∫f(λ,φ,r) r^2cosφ dλdφdr
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001422-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001422-source">
<pre>
    function IntLonLatRad_xyz(xyz) ! 緯度経度動径(全球)積分
      !
      ! 3 次元格子点データの緯度経度動径(全球)積分
      !
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !     ∫f(λ,φ,r) r^2cosφ dλdφdr 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz 
      !(in) 3 次元経度緯度動径格子点データ

      real(8)                     :: IntLonLatRad_xyz 
      !(out) 全球積分値

      integer :: i, j, k

      IntLonLatRad_xyz = 0
      do k=0,km
         do j=1,jm
            do i=0,im-1
               IntLonLatRad_xyz = IntLonLatRad_xyz + xyz(i,j,k) * x_Lon_Weight(i) * y_Lat_Weight(j) * z_Rad_Weight(k)
            enddo
         enddo
      enddo
    end function IntLonLatRad_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001495" class="method-detail">
        <a name="M001495"></a>

        <div class="method-heading">




          <span class="method-name">IntLonLat_xy</span><span class="method-args">( xy_data ) result(IntLonLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001495">IntLonLat_xy</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの全領域積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight, y_Y_Weight をかけた
総和を計算している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000915">wa_module#IntLonLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001428" class="method-detail">
        <a name="M001428"></a>

        <div class="method-heading">


          <a href="#M001428" class="method-signature">



          <span class="method-name">IntLonRad_xz</span><span class="method-args">( xz ) result(IntLonRad_xz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001428">IntLonRad_xz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
経度動径(緯度円)積分
</p>
<p>
2 次元(XZ)格子点データの経度動径積分
</p>
<p>
2 次元データ f(λ,r) に対して∫f(λ,r) r^2dλdr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001428-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001428-source">
<pre>
    function IntLonRad_xz(xz)  ! 経度動径(緯度円)積分
      !
      ! 2 次元(XZ)格子点データの経度動径積分
      !
      ! 2 次元データ f(λ,r) に対して∫f(λ,r) r^2dλdr を計算する.
      !
      real(8), dimension(0:im-1,0:km), intent(in) :: xz
      !(in) 2 次元緯度動径格子点データ

      real(8)                                 :: IntLonRad_xz
      !(out) 積分値

      integer :: i, k

      IntLonRad_xz = 0
      do k=0,km
         do i=0,im-1
            IntLonRad_xz = IntLonRad_xz + xz(i,k) * x_Lon_Weight(i) * z_Rad_Weight(k)
         enddo
      enddo
    end function IntLonRad_xz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001496" class="method-detail">
        <a name="M001496"></a>

        <div class="method-heading">




          <span class="method-name">IntLon_x</span><span class="method-args">( x_data ) result(IntLon_x)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001496">IntLon_x</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>x_data(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
1 次元経度(X)格子点データの X 方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000917">wa_module#IntLon_x</a>
</p>


        </div>
      </div>


      <div id="method-M001429" class="method-detail">
        <a name="M001429"></a>

        <div class="method-heading">


          <a href="#M001429" class="method-signature">



          <span class="method-name">IntRad_z</span><span class="method-args">( z ) result(IntRad_z)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001429">IntRad_z</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>z  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
動径積分
</p>
<p>
1 次元(Z)格子点データの動径方向域積分.
</p>
<p>
1 次元データ f(r) に対して ∫f(r) r^2dr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001429-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001429-source">
<pre>
    function IntRad_z(z)  ! 動径積分
      !
      ! 1 次元(Z)格子点データの動径方向域積分.
      !
      ! 1 次元データ f(r) に対して ∫f(r) r^2dr を計算する.
      !
      real(8), dimension(0:km), intent(in) :: z
      !(in) 1 次元動径格子点データ

      real(8)                              :: IntRad_z
      !(out) 積分値

      integer :: k

      IntRad_z = 0.0d0
      do k=0,km
         IntRad_z = IntRad_z + z(k) * z_Rad_Weight(k) 
      enddo
    end function IntRad_z
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001454" class="method-detail">
        <a name="M001454"></a>

        <div class="method-heading">


          <a href="#M001454" class="method-signature">



          <span class="method-name">Interpolate_wt</span><span class="method-args">( wt_data, alon, alat, arad ) result(Interpolate_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001454">Interpolate_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間した値

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt_data((nm+1)**2,0:km)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>alon  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間する位置(経度)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>alat  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間する位置(緯度)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>arad  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(IN)</tt>

<table>
<tr><td valign="top"> :</td><td> 補間する位置(動径)

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度 alon, 経度 alat 動径 arad における関数値を その球面調和変換係数
wa_data から補間計算する
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001454-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001454-source">
<pre>
    function Interpolate_wt(wt_data,alon,alat,arad)
      !
      ! 緯度 alon, 経度 alat 動径 arad における関数値を
      ! その球面調和変換係数 wa_data から補間計算する
      !
      real(8), intent(IN) :: wt_data((nm+1)**2,0:km)  ! スペクトルデータ
      real(8), intent(IN) :: alon                     ! 補間する位置(経度)
      real(8), intent(IN) :: alat                     ! 補間する位置(緯度)
      real(8), intent(IN) :: arad                     ! 補間する位置(動径)
      real(8) :: Interpolate_wt                       ! 補間した値
      
      Interpolate_wt = Interpolate_w(a_Interpolate_at(wt_data,arad),alon,alat)

    end function Interpolate_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001489" class="method-detail">
        <a name="M001489"></a>

        <div class="method-heading">




          <span class="method-name">at_Dr_at</span><span class="method-args">( at_data ) result(at_Dx_at)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_Dx_at  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(at_data,1),0:size(at_data,2)-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの X 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,0:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力チェビシェフデータに X 微分を作用する(2 次元配列用).
</p>
<p>
チェビシェフデータの X 微分とは, 対応する格子点データに X 微分を
作用させたデータのチェビシェフ変換のことである.
</p>
<p>
Original external subprogram is <a
href="at_module.html#M001342">at_module#at_Dx_at</a>
</p>


        </div>
      </div>


      <div id="method-M001492" class="method-detail">
        <a name="M001492"></a>

        <div class="method-heading">




          <span class="method-name">at_az</span><span class="method-args">( ag_data ) result(at_ag)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>at_ag  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(ag_data,1),0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ag_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからチェビシェフデータへ変換する(2 次元配列用).
</p>
<p>
Original external subprogram is <a
href="at_module.html#M001340">at_module#at_ag</a>
</p>


        </div>
      </div>


      <div id="method-M001491" class="method-detail">
        <a name="M001491"></a>

        <div class="method-heading">




          <span class="method-name">az_at</span><span class="method-args">( at_data ) result(ag_at)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>ag_at  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(at_data,1),0:im)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>at_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
チェビシェフデータから格子データへ変換する(2 次元配列用).
</p>
<p>
Original external subprogram is <a
href="at_module.html#M001338">at_module#ag_at</a>
</p>


        </div>
      </div>


      <div id="method-M001479" class="method-detail">
        <a name="M001479"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( n, m ) result(l_nm_array00)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array00  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>n  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>m  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
引数 n,m がともに整数値の場合, 整数値を返す.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000877">wa_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M001480" class="method-detail">
        <a name="M001480"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( n, marray ) result(l_nm_array01)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array01(size(marray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>n  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>marray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置
</p>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1 引数 n が整数, 第 2 引数 marray が整数 1 次元配列の場合, marray
と同じ大きさの 1 次元整数配列を返す.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000877">wa_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M001481" class="method-detail">
        <a name="M001481"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( narray, m ) result(l_nm_array10)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array10(size(narray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>narray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>m  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1 引数 narray が整数 1 次元配列, 第 2 引数 m が整数の場合, narray
と同じ大きさの 1 次元整数配列を返す.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000877">wa_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M001482" class="method-detail">
        <a name="M001482"></a>

        <div class="method-heading">




          <span class="method-name">l_nm</span><span class="method-args">( narray, marray ) result(l_nm_array11)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>l_nm_array11(size(narray))  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>narray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 全波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>marray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
全波数(n)と東西波数(m)からそのスペクトルデータの格納位置を返す.
</p>
<p>
第 1,2 引数 narray, marray がともに整数 1 次元配列の場合, narray, marray
と同じ大きさの 1 次元整数配列を返す. narray, marray
は同じ大きさでなければならない.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000877">wa_module#l_nm</a>
</p>


        </div>
      </div>


      <div id="method-M001483" class="method-detail">
        <a name="M001483"></a>

        <div class="method-heading">




          <span class="method-name">nm_l</span><span class="method-args">( l ) result(nm_l_int)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>nm_l_int(2)  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全波数, 帯状波数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>l  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置(l)から全波数(n)と東西波数(m)を返す.
</p>
<p>
引数 l が整数値の場合, 対応する全波数と帯状波数を 長さ 2 の 1
次元整数値を返す. <a href="wt_module.html#M001483">nm_l</a>(1) が全波数, <a
href="wt_module.html#M001483">nm_l</a>(2) が帯状波数である.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000881">wa_module#nm_l</a>
</p>


        </div>
      </div>


      <div id="method-M001484" class="method-detail">
        <a name="M001484"></a>

        <div class="method-heading">




          <span class="method-name">nm_l</span><span class="method-args">( larray ) result(nm_l_array)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>nm_l_array(size(larray),2)  </tt></b>  <tt> </tt> :</td><td><tt>integer</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータの格納位置

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>larray(:)  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 全波数, 帯状波数

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータの格納位置(l)から全波数(n)と東西波数(m)を返す.
</p>
<p>
引数 larray が整数 1 次元配列の場合, larray に対応する n, m を格納した 2
次元整数配列を返す. nm_l_array(:,1) が全波数, nm_l_array(:,2)
が帯状波数である.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000881">wa_module#nm_l</a>
</p>


        </div>
      </div>


      <div id="method-M001457" class="method-detail">
        <a name="M001457"></a>

        <div class="method-heading">


          <a href="#M001457" class="method-signature">



          <span class="method-name">nmz_PoloidalEnergySpectrum_wt</span><span class="method-args">( wt_POLPOT ) result(nmz_PoloidalEnergySpectrum_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001457">nmz_PoloidalEnergySpectrum_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,-nm:nm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトルポロイダル成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt_POLPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ポロイダルポテンシャル

</td></tr>
</table>
</td></tr>
</table>
<p>
ポロイダルポテンシャルから, ポロイダルエネルギーの 球面調和函数全波数 n,
帯状波数 m の各成分を計算する.
</p>
<pre>
 * 全波数 n, 帯状波数 m のポロイダルポテンシャルのスペクトル成分
   φ(n,m,r)から全波数 n, 帯状波数 m 成分のポロイダルエネルギー
   スペクトルは

     (1/2)n(n+1)4πr^2{[d(rφ(n,m,r))/dr]^2 + n(n+1)φ(n,m,r)^2}

   と計算される.

 * 全てのエネルギースペクトル成分の和を動径積分したもの(r^2の重み無し)
   が球殻内での全エネルギーに等しい.

 * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
   欠損値の値はモジュール変数 wt_VMiss によって設定できる
   (初期値は -999.0)
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001457-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001457-source">
<pre>
    function nmz_PoloidalEnergySpectrum_wt(wt_POLPOT)
      !
      ! ポロイダルポテンシャルから, ポロイダルエネルギーの
      ! 球面調和函数全波数 n, 帯状波数 m の各成分を計算する.
      !
      !  * 全波数 n, 帯状波数 m のポロイダルポテンシャルのスペクトル成分
      !    φ(n,m,r)から全波数 n, 帯状波数 m 成分のポロイダルエネルギー
      !    スペクトルは 
      !
      !      (1/2)n(n+1)4πr^2{[d(rφ(n,m,r))/dr]^2 + n(n+1)φ(n,m,r)^2} 
      !
      !    と計算される.
      !
      !  * 全てのエネルギースペクトル成分の和を動径積分したもの(r^2の重み無し)
      !    が球殻内での全エネルギーに等しい.
      !
      !  * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
      !    欠損値の値はモジュール変数 wt_VMiss によって設定できる
      !    (初期値は -999.0)
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt_POLPOT
      !(in) ポロイダルポテンシャル

      real(8), dimension(0:nm,-nm:nm,0:km) :: nmz_PoloidalEnergySpectrum_wt 
      !(out) エネルギースペクトルポロイダル成分


      real(8), dimension((nm+1)*(nm+1),0:km) ::wz_DATA1   ! 作業領域
      real(8), dimension((nm+1)*(nm+1),0:km) ::wz_DATA2   ! 作業領域
      integer :: n, m

      nmz_PoloidalEnergySpectrum_wt = wt_VMiss

      wz_Data1 = wz_wt(wt_POLPOT)
      wz_Data2 = wz_Rad*wz_wt(wt_DRad_wt(wt_POLPOT))     ! d(rφ)/dr + wz_wt(wt_POLPOT)                         ! = rdφ/dr+φ

      do n=0,nm
         do m=-n,n
            nmz_PoloidalEnergySpectrum_wt(n,m,:) = + 0.5* n*(n+1)* (4*pi) *( wz_Data2(l_nm(n,m),:)**2 + n*(n+1)*wz_Data1(l_nm(n,m),:)**2 )
         enddo
      enddo

    end function nmz_PoloidalEnergySpectrum_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001455" class="method-detail">
        <a name="M001455"></a>

        <div class="method-heading">


          <a href="#M001455" class="method-signature">



          <span class="method-name">nmz_ToroidalEnergySpectrum_wt</span><span class="method-args">( wt_TORPOT ) result(nmz_ToroidalEnergySpectrum_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001455">nmz_ToroidalEnergySpectrum_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,-nm:nm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトルトロイダル成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) トロイダルポテンシャル

</td></tr>
</table>
</td></tr>
</table>
<p>
トロイダルポテンシャルから, トロイダルエネルギーの 球面調和函数全波数 n,
帯状波数 m の各成分を計算する
</p>
<pre>
 * 全波数 n, 帯状波数 m のトロイダルポテンシャルのスペクトル成分
   ψ(n,m,r)から全波数 n, 帯状波数 m 成分のトロイダルエネルギー
   スペクトルは  (1/2)n(n+1)4πr^2ψ(n,m,r)^2  と計算される.

 * 全てのエネルギースペクトル成分の和を動径積分したもの(r^2の重み無し)
   が球殻内での全エネルギーに等しい.

 * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
   wt_VMiss によって設定できる (初期値は -999.0)
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001455-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001455-source">
<pre>
    function nmz_ToroidalEnergySpectrum_wt(wt_TORPOT)
      !
      ! トロイダルポテンシャルから, トロイダルエネルギーの
      ! 球面調和函数全波数 n, 帯状波数 m の各成分を計算する
      !
      !  * 全波数 n, 帯状波数 m のトロイダルポテンシャルのスペクトル成分
      !    ψ(n,m,r)から全波数 n, 帯状波数 m 成分のトロイダルエネルギー
      !    スペクトルは  (1/2)n(n+1)4πr^2ψ(n,m,r)^2  と計算される.
      !
      !  * 全てのエネルギースペクトル成分の和を動径積分したもの(r^2の重み無し)
      !    が球殻内での全エネルギーに等しい.
      !    
      !  * データの存在しない全波数 n, 帯状波数 m の配列には欠損値が格納される.
      !    wt_VMiss によって設定できる (初期値は -999.0)
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt_TORPOT
      !(in) トロイダルポテンシャル

      real(8), dimension(0:nm,-nm:nm,0:km) :: nmz_ToroidalEnergySpectrum_wt
      !(out) エネルギースペクトルトロイダル成分

      real(8), dimension((nm+1)*(nm+1),0:km) ::wz_DATA   ! 作業領域
      integer :: n, m

      nmz_ToroidalEnergySpectrum_wt = wt_VMiss

      wz_DATA = wz_wt(wt_TORPOT)
      do n=0,nm
         do m=-n,n
            nmz_ToroidalEnergySpectrum_wt(n,m,:) = 0.5 * n*(n+1)* (4*pi) * z_Rad**2 * wz_DATA(l_nm(n,m),:)**2
         enddo
      enddo

    end function nmz_ToroidalEnergySpectrum_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001458" class="method-detail">
        <a name="M001458"></a>

        <div class="method-heading">


          <a href="#M001458" class="method-signature">



          <span class="method-name">nz_PoloidalEnergySpectrum_wt</span><span class="method-args">( wt_POLPOT ) result(nz_PoloidalEnergySpectrum_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001458">nz_PoloidalEnergySpectrum_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトルポロイダル成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt_POLPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ポロイダルポテンシャル

</td></tr>
</table>
</td></tr>
</table>
<p>
ポロイダルポテンシャルから, ポロイダルエネルギーの
球面調和函数全波数の各成分を計算する
</p>
<pre>
 * 全波数 n, 帯状波数 m のポロイダルポテンシャルのスペクトル成分
   φ(n,m,r)から全波数 n 成分のポロイダルエネルギースペクトルは

     Σ[m=-n]^n ((1/2)n(n+1)4πr^2{[d(rφ(n,m,r))/dr]^2
                + n(n+1)φ(n,m,r)^2}

   と計算される.

 * 全ての全波数に対してのエネルギースペクトル成分の和を動径積分したもの
   (r^2の重み無し)が球殻内での全エネルギーに等しい.
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001458-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001458-source">
<pre>
    function nz_PoloidalEnergySpectrum_wt(wt_POLPOT)
      !
      ! ポロイダルポテンシャルから, ポロイダルエネルギーの
      ! 球面調和函数全波数の各成分を計算する
      !
      !  * 全波数 n, 帯状波数 m のポロイダルポテンシャルのスペクトル成分
      !    φ(n,m,r)から全波数 n 成分のポロイダルエネルギースペクトルは
      !
      !      Σ[m=-n]^n ((1/2)n(n+1)4πr^2{[d(rφ(n,m,r))/dr]^2 
      !                 + n(n+1)φ(n,m,r)^2} 
      !
      !    と計算される.
      !
      !  * 全ての全波数に対してのエネルギースペクトル成分の和を動径積分したもの
      !    (r^2の重み無し)が球殻内での全エネルギーに等しい.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt_POLPOT
      !(in) ポロイダルポテンシャル

      real(8), dimension(0:nm,0:km) :: nz_PoloidalEnergySpectrum_wt
      !(out) エネルギースペクトルポロイダル成分

      real(8), dimension((nm+1)*(nm+1),0:km) ::wz_DATA1   ! 作業領域
      real(8), dimension((nm+1)*(nm+1),0:km) ::wz_DATA2   ! 作業領域
      integer :: n, m

      wz_Data1 = wz_wt(wt_POLPOT)
      wz_Data2 = wz_Rad*wz_wt(wt_DRad_wt(wt_POLPOT))     ! d(rφ)/dr + wz_wt(wt_POLPOT)                         ! = rdφ/dr+φ

      do n=0,nm
         nz_PoloidalEnergySpectrum_wt(n,:) = + 0.5* n*(n+1)* (4*pi) *( sum(wz_Data2(l_nm(n,(/(m,m=-n,n)/)),:)**2,1) + n*(n+1)*sum(wz_Data1(l_nm(n,(/(m,m=-n,n)/)),:)**2,1) )
      enddo

    end function nz_PoloidalEnergySpectrum_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001456" class="method-detail">
        <a name="M001456"></a>

        <div class="method-heading">


          <a href="#M001456" class="method-signature">



          <span class="method-name">nz_ToroidalEnergySpectrum_wt</span><span class="method-args">( wt_TORPOT ) result(nz_ToroidalEnergySpectrum_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001456">nz_ToroidalEnergySpectrum_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:nm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) エネルギースペクトルトロイダル成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) トロイダルポテンシャル

</td></tr>
</table>
</td></tr>
</table>
<p>
トロイダルポテンシャルから, トロイダルエネルギーの
球面調和函数全波数の各成分を計算する.
</p>
<pre>
 * 全波数 n, 帯状波数 m のトロイダルポテンシャルのスペクトル成分
   ψ(n,m,r)から全波数 n 成分のトロイダルエネルギースペクトルは
   Σ[m=-n]^n(1/2)n(n+1)4πr^2ψ(n,m,r)^2 と計算される.
</pre>
<ul>
<li>全てのエネルギースペクトル成分の和を動径積分したもの(r^2の重み無し)

<pre>
 が球殻内での全エネルギーに等しい.
</pre>
</li>
</ul>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001456-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001456-source">
<pre>
    function nz_ToroidalEnergySpectrum_wt(wt_TORPOT)
      !
      ! トロイダルポテンシャルから, トロイダルエネルギーの
      ! 球面調和函数全波数の各成分を計算する.
      !
      !  * 全波数 n, 帯状波数 m のトロイダルポテンシャルのスペクトル成分
      !    ψ(n,m,r)から全波数 n 成分のトロイダルエネルギースペクトルは
      !    Σ[m=-n]^n(1/2)n(n+1)4πr^2ψ(n,m,r)^2 と計算される.
      !
      ! * 全てのエネルギースペクトル成分の和を動径積分したもの(r^2の重み無し)
      !    が球殻内での全エネルギーに等しい.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt_TORPOT
      !(in) トロイダルポテンシャル

      real(8), dimension(0:nm,0:km) :: nz_ToroidalEnergySpectrum_wt 
      !(out) エネルギースペクトルトロイダル成分

      real(8), dimension((nm+1)*(nm+1),0:km) ::wz_DATA   ! 作業領域
      integer :: n, m

      wz_DATA = wz_wt(wt_TORPOT)
      do n=0,nm
         nz_ToroidalEnergySpectrum_wt(n,:) = 0.5 * n*(n+1)* (4*pi) * z_Rad**2 * sum(wz_Data(l_nm(n,(/(m,m=-n,n)/)),:)**2,1)
      enddo

    end function nz_ToroidalEnergySpectrum_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001490" class="method-detail">
        <a name="M001490"></a>

        <div class="method-heading">




          <span class="method-name">t_Dr_t</span><span class="method-args">( t_data ) result(t_Dx_t)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>t_Dx_t  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(size(t_data))</tt>

<table>
<tr><td valign="top"> :</td><td> (out) チェビシェフデータの X 微分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>t_data  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力チェビシェフデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力チェビシェフデータに X 微分を作用する(1 次元配列用).
</p>
<p>
チェビシェフデータの X 微分とは, 対応する格子点データに X 微分を
作用させたデータのチェビシェフ変換のことである.
</p>
<p>
Original external subprogram is <a
href="at_module.html#M001343">at_module#t_Dx_t</a>
</p>


        </div>
      </div>


      <div id="method-M001487" class="method-detail">
        <a name="M001487"></a>

        <div class="method-heading">




          <span class="method-name">w_xy</span><span class="method-args">( xy_data, [ipow], [iflag] ) result(w_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001487">w_xy</a>((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ipow  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 変換時に同時に作用させる 1/cosφ の次数. 省略時は 0.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>iflag  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> 変換の種類

<pre>
   0 : 通常の正変換
  -1 : 経度微分を作用させた正変換
   1 : 緯度微分 1/cosφ・∂(f cos^2φ)/∂φ を作用させた正変換
   2 : sinφを作用させた正変換
 省略時は 0.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
格子データからスペクトルデータへ(正)変換する(1 層用).
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000876">wa_module#w_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001469" class="method-detail">
        <a name="M001469"></a>

        <div class="method-heading">




          <span class="method-name">wt_Boundaries</span><span class="method-args">( wt, [values], [cond] ) </span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界での 値/勾配 分布を水平スペクトル変換したものを与える.

<pre>
    省略時は値/勾配 0 となる.
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件. 省略時は &#8216;DD&#8216;

<pre>
       DD : 両端ディリクレ条件
       DN : 上端ディリクレ, 下端ノイマン条件
       ND : 上端ノイマン, 下端ディリクレ条件
       NN : 両端ノイマン条件
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータにディリクレ・ノイマン境界条件を適用する Chebyshev
空間での境界条件適用(タウ法)
</p>
<p>
チェビシェフ空間において境界条件を満たすべく高次の係数を
定める方法をとっている(タウ法).
</p>
<p>
Alias for <a href="wt_module.html#M001459">wt_BoundariesTau</a>
</p>


        </div>
      </div>


      <div id="method-M001460" class="method-detail">
        <a name="M001460"></a>

        <div class="method-heading">


          <a href="#M001460" class="method-signature">



          <span class="method-name">wt_BoundariesGrid</span><span class="method-args">( wt, [values], [cond] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界での 値/勾配 分布を水平スペクトル変換したものを与える.

<pre>
   省略時は値/勾配 0 となる.
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件. 省略時は &#8216;DD&#8216;

<pre>
       DD : 両端ディリクレ条件
       DN : 上端ディリクレ, 下端ノイマン条件
       ND : 上端ノイマン, 下端ディリクレ条件
       NN : 両端ノイマン条件
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータにディリクレ・ノイマン境界条件を適用する
実空間での境界条件適用
</p>
<p>
鉛直実格子点空間において内部領域の値と境界条件を満たすように
条件を課している(選点法). このルーチンを用いるためには <a
href="wt_module.html#M001396">wt_Initial</a>
にて設定するチェビシェフ切断波数(lm)と鉛直格子点数(km)を
等しくしておく必要がある.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001460-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001460-source">
<pre>
    subroutine wt_BoundariesGrid(wt,values,cond)
      !
      ! スペクトルデータにディリクレ・ノイマン境界条件を適用する
      ! 実空間での境界条件適用
      !
      ! 鉛直実格子点空間において内部領域の値と境界条件を満たすように
      ! 条件を課している(選点法). このルーチンを用いるためには 
      ! wt_Initial にて設定するチェビシェフ切断波数(lm)と鉛直格子点数(km)を
      ! 等しくしておく必要がある.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)      :: wt
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      real(8), dimension((nm+1)*(nm+1),2), intent(in), optional :: values
              !(in) 境界での 値/勾配 分布を水平スペクトル変換したものを与える. 
              !    省略時は値/勾配 0 となる. 

      character(len=2), intent(in), optional             :: cond
              !(in) 境界条件. 省略時は 'DD'
              !        DD : 両端ディリクレ条件
              !        DN : 上端ディリクレ, 下端ノイマン条件
              !        ND : 上端ノイマン, 下端ディリクレ条件
              !        NN : 両端ノイマン条件

      if (.not. present(cond)) then
         if (present(values)) then
            call at_boundariesGrid_DD(wt,values)
         else
            call at_boundariesGrid_DD(wt)
         endif
         return
      endif

      select case(cond)
      case ('NN')
         if (present(values)) then
            call at_BoundariesGrid_NN(wt,values)
         else
            call at_BoundariesGrid_NN(wt)
         endif
      case ('DN')
         if (present(values)) then
            call at_BoundariesGrid_DN(wt,values)
         else
            call at_BoundariesGrid_DN(wt)
         endif
      case ('ND')
         if (present(values)) then
            call at_BoundariesGrid_ND(wt,values)
         else
            call at_BoundariesGrid_ND(wt)
         endif
      case ('DD')
         if (present(values)) then
            call at_BoundariesGrid_DD(wt,values)
         else
            call at_BoundariesGrid_DD(wt)
         endif
      case default
         call MessageNotify('E','wt_BoundariesGrid','B.C. not supported')
      end select

    end subroutine wt_BoundariesGrid
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001459" class="method-detail">
        <a name="M001459"></a>

        <div class="method-heading">


          <a href="#M001459" class="method-signature">



          <span class="method-name">wt_BoundariesTau</span><span class="method-args">( wt, [values], [cond] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界での 値/勾配 分布を水平スペクトル変換したものを与える.

<pre>
    省略時は値/勾配 0 となる.
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件. 省略時は &#8216;DD&#8216;

<pre>
       DD : 両端ディリクレ条件
       DN : 上端ディリクレ, 下端ノイマン条件
       ND : 上端ノイマン, 下端ディリクレ条件
       NN : 両端ノイマン条件
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータにディリクレ・ノイマン境界条件を適用する Chebyshev
空間での境界条件適用(タウ法)
</p>
<p>
チェビシェフ空間において境界条件を満たすべく高次の係数を
定める方法をとっている(タウ法).
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001459-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001459-source">
<pre>
    subroutine wt_BoundariesTau(wt,values,cond)
      !
      ! スペクトルデータにディリクレ・ノイマン境界条件を適用する
      ! Chebyshev 空間での境界条件適用(タウ法)
      !
      ! チェビシェフ空間において境界条件を満たすべく高次の係数を
      ! 定める方法をとっている(タウ法).
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)      :: wt
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      real(8), dimension((nm+1)*(nm+1),2), intent(in), optional :: values
              !(in) 境界での 値/勾配 分布を水平スペクトル変換したものを与える. 
              !     省略時は値/勾配 0 となる. 

      character(len=2), intent(in), optional             :: cond
              !(in) 境界条件. 省略時は 'DD'
              !        DD : 両端ディリクレ条件
              !        DN : 上端ディリクレ, 下端ノイマン条件
              !        ND : 上端ノイマン, 下端ディリクレ条件
              !        NN : 両端ノイマン条件

      if (.not. present(cond)) then
         if (present(values)) then
            call at_BoundariesTau_DD(wt,values)
         else
            call at_BoundariesTau_DD(wt)
         endif
         return
      endif

      select case(cond)
      case ('NN')
         if (present(values)) then
            call at_BoundariesTau_NN(wt,values)
         else
            call at_BoundariesTau_NN(wt)
         endif
      case ('DN')
         if (present(values)) then
            call at_BoundariesTau_DN(wt,values)
         else
            call at_BoundariesTau_DN(wt)
         endif
      case ('ND')
         if (present(values)) then
            call at_BoundariesTau_ND(wt,values)
         else
            call at_BoundariesTau_ND(wt)
         endif
      case ('DD')
         if (present(values)) then
            call at_BoundariesTau_DD(wt,values)
         else
            call at_BoundariesTau_DD(wt)
         endif
      case default
         call MessageNotify('E','wt_BoundariesTau','B.C. not supported')
      end select

    end subroutine wt_BoundariesTau
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001403" class="method-detail">
        <a name="M001403"></a>

        <div class="method-heading">


          <a href="#M001403" class="method-signature">



          <span class="method-name">wt_DRad_wt</span><span class="method-args">( wt ) result(wt_DRad_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001403">wt_DRad_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 動径微分された2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに動径微分 ∂/∂r を作用する.
</p>
<p>
スペクトルデータの動径微分とは, 対応する格子点データに動径微分を
作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001403-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001403-source">
<pre>
    function wt_DRad_wt(wt)
      !
      ! 入力スペクトルデータに動径微分 ∂/∂r を作用する.
      !
      ! スペクトルデータの動径微分とは, 対応する格子点データに動径微分を
      ! 作用させたデータのスペクトル変換のことである.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wt_DRad_wt
      !(in) 動径微分された2 次元球面調和函数チェビシェフスペクトルデータ

      wt_DRad_wt = at_Dr_at(wt)

    end function wt_DRad_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001410" class="method-detail">
        <a name="M001410"></a>

        <div class="method-heading">


          <a href="#M001410" class="method-signature">



          <span class="method-name">wt_DivLat_xyz</span><span class="method-args">( xyz ) result(wt_DivLat_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001410">wt_DivLat_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 発散型緯度微分を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子データに発散型緯度微分 1/rcosφ・∂(f cosφ)/∂φ を
作用させたスペクトルデータを返す.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001410-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001410-source">
<pre>
    function wt_DivLat_xyz(xyz)
      !
      ! 格子データに発散型緯度微分 1/rcosφ・∂(f cosφ)/∂φ を
      ! 作用させたスペクトルデータを返す.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in)   :: xyz
      !(in) 3 次元経度緯度動径格子点データ
      real(8), dimension((nm+1)*(nm+1),0:lm)       :: wt_DivLat_xyz
      !(out) 発散型緯度微分を作用された 2 次元スペクトルデータ

      wt_DivLat_xyz = wt_wz(wa_divlat_xya(xyz/xyz_Rad))

    end function wt_DivLat_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001409" class="method-detail">
        <a name="M001409"></a>

        <div class="method-heading">


          <a href="#M001409" class="method-signature">



          <span class="method-name">wt_DivLon_xyz</span><span class="method-args">( xyz ) result(wt_DivLon_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001409">wt_DivLon_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 発散型経度微分を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
格子点データに発散型経度微分 1/rcosφ・∂/∂λ を作用させた
スペクトルデータを返す.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001409-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001409-source">
<pre>
    function wt_DivLon_xyz(xyz)
      ! 
      ! 格子点データに発散型経度微分 1/rcosφ・∂/∂λ を作用させた
      ! スペクトルデータを返す.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in)   :: xyz
      !(in) 3 次元経度緯度動径格子点データ
      real(8), dimension((nm+1)*(nm+1),0:lm)       :: wt_DivLon_xyz
      !(out) 発散型経度微分を作用された 2 次元スペクトルデータ

      wt_DivLon_xyz = wt_wz(wa_DivLon_xya(xyz/xyz_Rad))

    end function wt_DivLon_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001404" class="method-detail">
        <a name="M001404"></a>

        <div class="method-heading">


          <a href="#M001404" class="method-signature">



          <span class="method-name">wt_DivRad_wt</span><span class="method-args">( wt ) result(wt_DivRad_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001404">wt_DivRad_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 発散型動径微分を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに発散型動径微分
</p>
<pre>
      1/r^2 ∂/∂r (r^2 .)= ∂/∂r + 2/r
</pre>
<p>
を作用する.
</p>
<p>
スペクトルデータの発散型動径微分とは, 対応する格子点データに
発散型動径微分を作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001404-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001404-source">
<pre>
    function wt_DivRad_wt(wt)
      ! 
      ! 入力スペクトルデータに発散型動径微分
      !
      !       1/r^2 ∂/∂r (r^2 .)= ∂/∂r + 2/r
      !
      ! を作用する.
      !
      ! スペクトルデータの発散型動径微分とは, 対応する格子点データに
      ! 発散型動径微分を作用させたデータのスペクトル変換のことである. 
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wt_DivRad_wt
      !(out) 発散型動径微分を作用された 2 次元スペクトルデータ

      wt_DivRad_wt = wt_Drad_wt(wt) + wt_wz(2/wz_rad*wz_wt(wt))


    end function wt_DivRad_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001411" class="method-detail">
        <a name="M001411"></a>

        <div class="method-heading">


          <a href="#M001411" class="method-signature">



          <span class="method-name">wt_Div_xyz_xyz_xyz</span><span class="method-args">( xyz_Vlon, xyz_Vlat, xyz_Vrad ) result(wt_Div_xyz_xyz_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001411">wt_Div_xyz_xyz_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の発散

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_Vlon  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_Vlat  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_Vrad  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の動径成分

</td></tr>
</table>
</td></tr>
</table>
<p>
べクトル成分である 3 つの格子データに発散を作用させた
スペクトルデータを返す.
</p>
<p>
第 1, 2 ,3 引数(u,v,w)がそれぞれベクトルの経度成分, 緯度成分,
動径成分を表し, 発散は
</p>
<pre>
     1/rcosφ・∂u/∂λ + 1/rcosφ・∂(v cosφ)/∂φ
   + 1/r^2 ∂/∂r (r^2 w)
</pre>
<p>
と計算される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001411-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001411-source">
<pre>
    function wt_Div_xyz_xyz_xyz(xyz_Vlon,xyz_Vlat,xyz_Vrad)
      !
      ! べクトル成分である 3 つの格子データに発散を作用させた
      ! スペクトルデータを返す.
      !
      ! 第 1, 2 ,3 引数(u,v,w)がそれぞれベクトルの経度成分, 緯度成分, 
      ! 動径成分を表し, 発散は 
      !
      !      1/rcosφ・∂u/∂λ + 1/rcosφ・∂(v cosφ)/∂φ 
      !    + 1/r^2 ∂/∂r (r^2 w)
      !
      ! と計算される.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz_Vlon
      !(in) ベクトル場の経度成分
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz_Vlat
      !(in) ベクトル場の緯度成分

      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz_Vrad
      !(in) ベクトル場の動径成分

      real(8), dimension((nm+1)*(nm+1),0:lm)     :: wt_Div_xyz_xyz_xyz
      !(out) ベクトル場の発散

      wt_Div_xyz_xyz_xyz =   wt_DivLon_xyz(xyz_Vlon) + wt_DivLat_xyz(xyz_Vlat) + wt_DivRad_wt(wt_xyz(xyz_Vrad))

    end function wt_Div_xyz_xyz_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001396" class="method-detail">
        <a name="M001396"></a>

        <div class="method-heading">


          <a href="#M001396" class="method-signature">



          <span class="method-name">wt_Initial</span><span class="method-args">( i, j, k, n, l, r_in, r_out, [np], [wa_init] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>i  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点数(経度λ)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>j  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点数(緯度φ)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>k  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点数(動径 r)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>n  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 切断波数(水平全波数)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>l  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 切断波数(動径波数)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>r_in  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 球殻内半径

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>r_out  </tt></b>  <tt> </tt> :</td><td><tt>real(8),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> 球殻外半径

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>np  </tt></b>  <tt> </tt> :</td><td><tt>integer,intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> OPENMP での最大スレッド数

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wa_init  </tt></b>  <tt> </tt> :</td><td><tt>logical,intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> wa_initial スイッチ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトル変換の格子点数, 波数, 動径座標の範囲を設定する.
</p>
<p>
他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで初期設定を
しなければならない.
</p>
<p>
np に 1 より大きな値を指定すれば ISPACK の球面調和函数変換 OPENMP
並列計算ルーチンが用いられる. 並列計算を実行するには, 実行時に環境変数
OMP_NUM_THREADS を np 以下の数字に設定する等の
システムに応じた準備が必要となる.
</p>
<p>
np に 1 より大きな値を指定しなければ並列計算ルーチンは呼ばれない.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001396-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001396-source">
<pre>
   subroutine wt_Initial(i,j,k,n,l,r_in,r_out,np,wa_init)
     !
     ! スペクトル変換の格子点数, 波数, 動径座標の範囲を設定する.
     !
     ! 他の関数を呼ぶ前に, 最初にこのサブルーチンを呼んで初期設定を
     ! しなければならない. 
     !
     ! np に 1 より大きな値を指定すれば ISPACK の球面調和函数変換 
     ! OPENMP 並列計算ルーチンが用いられる. 並列計算を実行するには, 
     ! 実行時に環境変数 OMP_NUM_THREADS を np 以下の数字に設定する等の
     ! システムに応じた準備が必要となる. 
     !
     ! np に 1 より大きな値を指定しなければ並列計算ルーチンは呼ばれない.
     !
     !
     integer,intent(in) :: i              ! 格子点数(経度λ)
     integer,intent(in) :: j              ! 格子点数(緯度φ)
     integer,intent(in) :: k              ! 格子点数(動径 r)
     integer,intent(in) :: n              ! 切断波数(水平全波数)
     integer,intent(in) :: l              ! 切断波数(動径波数)

     real(8),intent(in) :: r_in           ! 球殻内半径
     real(8),intent(in) :: r_out          ! 球殻外半径

     integer,intent(in), optional :: np   ! OPENMP での最大スレッド数
     logical,intent(in), optional :: wa_init   ! wa_initial スイッチ

     logical    :: wa_initialize=.true.   ! wa_initial スイッチ
     
     im = i  
      jm = j 
      km = k
     nm = n  
      lm = l
     ri = r_in 
      ro = r_out

     if ( present(wa_init) ) then
        wa_initialize = wa_init
     else
        wa_initialize = .true.
     endif

     if ( wa_initialize ) then
        if ( present(np) ) then
           call wa_Initial(nm,im,jm,km+1,np)
        else
           call wa_Initial(nm,im,jm,km+1)
        endif
     endif

     call at_Initial(km,lm,r_in,r_out)

     allocate(xyz_Lon(0:im-1,1:jm,0:km))
     allocate(xyz_Lat(0:im-1,1:jm,0:km))
     allocate(xyz_Rad(0:im-1,1:jm,0:km))

     allocate(wz_Rad((nm+1)*(nm+1),0:km))

     xyz_Lon = spread(xy_Lon,3,km+1)
     xyz_Lat = spread(xy_Lat,3,km+1)
     xyz_Rad = spread(spread(z_Rad,1,jm),1,im)

     wz_Rad = spread(z_Rad,1,(nm+1)*(nm+1))

     z_Rad_Weight = z_Rad_Weight * z_Rad**2       ! r^2 dr の積分重み

     call MessageNotify('M','wt_initial', 'wt_module (2009/01/08) is initialized')

   end subroutine wt_initial
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001444" class="method-detail">
        <a name="M001444"></a>

        <div class="method-heading">


          <a href="#M001444" class="method-signature">



          <span class="method-name">wt_KxRGrad_wt</span><span class="method-args">( wt ) result(wt_KxRGrad_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001444">wt_KxRGrad_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度微分を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに経度微分 k×r・▽ = ∂/∂λを作用する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001444-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001444-source">
<pre>
    function wt_KxRGrad_wt(wt)
      !
      ! 入力スペクトルデータに経度微分 k×r・▽ = ∂/∂λを作用する.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wt_KxRGrad_wt
      !(out) 経度微分を作用された 2 次元スペクトルデータ

      wt_KxRGrad_wt =  wa_Dlon_wa(wt)

    end function wt_KxRGrad_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001447" class="method-detail">
        <a name="M001447"></a>

        <div class="method-heading">


          <a href="#M001447" class="method-signature">



          <span class="method-name">wt_L2Inv_wt</span><span class="method-args">( wt ) result(wt_L2Inv_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001447">wt_L2Inv_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) L^2 演算子の逆演算を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに L^2 演算子の逆演算(-逆水平ラプラシアン)を 作用する.
</p>
<p>
スペクトルデータに L^2 演算子を作用させる関数 <a
href="wt_module.html#M001446">wt_L2_wt</a> の逆計算を 行う関数である.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001447-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001447-source">
<pre>
    function wt_L2Inv_wt(wt)
      !
      ! 入力スペクトルデータに L^2 演算子の逆演算(-逆水平ラプラシアン)を
      ! 作用する.
      !
      ! スペクトルデータに L^2 演算子を作用させる関数 wt_L2_wt の逆計算を
      ! 行う関数である.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wt_L2Inv_wt
      !(out) L^2 演算子の逆演算を作用された 2 次元スペクトルデータ

      wt_L2Inv_wt = -wa_LaplaInv_wa(wt)

    end function wt_L2Inv_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001446" class="method-detail">
        <a name="M001446"></a>

        <div class="method-heading">


          <a href="#M001446" class="method-signature">



          <span class="method-name">wt_L2_wt</span><span class="method-args">( wt ) result(wt_L2_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001446">wt_L2_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) L^2 演算子を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに L^2 演算子(=-水平ラプラシアン)を作用する.
</p>
<p>
L^2 演算子は単位球面上の水平ラプラシアンの逆符号にあたる.
</p>
<pre>
 入力スペクトルデ ータに対応する格子点データに演算子

    L^2 = -1/cos^2φ・∂^2/∂λ^2 - 1/cosφ・∂/∂φ(cosφ∂/∂φ)
</pre>
<p>
を作用させたデータのスペクトル変換が返される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001446-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001446-source">
<pre>
    function wt_L2_wt(wt)
      !
      ! 入力スペクトルデータに L^2 演算子(=-水平ラプラシアン)を作用する.
      !
      ! L^2 演算子は単位球面上の水平ラプラシアンの逆符号にあたる. 
      !  入力スペクトルデ ータに対応する格子点データに演算子 
      !
      !     L^2 = -1/cos^2φ・∂^2/∂λ^2 - 1/cosφ・∂/∂φ(cosφ∂/∂φ)
      !
      ! を作用させたデータのスペクトル変換が返される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wt_L2_wt
      !(out) L^2 演算子を作用された 2 次元スペクトルデータ

      wt_L2_wt = -wa_Lapla_wa(wt)

    end function wt_L2_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001464" class="method-detail">
        <a name="M001464"></a>

        <div class="method-heading">


          <a href="#M001464" class="method-signature">



          <span class="method-name">wt_LaplaPol2PolGrid_wt</span><span class="method-args">( wt, [cond], [new] ) result(wt_LaplaPol2PolGrid_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001464">wt_LaplaPol2PolGrid_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 出力ポロイダルポテンシャル分布

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力▽^2φ分布

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件スイッチ. 省略時は &#8216;RR&#8216;

<pre>
    RR    : 両端粘着条件
    RF    : 上端粘着, 下端応力なし条件
    FR    : 上端応力なし, 下端粘着条件
    FF    : 両端応力なし条件
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
速度ポロイダルポテンシャルΦを▽^2Φから計算する.
チェビシェフ格子点空間で境界条件を適用している.
</p>
<p>
この関数を用いるためには <a href="wt_module.html#M001396">wt_Initial</a>
にて設定する チェビシェフ切断波数(lm)と鉛直格子点数(km)を等しく
しておく必要がある.
</p>
<p>
速度ポロイダルポテンシャルΦを f = ▽^2Φから定める式は
</p>
<pre>
   ▽^2Φ = f
     Φ = const. at boundaries.
     ∂Φ/∂r = 0 at boundaries          (粘着条件)
     or ∂^2Φ/∂r^2 = 0 at boundaries   (応力なし条件)
</pre>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>
<p>
最終的にチェビシェフ係数の解が欲しい場合には, <a
href="wt_module.html#M001463">wz_LaplaPol2Pol_wz</a> に 比べてチェビシェフ
&#8212; 格子点変換が 1 回分少なくて済む.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001464-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001464-source">
<pre>
    function wt_LaplaPol2PolGrid_wt(wt,cond,new)
      !
      ! 速度ポロイダルポテンシャルΦを▽^2Φから計算する.
      ! チェビシェフ格子点空間で境界条件を適用している. 
      !
      ! この関数を用いるためには wt_Initial にて設定する
      ! チェビシェフ切断波数(lm)と鉛直格子点数(km)を等しく
      ! しておく必要がある. 
      !
      ! 速度ポロイダルポテンシャルΦを f = ▽^2Φから定める式は
      !
      !    ▽^2Φ = f
      !      Φ = const. at boundaries.
      !      ∂Φ/∂r = 0 at boundaries          (粘着条件) 
      !      or ∂^2Φ/∂r^2 = 0 at boundaries   (応力なし条件)
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      ! 最終的にチェビシェフ係数の解が欲しい場合には, wz_LaplaPol2Pol_wz に
      ! 比べてチェビシェフ -- 格子点変換が 1 回分少なくて済む.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(in)  :: wt
              !(in) 入力▽^2φ分布

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wt_LaplaPol2PolGrid_wt
              !(out) 出力ポロイダルポテンシャル分布

      character(len=2), intent(in), optional  :: cond
              !(in) 境界条件スイッチ. 省略時は 'RR'
              !     RR    : 両端粘着条件
              !     RF    : 上端粘着, 下端応力なし条件
              !     FR    : 上端応力なし, 下端粘着条件
              !     FF    : 両端応力なし条件

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:,:), allocatable  :: alu
      integer, dimension(:,:), allocatable    :: kp

      real(8), dimension((nm+1)*(nm+1),0:km)  :: wz_work
      real(8), dimension((nm+1)*(nm+1),0:lm)  :: wt_work
      real(8), dimension(0:lm,0:lm)           :: tt_I
      real(8), dimension(0:lm,0:km)           :: tz_work
      logical                                 :: rigid1, rigid2   ! 境界条件

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer :: l,n
      save    :: alu, kp, first

      if (.not. present(cond)) then
         rigid1=.TRUE. 
          rigid2=.TRUE.
      else
         select case (cond)
         case ('RR')
            rigid1 = .TRUE.  
             rigid2 = .TRUE.
         case ('RF')
            rigid1 = .TRUE.  
             rigid2 = .FALSE.
         case ('FR')
            rigid1 = .FALSE. 
             rigid2 = .TRUE.
         case ('FF')
            rigid1 = .FALSE. 
             rigid2 = .FALSE.
         case default
            call MessageNotify('E','wt_LaplaPol2PolGrid_wt','B.C. not supported')
         end select
      endif

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( lm /= km ) then
            call MessageNotify('E','wt_LaplaPol2PolGrid_wt', 'Chebyshev truncation and number of grid points should be same.')
         endif

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         allocate(alu((nm+1)*(nm+1),0:km,0:lm),kp((nm+1)*(nm+1),0:lm))

         do l=0,lm
            wt_work = 0.0D0 
             wt_work(:,l) = 1.0D0

            ! 各水平波数に関して独立の式
            alu(:,:,l) = wz_wt(wt_Lapla_wt(wt_work))
         enddo

         ! 運動学的条件. 流線は境界で一定
         tt_I = 0.0D0
         do l=0,lm
            tt_I(l,l)=1.0D0
         enddo

         ! 非電気伝導体
         tz_work = az_at(tt_I)

         do n=1,(nm+1)*(nm+1)
            alu(n,0,:)  = tz_work(:,0)
            alu(n,km,:) = tz_work(:,km)
         enddo

         ! 力学的条件粘着条件 
         if ( rigid1 ) then
            tz_work=az_at(at_Dr_at(tt_I))
         else
            tz_work=az_at(at_Dr_at(at_Dr_at(tt_I)))
         endif
         do n=1,(nm+1)*(nm+1)
            alu(n,1,:) = tz_work(:,0)
         enddo

         ! 力学的条件粘着条件 
         if ( rigid2 ) then
            tz_work=az_at(at_Dr_at(tt_I))
         else
            tz_work=az_at(at_Dr_at(at_Dr_at(tt_I)))
         endif
         do n=1,(nm+1)*(nm+1)
            alu(n,km-1,:) = tz_work(:,km)
         enddo

         call ludecomp(alu,kp)

         call MessageNotify('M','wt_LaplaPol2PolGrid_wt', 'Matrix to apply  b.c. newly produced.')
      endif

      wz_work         = wz_wt(wt)
      wz_work(:,1)    = 0.0D0               ! 力学的条件
      wz_work(:,km-1) = 0.0D0               ! 力学的条件
      wz_work(:,0)    = 0.0D0               ! 運動学的条件
      wz_work(:,km)   = 0.0D0               ! 運動学的条件 

      wt_LaplaPol2PolGrid_wt = lusolve(alu,kp,wz_work)

    end function wt_LaplaPol2PolGrid_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001406" class="method-detail">
        <a name="M001406"></a>

        <div class="method-heading">


          <a href="#M001406" class="method-signature">



          <span class="method-name">wt_Lapla_wt</span><span class="method-args">( wt ) result(wt_Lapla_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001406">wt_Lapla_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ラプラシアンを作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータにラプラシアン
</p>
<pre>
    ▽^2 =   1/r^2 cos^2φ・∂^2/∂λ^2
           + 1/r^2 cosφ・∂/∂φ(cosφ∂/∂φ)
           + 1/r^2 ∂/∂r (r^2 ∂/∂r)
</pre>
<p>
を作用する.
</p>
<p>
スペクトルデータのラプラシアンとは, 対応する格子点データに
ラプラシアンを作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001406-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001406-source">
<pre>
    function wt_Lapla_wt(wt)
      ! 入力スペクトルデータにラプラシアン
      !
      !     ▽^2 =   1/r^2 cos^2φ・∂^2/∂λ^2 
      !            + 1/r^2 cosφ・∂/∂φ(cosφ∂/∂φ) 
      !            + 1/r^2 ∂/∂r (r^2 ∂/∂r) 
      !
      ! を作用する.
      !
      ! スペクトルデータのラプラシアンとは, 対応する格子点データに
      ! ラプラシアンを作用させたデータのスペクトル変換のことである. 
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wt_Lapla_wt
      !(out) ラプラシアンを作用された 2 次元スペクトルデータ

      wt_Lapla_wt = wt_DivRad_wt(wt_Drad_wt(wt)) + wt_wz(wz_wt(wa_Lapla_wa(wt))/wz_Rad**2)

    end function wt_Lapla_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001472" class="method-detail">
        <a name="M001472"></a>

        <div class="method-heading">




          <span class="method-name">wt_PolMagBoundaries</span><span class="method-args">( wt_POL, [new] ) </span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wt_POL  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
磁場ポロイダルポテンシャルに対して境界条件を適用する. Chebyshev
空間での境界条件適用
</p>
<p>
チェビシェフ空間において境界条件を満たすべく高次の係数を定める方法を
とっている(タウ法). 現在のところ境界物質が非電気伝導体の場合のみ
対応している. その場合, 磁場ポロイダルポテンシャルの各水平スペクトル 成分 h
にたいして境界条件が与えられ,
</p>
<pre>
 * 外側境界 : dh/dr + (n+1)h/r = 0
 * 内側境界 : dh/dr - nh/r = 0
</pre>
<p>
である. ここで n は h の水平全波数である.
</p>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>
<p>
Alias for <a href="wt_module.html#M001467">wt_PolMagBoundariesTau</a>
</p>


        </div>
      </div>


      <div id="method-M001468" class="method-detail">
        <a name="M001468"></a>

        <div class="method-heading">


          <a href="#M001468" class="method-signature">



          <span class="method-name">wt_PolmagBoundariesGrid</span><span class="method-args">( wt_POL, [new] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wt_POL  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
磁場ポロイダルポテンシャルに対して境界条件を適用する.
鉛直実空間での境界条件適用.
</p>
<p>
鉛直実格子点空間において内部領域の値と境界条件を満たすように
条件を課している(選点法). このルーチンを用いるためには <a
href="wt_module.html#M001396">wt_Initial</a>
にて設定するチェビシェフ切断波数(lm)と鉛直格子点数(km)を
等しくしておく必要がある.
</p>
<p>
現在のところ境界物質が非電気伝導体の場合のみ対応している. その場合,
磁場ポロイダルポテンシャルの各水平スペクトル成分 h に
たいして境界条件が与えられ,
</p>
<pre>
 * 外側境界 : dh/dr + (n+1)h/r = 0
 * 内側境界 : dh/dr - nh/r = 0
</pre>
<p>
である. ここで n は h の水平全波数である.
</p>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001468-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001468-source">
<pre>
    subroutine wt_PolmagBoundariesGrid(wt_POL,new)
      !
      ! 磁場ポロイダルポテンシャルに対して境界条件を適用する.
      ! 鉛直実空間での境界条件適用. 
      !
      ! 鉛直実格子点空間において内部領域の値と境界条件を満たすように
      ! 条件を課している(選点法). このルーチンを用いるためには 
      ! wt_Initial にて設定するチェビシェフ切断波数(lm)と鉛直格子点数(km)を
      ! 等しくしておく必要がある. 
      !
      ! 現在のところ境界物質が非電気伝導体の場合のみ対応している. 
      ! その場合, 磁場ポロイダルポテンシャルの各水平スペクトル成分 h に
      ! たいして境界条件が与えられ,
      !
      !  * 外側境界 : dh/dr + (n+1)h/r = 0
      !  * 内側境界 : dh/dr - nh/r = 0
      !
      ! である. ここで n は h の水平全波数である. 
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)   :: wt_POL
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:,:), allocatable  :: alu
      integer, dimension(:,:), allocatable    :: kp

      real(8), dimension(:,:), allocatable    :: tt_I
      real(8), dimension(:,:), allocatable    :: tz_PSI
      real(8), dimension(:,:), allocatable    :: tz_DPSIDR
      real(8), dimension((nm+1)*(nm+1),0:km)  :: wz_POL

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer  :: l, n, nn(2)
      save     :: alu, kp, first

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( lm /= km ) then
            call MessageNotify('E','PolMagBoundariesGrid', 'Chebyshev truncation and number of grid points should be same.')
         endif

         if ( allocated(alu) ) then 
           deallocate(alu)
         endif
         if ( allocated(kp) ) then 
           deallocate(kp)
         endif
         if ( allocated(tt_I) ) then
           deallocate(tt_I)
         endif
         if ( allocated(tz_PSI) ) then 
           deallocate(tz_PSI)
         endif
         if ( allocated(tz_DPSIDR) ) then 
           deallocate(tz_DPSIDR)
         endif

         allocate(alu((nm+1)*(nm+1),0:lm,0:lm),kp((nm+1)*(nm+1),0:lm))
         allocate(tt_I(0:lm,0:lm),tz_PSI(0:lm,0:km),tz_DPSIDR(0:lm,0:km))

         tt_I = 0.0D0
         do l=0,lm
            tt_I(l,l)=1.0D0
         enddo
         do n=1,(nm+1)*(nm+1)
            alu(n,:,:) = transpose(az_at(tt_I))  ! 内部領域の値はそのまま
         enddo

         ! 非電気伝導体
         tz_PSI = az_at(tt_I)
         tz_DPSIDR = az_at(at_dr_at(tt_I))

         do n=1,(nm+1)*(nm+1)
            nn=nm_l(n)
            alu(n,0,:)  = tz_DPSIDR(:,0) + (nn(1)+1) * tz_PSI(:,0)/z_RAD(0)
            alu(n,km,:) = tz_DPSIDR(:,km) - nn(1) * tz_PSI(:,km)/z_RAD(km)
         enddo
         call ludecomp(alu,kp)

         deallocate(tt_I,tz_PSI,tz_DPSIDR)

         call MessageNotify('M','PolmagBoundariesGrid', 'Matrix to apply  b.c. newly produced.')
      endif

      wz_POL       = wz_wt(wt_POL)
      wz_POL(:,0)  = 0.0D0
      wz_POL(:,km) = 0.0D0
      wt_POL = lusolve(alu,kp,wz_POL)

    end subroutine wt_PolmagBoundariesGrid
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001467" class="method-detail">
        <a name="M001467"></a>

        <div class="method-heading">


          <a href="#M001467" class="method-signature">



          <span class="method-name">wt_PolmagBoundariesTau</span><span class="method-args">( wt_POL, [new] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wt_POL  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
磁場ポロイダルポテンシャルに対して境界条件を適用する. Chebyshev
空間での境界条件適用
</p>
<p>
チェビシェフ空間において境界条件を満たすべく高次の係数を定める方法を
とっている(タウ法). 現在のところ境界物質が非電気伝導体の場合のみ
対応している. その場合, 磁場ポロイダルポテンシャルの各水平スペクトル 成分 h
にたいして境界条件が与えられ,
</p>
<pre>
 * 外側境界 : dh/dr + (n+1)h/r = 0
 * 内側境界 : dh/dr - nh/r = 0
</pre>
<p>
である. ここで n は h の水平全波数である.
</p>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001467-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001467-source">
<pre>
    subroutine wt_PolmagBoundariesTau(wt_POL,new)
      !
      ! 磁場ポロイダルポテンシャルに対して境界条件を適用する.
      ! Chebyshev 空間での境界条件適用
      !
      ! チェビシェフ空間において境界条件を満たすべく高次の係数を定める方法を
      ! とっている(タウ法). 現在のところ境界物質が非電気伝導体の場合のみ
      ! 対応している. その場合, 磁場ポロイダルポテンシャルの各水平スペクトル
      ! 成分 h にたいして境界条件が与えられ,
      !
      !  * 外側境界 : dh/dr + (n+1)h/r = 0
      !  * 内側境界 : dh/dr - nh/r = 0
      !
      ! である. ここで n は h の水平全波数である. 
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)   :: wt_POL
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:,:), allocatable  :: alu
      integer, dimension(:,:), allocatable    :: kp

      real(8), dimension(:,:), allocatable    :: tt_I
      real(8), dimension(:,:), allocatable    :: tz_PSI
      real(8), dimension(:,:), allocatable    :: tz_DPSIDR

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer  :: l, n, nn(2)
      save     :: alu, kp, first

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         if ( allocated(tt_I) ) deallocate(tt_I)
         if ( allocated(tz_PSI) ) deallocate(tz_PSI)
         if ( allocated(tz_DPSIDR) ) deallocate(tz_DPSIDR)

         allocate(alu((nm+1)*(nm+1),0:lm,0:lm),kp((nm+1)*(nm+1),0:lm))
         allocate(tt_I(0:lm,0:lm),tz_PSI(0:lm,0:km),tz_DPSIDR(0:lm,0:km))

         tt_I = 0.0D0
         do l=0,lm
            tt_I(l,l)=1.0D0
         enddo
         do n=1,(nm+1)*(nm+1)
            alu(n,:,:) = tt_I
         enddo

         ! 非電気伝導体
         tz_PSI = az_at(tt_I)
         tz_DPSIDR = az_at(at_dr_at(tt_I))

         do n=1,(nm+1)*(nm+1)
            nn=nm_l(n)
            alu(n,lm-1,:) = tz_DPSIDR(:,0) + (nn(1)+1) * tz_PSI(:,0)/z_RAD(0)
            alu(n,lm,:)   = tz_DPSIDR(:,km) - nn(1) * tz_PSI(:,km)/z_RAD(km)
         enddo
         call ludecomp(alu,kp)

         deallocate(tt_I,tz_PSI,tz_DPSIDR)

         call MessageNotify('M','PolmagBoundariesTau', 'Matrix to apply  b.c. newly produced.')
      endif

      wt_POL(:,lm-1) = 0.0D0
      wt_POL(:,lm)   = 0.0D0
      wt_POL = lusolve(alu,kp,wt_POL)

    end subroutine wt_PolmagBoundariesTau
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001452" class="method-detail">
        <a name="M001452"></a>

        <div class="method-heading">


          <a href="#M001452" class="method-signature">



          <span class="method-name">wt_Potential2Rotation</span><span class="method-args">( xyz_RotVLON, xyz_RotVLAT, xyz_RotVRAD, wt_TORPOT, wt_POLPOT ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>xyz_RotVLON  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(OUT)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 回転の経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_RotVLAT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(OUT)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 回転の緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_RotVRAD  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(OUT)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 回転の動径成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) トロイダルポテンシャル

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt_POLPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ポロイダルポテンシャル

</td></tr>
</table>
</td></tr>
</table>
<p>
トロイダルポロイダルポテンシャルΨ,Φで表される非発散ベクトル場
</p>
<pre>
    v = ▽x(Ψr) + ▽x▽x(Φr)
</pre>
<p>
に対して, その回転
</p>
<pre>
    ▽xv = ▽x▽x(Ψr) + ▽x▽x▽x(Φr) = ▽x▽x(Ψr) - ▽x((▽^2Φ)r)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001452-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001452-source">
<pre>
    subroutine wt_Potential2Rotation( xyz_RotVLON,xyz_RotVLAT,xyz_RotVRAD,wt_TORPOT,wt_POLPOT)
      !
      ! トロイダルポロイダルポテンシャルΨ,Φで表される非発散ベクトル場
      !
      !     v = ▽x(Ψr) + ▽x▽x(Φr) 
      !
      ! に対して, その回転
      !
      !     ▽xv = ▽x▽x(Ψr) + ▽x▽x▽x(Φr) = ▽x▽x(Ψr) - ▽x((▽^2Φ)r)
      !
      ! を計算する. 
      
      ! ベクトル場の回転
      real(8), dimension(0:im-1,1:jm,0:km), intent(OUT) :: xyz_RotVLON
      !(out) 回転の経度成分

      real(8), dimension(0:im-1,1:jm,0:km), intent(OUT) :: xyz_RotVLAT
      !(out) 回転の緯度成分

      real(8), dimension(0:im-1,1:jm,0:km), intent(OUT) :: xyz_RotVRAD
      !(out) 回転の動径成分

      ! 入力ベクトル場を表すポテンシャル
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt_TORPOT
      !(in) トロイダルポテンシャル

      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt_POLPOT
      !(in) ポロイダルポテンシャル

      call wt_Potential2Vector( xyz_RotVLON,xyz_RotVLAT,xyz_RotVRAD, -wt_Lapla_wt(wt_POLPOT), wt_TORPOT)

    end subroutine wt_Potential2Rotation
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001451" class="method-detail">
        <a name="M001451"></a>

        <div class="method-heading">


          <a href="#M001451" class="method-signature">



          <span class="method-name">wt_Potential2Vector</span><span class="method-args">( xyz_VLON, xyz_VLAT, xyz_VRAD, wt_TORPOT, wt_POLPOT ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VLON  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VLAT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VRAD  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の動径成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) トロイダルポテンシャル

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt_POLPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ポロイダルポテンシャル

</td></tr>
</table>
</td></tr>
</table>
<p>
トロイダルポロイダルポテンシャルΨ,Φで表される非発散ベクトル場
</p>
<pre>
    v = ▽x(Ψr) + ▽x▽x(Φr)
</pre>
<p>
の各成分を計算する
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001451-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001451-source">
<pre>
    subroutine wt_Potential2Vector( xyz_VLON,xyz_VLAT,xyz_VRAD,wt_TORPOT,wt_POLPOT)
      !
      ! トロイダルポロイダルポテンシャルΨ,Φで表される非発散ベクトル場
      !
      !     v = ▽x(Ψr) + ▽x▽x(Φr) 
      !
      ! の各成分を計算する
      !
      real(8), dimension(0:im-1,1:jm,0:km)     :: xyz_VLON
      !(out) ベクトル場の経度成分

      real(8), dimension(0:im-1,1:jm,0:km)     :: xyz_VLAT
      !(out) ベクトル場の緯度成分

      real(8), dimension(0:im-1,1:jm,0:km)     :: xyz_VRAD
      !(out) ベクトル場の動径成分

      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt_TORPOT
      !(in) トロイダルポテンシャル

      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt_POLPOT
      !(in) ポロイダルポテンシャル

      xyz_VLON =   xyz_RAD * xyz_GradLat_wt(wt_TORPOT) + xya_GradLon_wa(wz_wt(wt_RotRad_wt(wt_POLPOT)))
      xyz_VLAT = - xyz_RAD * xyz_GradLon_wt(wt_TORPOT) + xya_GradLat_wa(wz_wt(wt_RotRad_wt(wt_POLPOT)))
      xyz_VRAD = xyz_wt(wt_L2_wt(wt_POLPOT))/xyz_RAD

    end subroutine wt_Potential2Vector
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001448" class="method-detail">
        <a name="M001448"></a>

        <div class="method-heading">


          <a href="#M001448" class="method-signature">



          <span class="method-name">wt_QOperator_wt</span><span class="method-args">( wt ) result(wt_QOperator_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001448">wt_QOperator_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) Q 演算子を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに対応する格子点データに演算子
</p>
<pre>
   Q=(k・▽-1/2(L2 k・▽+ k・▽L2))
</pre>
<p>
を作用させたデータのスペクトル変換が返される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001448-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001448-source">
<pre>
    function wt_QOperator_wt(wt)
      !
      ! 入力スペクトルデータに対応する格子点データに演算子 
      !
      !    Q=(k・▽-1/2(L2 k・▽+ k・▽L2)) 
      !
      ! を作用させたデータのスペクトル変換が返される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wt_QOperator_wt
      !(out) Q 演算子を作用された 2 次元スペクトルデータ

      wt_QOperator_wt = wt_xyz(xyz_KGrad_wt(wt) - xyz_KGrad_wt(wt_L2_wt(wt))/2) - wt_L2_wt(wt_xyz(xyz_KGrad_wt(wt)))/2

    end function wt_QOperator_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001450" class="method-detail">
        <a name="M001450"></a>

        <div class="method-heading">


          <a href="#M001450" class="method-signature">



          <span class="method-name">wt_RadRotRot_xyz_xyz_xyz</span><span class="method-args">( xyz_VLON, xyz_VLAT, xyz_VRAD ) result(wt_RadRotRot_xyz_xyz_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001450">wt_RadRotRot_xyz_xyz_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル v の r・(▽×▽×v)

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VLON  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトルの経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VLAT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトルの緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VRAD  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトルの動径成分

</td></tr>
</table>
</td></tr>
</table>
<p>
ベクトル v に対して r・(▽×▽×v) を計算する.
</p>
<p>
第 1, 2, 3 引数(v[λ], v[φ], v[r])がそれぞれベクトルの経度成分, 緯度成分,
動径成分を表す.
</p>
<pre>
   r・(▽×▽×v)  = 1/r ∂/∂r (r・( 1/cosφ・∂v[λ]/∂λ
                                 + 1/cosφ・∂(v[φ] cosφ)/∂φ ) )
                    + L^2 v[r]/r
</pre>
<p>
のスペクトルデータが返される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001450-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001450-source">
<pre>
    function wt_RadRotRot_xyz_xyz_xyz(xyz_VLON,xyz_VLAT,xyz_VRAD) 
      ! 
      ! ベクトル v に対して r・(▽×▽×v) を計算する.
      !
      ! 第 1, 2, 3 引数(v[λ], v[φ], v[r])がそれぞれベクトルの経度成分, 
      ! 緯度成分, 動径成分を表す. 
      !
      !    r・(▽×▽×v)  = 1/r ∂/∂r (r・( 1/cosφ・∂v[λ]/∂λ 
      !                                  + 1/cosφ・∂(v[φ] cosφ)/∂φ ) ) 
      !                     + L^2 v[r]/r 
      !
      ! のスペクトルデータが返される.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz_VLON
      !(in) ベクトルの経度成分

      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz_VLAT
      !(in) ベクトルの緯度成分

      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz_VRAD
      !(in) ベクトルの動径成分

      real(8), dimension((nm+1)*(nm+1),0:lm)     :: wt_RadRotRot_xyz_xyz_xyz
      !(out) ベクトル v の r・(▽×▽×v) 

      wt_RadRotRot_xyz_xyz_xyz = wt_RotRad_wt(wt_wz( (wa_DivLon_xya(xyz_VLON)+ wa_DivLat_xya(xyz_VLAT)))) + wt_L2_wt(wt_xyz(xyz_VRAD/xyz_RAD))

    end function wt_RadRotRot_xyz_xyz_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001449" class="method-detail">
        <a name="M001449"></a>

        <div class="method-heading">


          <a href="#M001449" class="method-signature">



          <span class="method-name">wt_RadRot_xyz_xyz</span><span class="method-args">( xyz_VLON, xyz_VLAT ) result(wt_RadRot_xyz_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001449">wt_RadRot_xyz_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトルの渦度と動径ベクトルの内積

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VLON  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトルの経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VLAT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトルの緯度成分

</td></tr>
</table>
</td></tr>
</table>
<p>
r・(▽×v)
</p>
<p>
ベクトルの渦度と動径ベクトルの内積 r・(▽×v) を計算する.
</p>
<p>
第 1, 2 引数(v[λ], v[φ])がそれぞれベクトルの経度成分, 緯度成分を表す.
</p>
<pre>
   r・(▽×v) = 1/cosφ・∂v[φ]/∂λ - 1/cosφ・∂(v[λ] cosφ)/∂φ
</pre>
<p>
のスペクトル データが返される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001449-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001449-source">
<pre>
    function wt_RadRot_xyz_xyz(xyz_VLON,xyz_VLAT)  ! r・(▽×v)
      !
      ! ベクトルの渦度と動径ベクトルの内積 r・(▽×v) を計算する.
      !
      ! 第 1, 2 引数(v[λ], v[φ])がそれぞれベクトルの経度成分, 緯度成分を表す.
      !
      !    r・(▽×v) = 1/cosφ・∂v[φ]/∂λ - 1/cosφ・∂(v[λ] cosφ)/∂φ
      !
      ! のスペクトル データが返される.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz_VLON
      !(in) ベクトルの経度成分

      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz_VLAT
      !(in) ベクトルの緯度成分

      real(8), dimension((nm+1)*(nm+1),0:lm)     :: wt_RadRot_xyz_xyz
      !(out) ベクトルの渦度と動径ベクトルの内積

      wt_RadRot_xyz_xyz = wt_wz(wa_DivLon_xya(xyz_VLAT) - wa_DivLat_xya(xyz_VLON))
      
    end function wt_RadRot_xyz_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001405" class="method-detail">
        <a name="M001405"></a>

        <div class="method-heading">


          <a href="#M001405" class="method-signature">



          <span class="method-name">wt_RotRad_wt</span><span class="method-args">( wt ) result(wt_RotRad_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001405">wt_RotRad_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 回転型動径微分を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
入力スペクトルデータに回転型動径微分
</p>
<pre>
     1/r ∂(r.)/∂r = ∂(.)/∂r + (.)/r
</pre>
<p>
を作用する.
</p>
<p>
スペクトルデータの回転型動径微分とは, 対応する格子点データに
回転型動径微分を作用させたデータのスペクトル変換のことである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001405-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001405-source">
<pre>
    function wt_RotRad_wt(wt)
      !
      ! 入力スペクトルデータに回転型動径微分
      !
      !      1/r ∂(r.)/∂r = ∂(.)/∂r + (.)/r
      !
      ! を作用する.
      !
      ! スペクトルデータの回転型動径微分とは, 対応する格子点データに
      ! 回転型動径微分を作用させたデータのスペクトル変換のことである. 
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wt_RotRad_wt
      !(out) 回転型動径微分を作用された 2 次元スペクトルデータ

      wt_RotRad_wt = wt_Drad_wt(wt) + wt_wz(1/wz_Rad*wz_wt(wt))

    end function wt_RotRad_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001415" class="method-detail">
        <a name="M001415"></a>

        <div class="method-heading">


          <a href="#M001415" class="method-signature">



          <span class="method-name">wt_RotRad_xyz_xyz</span><span class="method-args">( xyz_Vlat, xyz_Vlon ) result(wt_RotRad_xyz_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001415">wt_RotRad_xyz_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の回転の動径成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_Vlat  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_Vlon  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の経度成分

</td></tr>
</table>
</td></tr>
</table>
<p>
ベクトルの緯度成分, 経度成分である第 1, 2 引数 Vlat, Vlon に対して
ベクトル場の回転の動径成分
</p>
<pre>
   1/rcosφ・∂Vlat/∂λ - 1/rcosφ・∂(Vlon cosφ)/∂φ
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001415-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001415-source">
<pre>
    function wt_RotRad_xyz_xyz(xyz_Vlat,xyz_Vlon) 
      !
      ! ベクトルの緯度成分, 経度成分である第 1, 2 引数 Vlat, Vlon に対して
      ! ベクトル場の回転の動径成分 
      !
      !    1/rcosφ・∂Vlat/∂λ - 1/rcosφ・∂(Vlon cosφ)/∂φ
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz_Vlat
      !(in) ベクトル場の緯度成分

      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz_Vlon
      !(in) ベクトル場の経度成分

      real(8), dimension((nm+1)*(nm+1),0:lm)     :: wt_RotRad_xyz_xyz
      !(out) ベクトル場の回転の動径成分

        wt_RotRad_xyz_xyz =   wt_DivLon_xyz(xyz_Vlat) - wt_DivLat_xyz(xyz_Vlon)

    end function wt_RotRad_xyz_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001470" class="method-detail">
        <a name="M001470"></a>

        <div class="method-heading">




          <span class="method-name">wt_TorBoundaries</span><span class="method-args">( wt_TORPOT, [values], [cond], [new] ) </span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wt_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 両端境界でのトロイダルポテンシャル

<pre>
    粘着条件の時のみ有効
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件スイッチ. 省略時は &#8216;RR&#8216;

<pre>
    RR    : 両端粘着条件
    RF    : 上端粘着, 下端応力なし条件
    FR    : 上端応力なし, 下端粘着条件
    FF    : 両端応力なし条件
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
速度トロイダルポテンシャルに対して境界条件を適用する. Chebyshev
空間での境界条件適用.
</p>
<p>
速度トロイダルポテンシャルΨに対して与えられる境界条件は
</p>
<pre>
  * 粘着条件 : Ψ = Ψb(lon,lat). Ψb は境界球面での速度分布.
                                  default は 0(静止状態).

  * 応力なし条件 : ∂(Ψ/r)/∂r = 0.
</pre>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>
<p>
Alias for <a href="wt_module.html#M001461">wt_TorBoundariesTau</a>
</p>


        </div>
      </div>


      <div id="method-M001462" class="method-detail">
        <a name="M001462"></a>

        <div class="method-heading">


          <a href="#M001462" class="method-signature">



          <span class="method-name">wt_TorBoundariesGrid</span><span class="method-args">( wt_TORPOT, [values], [cond], [new] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wt_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 両端境界でのトロイダルポテンシャル

<pre>
    粘着条件の時のみ有効
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件スイッチ. 省略時は &#8216;RR&#8216;

<pre>
    RR    : 両端粘着条件
    RF    : 上端粘着, 下端応力なし条件
    FR    : 上端応力なし, 下端粘着条件
    FF    : 両端応力なし条件
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
速度トロイダルポテンシャルに対して境界条件を適用する.
実空間での境界条件適用
</p>
<p>
鉛直実格子点空間において内部領域の値と境界条件を満たすように
条件を課している(選点法). このルーチンを用いるためには <a
href="wt_module.html#M001396">wt_Initial</a>
にて設定するチェビシェフ切断波数(lm)と鉛直格子点数(km)を
等しくしておく必要がある.
</p>
<p>
速度トロイダルポテンシャルΨに対して与えられる境界条件は
</p>
<pre>
  * 粘着条件 : Ψ = Ψb(lon,lat). Ψb は境界球面での速度分布.
                                  default は 0 (静止状態).

  * 応力なし条件 : ∂(Ψ/r)/∂r = 0.
</pre>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001462-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001462-source">
<pre>
    subroutine wt_TorBoundariesGrid(wt_TORPOT,values,cond,new) 
      !
      ! 速度トロイダルポテンシャルに対して境界条件を適用する.
      ! 実空間での境界条件適用
      !
      ! 鉛直実格子点空間において内部領域の値と境界条件を満たすように
      ! 条件を課している(選点法). このルーチンを用いるためには 
      ! wt_Initial にて設定するチェビシェフ切断波数(lm)と鉛直格子点数(km)を
      ! 等しくしておく必要がある. 
      !
      ! 速度トロイダルポテンシャルΨに対して与えられる境界条件は
      !
      !   * 粘着条件 : Ψ = Ψb(lon,lat). Ψb は境界球面での速度分布. 
      !                                   default は 0 (静止状態).
      !
      !   * 応力なし条件 : ∂(Ψ/r)/∂r = 0.
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)      :: wt_TORPOT
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      real(8), dimension((nm+1)*(nm+1),2), intent(in), optional :: values
              !(in) 両端境界でのトロイダルポテンシャル
              !     粘着条件の時のみ有効

      character(len=2), intent(in), optional  :: cond
              !(in) 境界条件スイッチ. 省略時は 'RR'
              !     RR    : 両端粘着条件
              !     RF    : 上端粘着, 下端応力なし条件
              !     FR    : 上端応力なし, 下端粘着条件
              !     FF    : 両端応力なし条件

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension((nm+1)*(nm+1),0:km):: wz_TORPOT
      real(8), dimension(:,:), allocatable  :: alu
      integer, dimension(:), allocatable    :: kp
      real(8), dimension(0:lm,0:lm)         :: tt_data
      real(8), dimension(0:lm,0:km)         :: tz_data
      logical                               :: rigid1, rigid2   ! 境界条件

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer :: l
      save    :: alu, kp, first

      if (.not. present(cond)) then
         rigid1=.TRUE. 
          rigid2=.TRUE.
      else
         select case (cond)
         case ('RR')
            rigid1 = .TRUE.  
             rigid2 = .TRUE.
         case ('RF')
            rigid1 = .TRUE.  
             rigid2 = .FALSE.
         case ('FR')
            rigid1 = .FALSE. 
             rigid2 = .TRUE.
         case ('FF')
            rigid1 = .FALSE. 
             rigid2 = .FALSE.
         case default
            call MessageNotify('E','wt_TorBoundariesGrid','B.C. not supported')
         end select
      endif

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( lm /= km ) then
            call MessageNotify('E','TorBoundariesGrid', 'Chebyshev truncation and number of grid points should be same.')
         endif

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         allocate(alu(0:km,0:lm),kp(0:lm))

         tt_data = 0.0D0
         do l=0,lm
            tt_data(l,l)=1.0D0
         enddo
         tz_data = az_at(tt_data)
         alu = transpose(tz_data)       ! 内部領域での値はそのまま

         if ( rigid1 ) then
            tz_data = az_at(tt_data)
         else
            tz_data = az_at(at_dr_at(at_az( az_at(tt_data)/spread(z_rad,1,lm+1))))
         endif
         alu(0,:) = tz_data(:,0)        ! 境界 k=0 での条件式代入

         if ( rigid2 ) then
            tz_data = az_at(tt_data)
         else
            tz_data = az_at(at_dr_at(at_az( az_at(tt_data)/spread(z_rad,1,lm+1))))
         endif
         alu(km,:)   = tz_data(:,km)    ! 境界 k=km での条件式代入

         call ludecomp(alu,kp)

         if ( rigid1 .AND. present(values) ) then 
            call MessageNotify('M','wt_TorBoundariesGrid', 'Toroidal potential at k=0 was given by the optional variable.')
         else if ( rigid1 .AND. (.NOT.present(values)) ) then
            call MessageNotify('M','wt_TorBoundariesGrid', 'Toroidal potential at k=0 was set to zero.')
         else if ( (.NOT. rigid1) .AND. present(values) ) then
            call MessageNotify('W','wt_TorBoundariesGrid', 'Boundary value at k=0 cannot be set under stress-free condition.')
         endif

         if ( rigid2 .AND. present(values) ) then 
            call MessageNotify('M','wt_TorBoundariesGrid', 'Toroidal potential at k=km was given by the optional variable.')
         else if ( rigid2 .AND. (.NOT.present(values)) ) then
            call MessageNotify('M','wt_TorBoundariesGrid', 'Toroidal potential at k=km was set to zero.')
         else if ( (.NOT. rigid2) .AND. present(values) ) then
            call MessageNotify('W','wt_TorBoundariesGrid', 'Boundary value at k=km cannot be set under stress-free condition.')
         endif

         call MessageNotify('M','wt_TorBoundariesGrid', 'Matrix to apply  b.c. newly produced.')
      endif

      wz_TorPot       = wz_wt(wt_TorPot)

      if ( rigid1 .AND. present(values) ) then
         wz_TorPot(:,0)  = values(:,1)
      else
         wz_TorPot(:,0)  = 0.0D0
      endif

      if ( rigid2 .AND. present(values) ) then
         wz_TorPot(:,km) = values(:,2)
      else
         wz_TorPot(:,km) = 0.0D0
      endif

      wt_torpot = lusolve(alu,kp,wz_TorPot)

    end subroutine wt_TorBoundariesGrid
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001461" class="method-detail">
        <a name="M001461"></a>

        <div class="method-heading">


          <a href="#M001461" class="method-signature">



          <span class="method-name">wt_TorBoundariesTau</span><span class="method-args">( wt_TORPOT, [values], [cond], [new] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wt_TORPOT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>values  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 両端境界でのトロイダルポテンシャル

<pre>
    粘着条件の時のみ有効
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件スイッチ. 省略時は &#8216;RR&#8216;

<pre>
    RR    : 両端粘着条件
    RF    : 上端粘着, 下端応力なし条件
    FR    : 上端応力なし, 下端粘着条件
    FF    : 両端応力なし条件
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
速度トロイダルポテンシャルに対して境界条件を適用する. Chebyshev
空間での境界条件適用.
</p>
<p>
速度トロイダルポテンシャルΨに対して与えられる境界条件は
</p>
<pre>
  * 粘着条件 : Ψ = Ψb(lon,lat). Ψb は境界球面での速度分布.
                                  default は 0(静止状態).

  * 応力なし条件 : ∂(Ψ/r)/∂r = 0.
</pre>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001461-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001461-source">
<pre>
    subroutine wt_TorBoundariesTau(wt_TORPOT,values,cond,new) 
      !
      ! 速度トロイダルポテンシャルに対して境界条件を適用する. 
      ! Chebyshev 空間での境界条件適用. 
      !
      ! 速度トロイダルポテンシャルΨに対して与えられる境界条件は
      !
      !   * 粘着条件 : Ψ = Ψb(lon,lat). Ψb は境界球面での速度分布. 
      !                                   default は 0(静止状態).
      !
      !   * 応力なし条件 : ∂(Ψ/r)/∂r = 0.
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)      :: wt_TORPOT
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      real(8), dimension((nm+1)*(nm+1),2), intent(in), optional :: values
              !(in) 両端境界でのトロイダルポテンシャル
              !     粘着条件の時のみ有効

      character(len=2), intent(in), optional  :: cond
              !(in) 境界条件スイッチ. 省略時は 'RR'
              !     RR    : 両端粘着条件
              !     RF    : 上端粘着, 下端応力なし条件
              !     FR    : 上端応力なし, 下端粘着条件
              !     FF    : 両端応力なし条件

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:), allocatable  :: alu
      integer, dimension(:), allocatable    :: kp
      real(8), dimension(0:lm,0:lm)         :: tt_data
      real(8), dimension(0:lm,0:km)         :: tg_data
      logical                               :: rigid1, rigid2   ! 境界条件

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer :: l
      save    :: alu, kp, first

      if (.not. present(cond)) then
         rigid1=.TRUE. 
          rigid2=.TRUE.
      else
         select case (cond)
         case ('RR')
            rigid1 = .TRUE.  
             rigid2 = .TRUE.
         case ('RF')
            rigid1 = .TRUE.  
             rigid2 = .FALSE.
         case ('FR')
            rigid1 = .FALSE. 
             rigid2 = .TRUE.
         case ('FF')
            rigid1 = .FALSE. 
             rigid2 = .FALSE.
         case default
            call MessageNotify('E','wt_TorBoundariesTau','B.C. not supported')
         end select
      endif

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         allocate(alu(0:lm,0:lm),kp(0:lm))

         tt_data = 0.0D0
         do l=0,lm
            tt_data(l,l)=1
         enddo
         alu = tt_data

         ! 力学的条件粘着条件 
         if ( rigid1 ) then
            tg_data = az_at(tt_data)
         else
            tg_data = az_at(at_dr_at(at_az( az_at(tt_data)/spread(z_rad,1,lm+1))))
         endif
         alu(lm-1,:) = tg_data(:,0)       ! 境界 k=0 での条件式代入

         if ( rigid2 ) then
            tg_data = az_at(tt_data)    
         else
            tg_data = az_at(at_dr_at(at_az( az_at(tt_data)/spread(z_rad,1,lm+1))))
         endif
         alu(lm,:)   = tg_data(:,km)      ! 境界 k=km での条件式代入

         call ludecomp(alu,kp)

         if ( rigid1 .AND. present(values) ) then 
            call MessageNotify('M','wt_TorBoundariesTau', 'Toroidal potential at k=0 was given by the optional variable.')
         else if ( rigid1 .AND. (.NOT.present(values)) ) then
            call MessageNotify('M','wt_TorBoundariesTau', 'Toroidal potential at k=0 was set to zero.')
         else if ( (.NOT. rigid1) .AND. present(values) ) then
            call MessageNotify('W','wt_TorBoundariesTau', 'Boundary value k=0 cannot be set under stress-free condition.')
         endif

         if ( rigid2 .AND. present(values) ) then 
            call MessageNotify('M','wt_TorBoundariesTau', 'Toroidal potential at k=0 was given by the optional variable.')
         else if ( rigid2 .AND. (.NOT.present(values)) ) then
            call MessageNotify('M','wt_TorBoundariesTau', 'Toroidal potential at k=0 was set to zero.')
         else if ( (.NOT. rigid2) .AND. present(values) ) then
            call MessageNotify('W','wt_TorBoundariesTau', 'Boundary value k=0 cannot be set under stress-free condition.')
         endif

         call MessageNotify('M','wt_TorBoundariesTau', 'Matrix to apply  b.c. newly produced.')
      endif

      if ( rigid1 .AND. present(values) ) then
         wt_torpot(:,lm-1) = values(:,1)
      else
         wt_torpot(:,lm-1) = 0.0D0
      endif
      if ( rigid2 .AND. present(values) ) then
         wt_torpot(:,lm)   = values(:,2)
      else
         wt_torpot(:,lm) = 0.0D0
      endif

      wt_torpot = lusolve(alu,kp,wt_TORPOT)

    end subroutine wt_TorBoundariesTau
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001471" class="method-detail">
        <a name="M001471"></a>

        <div class="method-heading">




          <span class="method-name">wt_TorMagBoundaries</span><span class="method-args">( wt_TOR, [new] ) </span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wt_TOR  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
Alias for <a href="wt_module.html#M001465">wt_TorMagBoundariesTau</a>
</p>


        </div>
      </div>


      <div id="method-M001466" class="method-detail">
        <a name="M001466"></a>

        <div class="method-heading">


          <a href="#M001466" class="method-signature">



          <span class="method-name">wt_TormagBoundariesGrid</span><span class="method-args">( wt_TOR, [new] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wt_TOR  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
磁場トロイダルポテンシャルに対して境界条件を適用する.
鉛直実空間での境界条件適用.
</p>
<p>
鉛直実格子点空間において内部領域の値と境界条件を満たすように
条件を課している(選点法). このルーチンを用いるためには <a
href="wt_module.html#M001396">wt_Initial</a>
にて設定するチェビシェフ切断波数(lm)と鉛直格子点数(km)を
等しくしておく必要がある.
</p>
<p>
現在のところ境界物質が非電気伝導体の場合のみ対応している. その場合,
磁場トロイダルポテンシャルの境界条件は
</p>
<p>
外側
</p>
<pre>
   wt_psi = 0   at the outer boundary
</pre>
<p>
内側
</p>
<pre>
   wt_psi = 0       at the inner boundary
</pre>
<p>
であるので <a href="wt_module.html#M001469">wt_Boundaries</a>
で対応可能だが, 将来のため別途作成しておく
</p>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001466-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001466-source">
<pre>
    subroutine wt_TormagBoundariesGrid(wt_TOR,new)
      !
      ! 磁場トロイダルポテンシャルに対して境界条件を適用する.
      ! 鉛直実空間での境界条件適用.
      !
      ! 鉛直実格子点空間において内部領域の値と境界条件を満たすように
      ! 条件を課している(選点法). このルーチンを用いるためには 
      ! wt_Initial にて設定するチェビシェフ切断波数(lm)と鉛直格子点数(km)を
      ! 等しくしておく必要がある. 
      !
      ! 現在のところ境界物質が非電気伝導体の場合のみ対応している. 
      ! その場合, 磁場トロイダルポテンシャルの境界条件は
      !
      ! 外側
      !    wt_psi = 0   at the outer boundary
      ! 内側
      !    wt_psi = 0       at the inner boundary
      ! 
      ! であるので wt_Boundaries で対応可能だが, 将来のため別途作成しておく
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)   :: wt_TOR
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:,:), allocatable  :: alu
      integer, dimension(:,:), allocatable    :: kp

      real(8), dimension(:,:), allocatable    :: tt_I
      real(8), dimension(:,:), allocatable    :: tz_PSI
      real(8), dimension((nm+1)*(nm+1),0:km)  :: wz_TOR

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer  :: l, n
      save     :: alu, kp, first

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( lm /= km ) then
            call MessageNotify('E','TorMagBoundariesGrid', 'Chebyshev truncation and number of grid points should be same.')
         endif

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         if ( allocated(tt_I) ) deallocate(tt_I)
         if ( allocated(tz_PSI) ) deallocate(tz_PSI)
         allocate(alu((nm+1)*(nm+1),0:km,0:lm),kp((nm+1)*(nm+1),0:lm))
         allocate(tt_I(0:lm,0:lm),tz_PSI(0:lm,0:km))

         tt_I = 0.0D0
         do l=0,lm
            tt_I(l,l)=1.0D0
         enddo
         do n=1,(nm+1)*(nm+1)
            alu(n,:,:) = transpose(az_at(tt_I))   ! 内部領域は値そのまま.
         enddo

         ! 非電気伝導体
         tz_PSI = az_at(tt_I)

         do n=1,(nm+1)*(nm+1)
            alu(n,0,:) = tz_PSI(:,0)
            alu(n,km,:)   = tz_PSI(:,km)
         enddo
         call ludecomp(alu,kp)

         deallocate(tt_I,tz_PSI)

         call MessageNotify('M','TormagBoundariesGrid', 'Matrix to apply  b.c. newly produced.')
      endif
      
      wz_TOR       = wz_wt(wt_TOR)
      wz_TOR(:,0)  = 0.0D0
      wz_TOR(:,km) = 0.0D0
      wt_TOR = lusolve(alu,kp,wz_TOR)

    end subroutine wt_TormagBoundariesGrid
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001465" class="method-detail">
        <a name="M001465"></a>

        <div class="method-heading">


          <a href="#M001465" class="method-signature">



          <span class="method-name">wt_TormagBoundariesTau</span><span class="method-args">( wt_TOR, [new] ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>wt_TOR  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)</tt>

<table>
<tr><td valign="top"> :</td><td> (inout) 境界条件を適用するデータ. 修正された値を返す.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001465-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001465-source">
<pre>
    subroutine wt_TormagBoundariesTau(wt_TOR,new)
      
      ! 磁場トロイダルポテンシャルに対して境界条件を適用する.
      ! Chebyshev 空間での境界条件適用
      !
      ! チェビシェフ空間において境界条件を満たすべく高次の係数を定める方法を
      ! とっている(タウ法). 現在のところ境界物質が非電気伝導体の場合のみ
      ! 対応している. その場合, 磁場トロイダルポテンシャルの境界条件は
      !
      ! 外側
      !    wt_psi = 0   at the outer boundary
      ! 内側
      !    wt_psi = 0       at the inner boundary
      ! 
      ! であるから wt_Boundaries で対応可能だが, 将来のため別途作成しておく.
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm),intent(inout)   :: wt_TOR
              !(inout) 境界条件を適用するデータ. 修正された値を返す. 

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:,:), allocatable  :: alu
      integer, dimension(:,:), allocatable    :: kp

      real(8), dimension(:,:), allocatable    :: tt_I
      real(8), dimension(:,:), allocatable    :: tz_PSI

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer  :: l, n
      save     :: alu, kp, first

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         if ( allocated(tt_I) ) deallocate(tt_I)
         if ( allocated(tz_PSI) ) deallocate(tz_PSI)
         allocate(alu((nm+1)*(nm+1),0:lm,0:lm),kp((nm+1)*(nm+1),0:lm))
         allocate(tt_I(0:lm,0:lm),tz_PSI(0:lm,0:km))

         tt_I = 0.0D0
         do l=0,lm
            tt_I(l,l)=1.0D0
         enddo
         do n=1,(nm+1)*(nm+1)
            alu(n,:,:) = tt_I
         enddo

         ! 非電気伝導体
         tz_PSI = az_at(tt_I)

         do n=1,(nm+1)*(nm+1)
            alu(n,lm-1,:) = tz_PSI(:,0)
            alu(n,lm,:)   = tz_PSI(:,km)
         enddo
         call ludecomp(alu,kp)

         deallocate(tt_I,tz_PSI)

         call MessageNotify('M','TormagBoundariesTau', 'Matrix to apply  b.c. newly produced.')
      endif

      wt_TOR(:,lm-1) = 0.0D0
      wt_TOR(:,lm)   = 0.0D0
      wt_TOR = lusolve(alu,kp,wt_TOR)

    end subroutine wt_TormagBoundariesTau
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001453" class="method-detail">
        <a name="M001453"></a>

        <div class="method-heading">


          <a href="#M001453" class="method-signature">



          <span class="method-name">wt_VGradV</span><span class="method-args">( xyz_VGRADV_LON, xyz_VGRADV_LAT, xyz_VGRADV_RAD, xyz_VLON, xyz_VLAT, xyz_VRAD ) </span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Subroutine </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VGRADV_LON  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km),intent(out)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) (v・▽v) 経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VGRADV_LAT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km),intent(out)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) (v・▽v) 緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VGRADV_RAD  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km),intent(out)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) (v・▽v) 動径成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VLON  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場 v の経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VLAT  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場 v の緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_VRAD  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場 v の動径成分

</td></tr>
</table>
</td></tr>
</table>
<p>
ベクトル場の v・▽v を計算する.
</p>
<p>
ベクトル場 v=(v[λ],v[φ],v[r]) に対するv・▽vの各成分は
次のように計算される.
</p>
<pre>
  (v・▽v)[λ] = ▽・(v[λ]v) + v[λ]v[r]/r - v[λ]v[φ]tan(φ)/r
  (v・▽v)[φ] = ▽・(v[φ]v) + v[φ]v[r]/r - v[λ]^2tan(φ)/r
  (v・▽v)[r] = ▽・(v[r]v) + (v[λ]^2+v[φ]^2)/r
</pre>
<p>
非発散速度場に対してはポテンシャルから <a
href="wt_module.html#M001452">wt_Potential2Rotation</a> を
用いて回転を計算し, 恒等式 v・▽v = ▽(v[2^/2) - vx▽xv を
用いる方がよいだろう.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001453-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001453-source">
<pre>
    subroutine wt_VGradV(xyz_VGRADV_LON,xyz_VGRADV_LAT,xyz_VGRADV_RAD, xyz_VLON,xyz_VLAT,xyz_VRAD )
      !
      ! ベクトル場の v・▽v を計算する.
      !
      ! ベクトル場 v=(v[λ],v[φ],v[r]) に対するv・▽vの各成分は
      ! 次のように計算される.
      !
      !   (v・▽v)[λ] = ▽・(v[λ]v) + v[λ]v[r]/r - v[λ]v[φ]tan(φ)/r
      !   (v・▽v)[φ] = ▽・(v[φ]v) + v[φ]v[r]/r - v[λ]^2tan(φ)/r
      !   (v・▽v)[r] = ▽・(v[r]v) + (v[λ]^2+v[φ]^2)/r
      !
      ! 非発散速度場に対してはポテンシャルから wt_Potential2Rotation を
      ! 用いて回転を計算し, 恒等式 v・▽v = ▽(v[2^/2) - vx▽xv を
      ! 用いる方がよいだろう.
      !
      real(8), dimension(0:im-1,1:jm,0:km),intent(out)   :: xyz_VGRADV_LON
      !(out) (v・▽v) 経度成分

      real(8), dimension(0:im-1,1:jm,0:km),intent(out)   :: xyz_VGRADV_LAT
      !(out) (v・▽v) 緯度成分

      real(8), dimension(0:im-1,1:jm,0:km),intent(out)   :: xyz_VGRADV_RAD
      !(out) (v・▽v) 動径成分

      real(8), dimension(0:im-1,1:jm,0:km),intent(in)    :: xyz_VLON
      !(in) ベクトル場 v の経度成分

      real(8), dimension(0:im-1,1:jm,0:km),intent(in)    :: xyz_VLAT
      !(in) ベクトル場 v の緯度成分

      real(8), dimension(0:im-1,1:jm,0:km),intent(in)    :: xyz_VRAD
      !(in) ベクトル場 v の動径成分

      xyz_VGRADV_LON = xyz_Div_xyz_xyz_xyz( xyz_VLON * xyz_VLON, xyz_VLON*xyz_VLAT, xyz_VLON*xyz_VRAD ) + xyz_VLON*xyz_VRAD/xyz_RAD - xyz_VLON*xyz_VLAT*tan(xyz_LAT)/xyz_RAD 

      xyz_VGRADV_LAT = xyz_Div_xyz_xyz_xyz( xyz_VLAT*xyz_VLON, xyz_VLAT*xyz_VLAT, xyz_VLAT*xyz_VRAD ) + xyz_VLAT*xyz_VRAD/xyz_RAD + xyz_VLON**2*tan(xyz_LAT)/xyz_RAD 

      xyz_VGRADV_RAD = xyz_Div_xyz_xyz_xyz( xyz_VRAD*xyz_VLON, xyz_VRAD*xyz_VLAT, xyz_VRAD*xyz_VRAD ) - (xyz_VLON**2 + xyz_VLAT**2)/xyz_RAD 

    end subroutine wt_VGradV
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001395" class="method-detail">
        <a name="M001395"></a>

        <div class="method-heading">




          <span class="method-name">wt_VMiss</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001395">wt_VMiss</a>  </tt></b>  <tt> = -999.0        </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> 欠損値

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001402" class="method-detail">
        <a name="M001402"></a>

        <div class="method-heading">


          <a href="#M001402" class="method-signature">



          <span class="method-name">wt_wz</span><span class="method-args">( wz ) result(wt_wz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001402">wt_wz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数スペクトル・動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
水平スペクトル・動径格子点データからスペクトルデータへ(正)変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001402-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001402-source">
<pre>
    function wt_wz(wz)
      !
      ! 水平スペクトル・動径格子点データからスペクトルデータへ(正)変換する.
      !
      real(8), dimension((nm+1)*(nm+1),0:km), intent(in) :: wz
      !(in) 2 次元球面調和函数スペクトル・動径格子点データ
      real(8), dimension((nm+1)*(nm+1),0:lm)             :: wt_wz
      !(out) 2 次元球面調和函数チェビシェフスペクトルデータ

      wt_wz = at_az(wz)

    end function wt_wz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001398" class="method-detail">
        <a name="M001398"></a>

        <div class="method-heading">


          <a href="#M001398" class="method-signature">



          <span class="method-name">wt_xyz</span><span class="method-args">( xyz ) result(wt_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001398">wt_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
3 次元格子点データからスペクトルデータへ(正)変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001398-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001398-source">
<pre>
    function wt_xyz(xyz)
      !
      ! 3 次元格子点データからスペクトルデータへ(正)変換する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ
      real(8), dimension((nm+1)*(nm+1),0:lm)           :: wt_xyz
      !(out) 2 次元球面調和函数チェビシェフスペクトルデータ

      wt_xyz = wt_wz(wa_xya(xyz))

    end function wt_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001463" class="method-detail">
        <a name="M001463"></a>

        <div class="method-heading">


          <a href="#M001463" class="method-signature">



          <span class="method-name">wz_LaplaPol2Pol_wz</span><span class="method-args">( wz, [cond], [new] ) result(wz_LaplaPol2Pol_wz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001463">wz_LaplaPol2Pol_wz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 出力ポロイダルポテンシャル分布

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:km),intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 入力▽^2φ分布

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>cond  </tt></b>  <tt> </tt> :</td><td><tt>character(len=2), intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 境界条件スイッチ. 省略時は &#8216;RR&#8216;

<pre>
    RR    : 両端粘着条件
    RF    : 上端粘着, 下端応力なし条件
    FR    : 上端応力なし, 下端粘着条件
    FF    : 両端応力なし条件
</pre>
</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>new  </tt></b>  <tt> </tt> :</td><td><tt>logical, intent(IN), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) true だと境界条件計算用行列を強制的に新たに作る.

<pre>
    default は false.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
速度ポロイダルポテンシャルΦを▽^2Φから計算する.
</p>
<p>
チェビシェフ格子点空間で境界条件を適用している. この関数を用いるためには <a
href="wt_module.html#M001396">wt_Initial</a> にて設定する
チェビシェフ切断波数(lm)と鉛直格子点数(km)を等しく しておく必要がある.
</p>
<p>
速度ポロイダルポテンシャルΦを f = ▽^2Φから定める式は
</p>
<pre>
  ▽^2Φ = f
    Φ = const. at boundaries.
    ∂Φ/∂r = 0 at boundaries           (粘着条件)
    or ∂^2Φ/∂r^2 = 0 at boundaries    (応力なし条件)
</pre>
<p>
最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001463-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001463-source">
<pre>
    function wz_LaplaPol2Pol_wz(wz,cond,new)
      !
      ! 速度ポロイダルポテンシャルΦを▽^2Φから計算する.
      !
      ! チェビシェフ格子点空間で境界条件を適用している. 
      ! この関数を用いるためには wt_Initial にて設定する
      ! チェビシェフ切断波数(lm)と鉛直格子点数(km)を等しく
      ! しておく必要がある. 
      !
      ! 速度ポロイダルポテンシャルΦを f = ▽^2Φから定める式は
      !
      !   ▽^2Φ = f
      !     Φ = const. at boundaries.
      !     ∂Φ/∂r = 0 at boundaries           (粘着条件) 
      !     or ∂^2Φ/∂r^2 = 0 at boundaries    (応力なし条件)
      !
      ! 最初に呼ばれるときはオプショナル引数 new に関係なく行列が設定される.
      !
      real(8), dimension((nm+1)*(nm+1),0:km),intent(in)  :: wz
              !(in) 入力▽^2φ分布

      real(8), dimension((nm+1)*(nm+1),0:km)             :: wz_LaplaPol2Pol_wz
              !(out) 出力ポロイダルポテンシャル分布

      character(len=2), intent(in), optional  :: cond
              !(in) 境界条件スイッチ. 省略時は 'RR'
              !     RR    : 両端粘着条件
              !     RF    : 上端粘着, 下端応力なし条件
              !     FR    : 上端応力なし, 下端粘着条件
              !     FF    : 両端応力なし条件

      logical, intent(IN), optional :: new
              !(in) true だと境界条件計算用行列を強制的に新たに作る.
              !     default は false.

      real(8), dimension(:,:,:), allocatable  :: alu
      integer, dimension(:,:), allocatable    :: kp

      real(8), dimension((nm+1)*(nm+1),0:km)  :: wz_work
      real(8), dimension(0:km,0:km)           :: gg
      real(8), dimension(0:km,0:km)           :: gg_work
      logical                                 :: rigid1, rigid2   ! 境界条件

      logical :: first = .true.
      logical :: new_matrix = .false.
      integer :: k,n
      save    :: alu, kp, first

      if (.not. present(cond)) then
         rigid1=.TRUE. 
          rigid2=.TRUE.
      else
         select case (cond)
         case ('RR')
            rigid1 = .TRUE.  
             rigid2 = .TRUE.
         case ('RF')
            rigid1 = .TRUE.  
             rigid2 = .FALSE.
         case ('FR')
            rigid1 = .FALSE. 
             rigid2 = .TRUE.
         case ('FF')
            rigid1 = .FALSE. 
             rigid2 = .FALSE.
         case default
            call MessageNotify('E','wt_laplapol2pol_wt','B.C. not supported')
         end select
      endif

      if (.not. present(new)) then
         new_matrix=.false.
      else 
         new_matrix=new
      endif

      if ( first .OR. new_matrix ) then
         first = .false.

         if ( lm /= km ) then
            call MessageNotify('E','wz_LaplaPol2Pol_wz', 'Chebyshev truncation and number of grid points should be same.')
         endif

         if ( allocated(alu) ) deallocate(alu)
         if ( allocated(kp) ) deallocate(kp)
         allocate(alu((nm+1)*(nm+1),0:km,0:km),kp((nm+1)*(nm+1),0:km))

         do k=0,km
            wz_work = 0.0D0 
             wz_work(:,k) = 1.0D0

            ! 各水平波数に関して独立の式
            alu(:,:,k) = wz_wt(wt_lapla_wt(wt_wz(wz_work)))
         enddo

         ! 運動学的条件. 流線は境界で一定
         gg = 0.0D0
         do k=0,km
            gg(k,k)=1.0D0
         enddo
         do n=1,(nm+1)*(nm+1)
            alu(n,0,:)   = gg(:,0)
            alu(n,km,:)  = gg(:,km)
         enddo

         ! 力学的条件粘着条件 
         if ( rigid1 ) then
            gg_work=az_at(at_dr_at(at_az(gg)))
         else
            gg_work=az_at(at_dr_at(at_dr_at(at_az(gg))))
         endif
         do n=1,(nm+1)*(nm+1)
            alu(n,1,:) = gg_work(:,0)
         enddo

         ! 力学的条件粘着条件 
         if ( rigid2 ) then
            gg_work=az_at(at_dr_at(at_az(gg)))
         else
            gg_work=az_at(at_dr_at(at_dr_at(at_az(gg))))
         endif
         do n=1,(nm+1)*(nm+1)
            alu(n,km-1,:) = gg_work(:,km)
         enddo

         call ludecomp(alu,kp)

         call MessageNotify('M','wz_LaplaPol2Pol_wz', 'Matrix to apply  b.c. newly produced.')
      endif

      wz_work         = wz
      wz_work(:,1)    = 0.0D0               ! 力学的条件
      wz_work(:,km-1) = 0.0D0               ! 力学的条件
      wz_work(:,0)    = 0.0D0               ! 運動学的条件
      wz_work(:,km)   = 0.0D0               ! 運動学的条件 

      wz_laplapol2pol_wz = lusolve(alu,kp,wz_work)

    end function wz_LaplaPol2Pol_wz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001394" class="method-detail">
        <a name="M001394"></a>

        <div class="method-heading">




          <span class="method-name">wz_RAD</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001394">wz_RAD</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001401" class="method-detail">
        <a name="M001401"></a>

        <div class="method-heading">


          <a href="#M001401" class="method-signature">



          <span class="method-name">wz_wt</span><span class="method-args">( wt ) result(wz_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001401">wz_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 次元球面調和函数スペクトル・動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから水平スペクトル・動径格子点データへ(正)変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001401-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001401-source">
<pre>
    function wz_wt(wt)
      !
      ! スペクトルデータから水平スペクトル・動径格子点データへ(正)変換する.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ
      real(8), dimension((nm+1)*(nm+1),0:km)             :: wz_wt
      !(out) 2 次元球面調和函数スペクトル・動径格子点データ

      wz_wt = az_at(wt)

    end function wz_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001400" class="method-detail">
        <a name="M001400"></a>

        <div class="method-heading">


          <a href="#M001400" class="method-signature">



          <span class="method-name">wz_xyz</span><span class="method-args">( xyz ) result(wz_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001400">wz_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 2 次元球面調和函数スペクトル・動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
3 次元格子データから水平スペクトル・動径格子点データへ(正)変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001400-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001400-source">
<pre>
    function wz_xyz(xyz)
      !
      ! 3 次元格子データから水平スペクトル・動径格子点データへ(正)変換する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in)   :: xyz
      !(in) 3 次元経度緯度動径格子点データ
      real(8), dimension((nm+1)*(nm+1),0:km)             :: wz_xyz
      !(out) 2 次元球面調和函数スペクトル・動径格子点データ

      wz_xyz = wa_xya(xyz)

    end function wz_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001433" class="method-detail">
        <a name="M001433"></a>

        <div class="method-heading">


          <a href="#M001433" class="method-signature">



          <span class="method-name">x_AvrLatRad_xyz</span><span class="method-args">( xyz ) result(x_AvrLatRad_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001433">x_AvrLatRad_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度動径(子午面)平均された 1 次元経度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度動径(子午面)積分
</p>
<p>
3 次元格子点データの緯度動径(子午面)平均
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
   ∫f(λ,,r) r^2cosφ dφdr /(2(r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001433-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001433-source">
<pre>
    function x_AvrLatRad_xyz(xyz)  ! 緯度動径(子午面)積分
      !
      ! 3 次元格子点データの緯度動径(子午面)平均
      !
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !    ∫f(λ,,r) r^2cosφ dφdr /(2(r[o]^3-r[i]^3)/3) 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:im-1)     :: x_AvrLatRad_xyz
      !(out) 緯度動径(子午面)平均された 1 次元経度格子点データ

      x_AvrLatRad_xyz = x_IntLatRad_xyz(xyz) /( sum(y_Lat_Weight)*sum(z_Rad_Weight) )

    end function x_AvrLatRad_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001498" class="method-detail">
        <a name="M001498"></a>

        <div class="method-heading">




          <span class="method-name">x_AvrLat_xy</span><span class="method-args">( xy_data ) result(x_AvrLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001498">x_AvrLat_xy</a>(im)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの緯度(Y)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算し, y_Y_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000923">wa_module#x_AvrLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001441" class="method-detail">
        <a name="M001441"></a>

        <div class="method-heading">


          <a href="#M001441" class="method-signature">



          <span class="method-name">x_AvrRad_xz</span><span class="method-args">( xz ) result(x_AvrRad_xz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001441">x_AvrRad_xz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 動径平均された 1 次元経度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
動径積分
</p>
<p>
2 次元(XZ)格子点データの動径方向域平均.
</p>
<p>
2 次元データ f(λ,r) に対して
</p>
<pre>
  ∫f(λ,r) r^2dr /((r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001441-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001441-source">
<pre>
    function x_AvrRad_xz(xz)  ! 動径積分
      !
      ! 2 次元(XZ)格子点データの動径方向域平均.
      !
      ! 2 次元データ f(λ,r) に対して
      !
      !   ∫f(λ,r) r^2dr /((r[o]^3-r[i]^3)/3) 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,0:km), intent(in) :: xz
      !(in) 2 次元緯度動径格子点データ

      real(8), dimension(0:im-1)  :: x_AvrRad_xz
      !(out) 動径平均された 1 次元経度格子点データ

      x_AvrRad_xz = x_IntRad_xz(xz)/sum(z_Rad_Weight)

    end function x_AvrRad_xz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001419" class="method-detail">
        <a name="M001419"></a>

        <div class="method-heading">


          <a href="#M001419" class="method-signature">



          <span class="method-name">x_IntLatRad_xyz</span><span class="method-args">( xyz ) result(x_IntLatRad_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001419">x_IntLatRad_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度動径(子午面)積分された 1 次元経度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
3 次元格子点データの緯度動径(子午面)積分
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
   ∫f(λ,φ,r) r^2cosφ dφdr
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001419-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001419-source">
<pre>
    function x_IntLatRad_xyz(xyz)
      !
      ! 3 次元格子点データの緯度動径(子午面)積分
      !
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !    ∫f(λ,φ,r) r^2cosφ dφdr 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:im-1)     :: x_IntLatRad_xyz
      !(out) 緯度動径(子午面)積分された 1 次元経度格子点データ

      integer :: j, k

      x_IntLatRad_xyz = 0.0D0
      do k=0,km
         do j=1,jm
            x_IntLatRad_xyz = x_IntLatRad_xyz + xyz(:,j,k) * y_Lat_Weight(j) * z_Rad_Weight(k)
         enddo
      enddo
    end function x_IntLatRad_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001493" class="method-detail">
        <a name="M001493"></a>

        <div class="method-heading">




          <span class="method-name">x_IntLat_xy</span><span class="method-args">( xy_data ) result(x_IntLat_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001493">x_IntLat_xy</a>(0:im-1)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元経度(X)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの緯度(Y)方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に y_Y_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000918">wa_module#x_IntLat_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001427" class="method-detail">
        <a name="M001427"></a>

        <div class="method-heading">


          <a href="#M001427" class="method-signature">



          <span class="method-name">x_IntRad_xz</span><span class="method-args">( xz ) result(x_IntRad_xz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001427">x_IntRad_xz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 動径積分された 1 次元経度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元(XZ)格子点データの動径方向域積分.
</p>
<p>
2 次元データ f(λ,r) に対して ∫f(λ,r) r^2dr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001427-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001427-source">
<pre>
    function x_IntRad_xz(xz)
      !
      ! 2 次元(XZ)格子点データの動径方向域積分.
      !
      ! 2 次元データ f(λ,r) に対して ∫f(λ,r) r^2dr を計算する.
      !
      real(8), dimension(0:im-1,0:km), intent(in) :: xz
      !(in) 2 次元緯度動径格子点データ

      real(8), dimension(0:im-1)  :: x_IntRad_xz
      !(out) 動径積分された 1 次元経度格子点データ

      integer :: k

      x_IntRad_xz = 0.0d0
      do k=0,km
         x_IntRad_xz(:) = x_IntRad_xz(:) + xz(:,k) * z_Rad_Weight(k) 
      enddo

    end function x_IntRad_xz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001473" class="method-detail">
        <a name="M001473"></a>

        <div class="method-heading">




          <span class="method-name">x_Lon</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001473">x_Lon</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 緯度経度

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="wa_module.html#M000869">wa_module#x_Lon</a>
</p>


        </div>
      </div>


      <div id="method-M001474" class="method-detail">
        <a name="M001474"></a>

        <div class="method-heading">




          <span class="method-name">x_Lon_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001474">x_Lon_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標重み

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="wa_module.html#M000871">wa_module#x_Lon_Weight</a>
</p>


        </div>
      </div>


      <div id="method-M001432" class="method-detail">
        <a name="M001432"></a>

        <div class="method-heading">


          <a href="#M001432" class="method-signature">



          <span class="method-name">xy_AvrRad_xyz</span><span class="method-args">( xyz ) result(xy_AvrRad_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001432">xy_AvrRad_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 動径平均された 2 次元経度緯度(水平, 球面)格子点データ
水平格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
3 次元格子点データの動径方向域平均.
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
   ∫f(λ,φ,r) r^2dr/((r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001432-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001432-source">
<pre>
    function xy_AvrRad_xyz(xyz)
      !
      ! 3 次元格子点データの動径方向域平均.
      !
      ! 3 次元データ f(λ,φ,r) に対して 
      !
      !    ∫f(λ,φ,r) r^2dr/((r[o]^3-r[i]^3)/3) 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:im-1,1:jm)  :: xy_AvrRad_xyz          
      !(out) 動径平均された 2 次元経度緯度(水平, 球面)格子点データ
      ! 水平格子点データ

      xy_AvrRad_xyz = xy_IntRad_xyz(xyz)/sum(z_Rad_Weight)

    end function xy_AvrRad_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001418" class="method-detail">
        <a name="M001418"></a>

        <div class="method-heading">


          <a href="#M001418" class="method-signature">



          <span class="method-name">xy_IntRad_xyz</span><span class="method-args">( xyz ) result(xy_IntRad_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001418">xy_IntRad_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 動径積分された 2 次元経度緯度(水平, 球面)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
動径積分
</p>
<p>
3 次元格子点データの動径方向域積分.
</p>
<p>
3 次元データ f(λ,φ,r) に対して∫f(λ,φ,r) r^2dr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001418-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001418-source">
<pre>
    function xy_IntRad_xyz(xyz)  ! 動径積分
      !
      ! 3 次元格子点データの動径方向域積分.
      !
      ! 3 次元データ f(λ,φ,r) に対して∫f(λ,φ,r) r^2dr を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:im-1,1:jm)  :: xy_IntRad_xyz
      !(out) 動径積分された 2 次元経度緯度(水平, 球面)格子点データ

      integer :: k

      xy_IntRad_xyz = 0.0d0
      do k=0,km
         xy_IntRad_xyz(:,:) = xy_IntRad_xyz(:,:) + xyz(:,:,k) * z_Rad_Weight(k) 
      enddo
    end function xy_IntRad_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001486" class="method-detail">
        <a name="M001486"></a>

        <div class="method-heading">




          <span class="method-name">xy_Lat</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001486">xy_Lat</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

</td></tr>
</table>
<p>
Original external subprogram is <a
href="wa_module.html#M000874">wa_module#xy_Lat</a>
</p>


        </div>
      </div>


      <div id="method-M001485" class="method-detail">
        <a name="M001485"></a>

        <div class="method-heading">




          <span class="method-name">xy_Lon</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001485">xy_Lon</a>(:,:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

</td></tr>
</table>
<p>
Original external subprogram is <a
href="wa_module.html#M000873">wa_module#xy_Lon</a>
</p>


        </div>
      </div>


      <div id="method-M001488" class="method-detail">
        <a name="M001488"></a>

        <div class="method-heading">




          <span class="method-name">xy_w</span><span class="method-args">( w_data, [ipow], [iflag] ) result(xy_w)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001488">xy_w</a>(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>w_data((nm+1)*(nm+1))  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>ipow  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 作用させる 1/cosφ の次数. 省略時は 0.

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>iflag  </tt></b>  <tt> </tt> :</td><td><tt>integer, intent(in), optional</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 変換の種類

<pre>
   0 : 通常の正変換
  -1 : 経度微分を作用させた逆変換
   1 : 緯度微分 cosφ・∂/∂φ を作用させた逆変換
   2 : sinφを作用させた逆変換
   省略時は 0.
</pre>
</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから格子データへ変換する(1 層用).
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000875">wa_module#xy_w</a>
</p>


        </div>
      </div>


      <div id="method-M001412" class="method-detail">
        <a name="M001412"></a>

        <div class="method-heading">


          <a href="#M001412" class="method-signature">



          <span class="method-name">xyz_Div_xyz_xyz_xyz</span><span class="method-args">( xyz_Vlon, xyz_Vlat, xyz_Vrad ) result(xyz_Div_xyz_xyz_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001412">xyz_Div_xyz_xyz_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の発散

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_Vlon  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_Vlat  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz_Vrad  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の動径成分

</td></tr>
</table>
</td></tr>
</table>
<p>
ベクトル成分である 3 つの格子データに発散を作用させる.
</p>
<p>
第 1, 2 ,3 引数(u,v,w)がそれぞれベクトルの経度成分, 緯度成分,
動径成分を表す.
</p>
<p>
極の特異性を回避するためにベクトル場に cosφ/r の重みをかけて 計算している.
</p>
<pre>
     div V = (r/cosφ)・div (Vcosφ/r) + V_φtanφ/r + V_r/r
</pre>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001412-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001412-source">
<pre>
    function xyz_Div_xyz_xyz_xyz(xyz_Vlon,xyz_Vlat,xyz_Vrad)
      !
      ! ベクトル成分である 3 つの格子データに発散を作用させる.
      !
      ! 第 1, 2 ,3 引数(u,v,w)がそれぞれベクトルの経度成分, 緯度成分, 
      ! 動径成分を表す.
      !
      ! 極の特異性を回避するためにベクトル場に cosφ/r の重みをかけて
      ! 計算している. 
      !
      !      div V = (r/cosφ)・div (Vcosφ/r) + V_φtanφ/r + V_r/r
      ! 
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz_Vlon
      !(in) ベクトル場の経度成分

      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz_Vlat
      !(in) ベクトル場の緯度成分

      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz_Vrad
      !(in) ベクトル場の動径成分

      real(8), dimension(0:im-1,1:jm,0:km)             :: xyz_Div_xyz_xyz_xyz
      !(out) ベクトル場の発散

      xyz_Div_xyz_xyz_xyz = xyz_Rad/cos(xyz_Lat) * xyz_wt(wt_Div_xyz_xyz_xyz(xyz_VLon*cos(xyz_Lat)/xyz_Rad, xyz_VLat*cos(xyz_Lat)/xyz_Rad, xyz_VRad*cos(xyz_Lat)/xyz_Rad )) + xyz_VLat*tan(xyz_Lat)/xyz_Rad + xyz_VRad/xyz_Rad

    end function xyz_Div_xyz_xyz_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001408" class="method-detail">
        <a name="M001408"></a>

        <div class="method-heading">


          <a href="#M001408" class="method-signature">



          <span class="method-name">xyz_GradLat_wt</span><span class="method-args">( wt ) result(xyz_GradLat_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001408">xyz_GradLat_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 勾配型緯度微分を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 1/r ∂/∂φ を作用させる.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001408-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001408-source">
<pre>
    function xyz_GradLat_wt(wt) 
      !
      ! スペクトルデータに勾配型経度微分 1/r ∂/∂φ を作用させる.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension(0:im-1,1:jm,0:km)    :: xyz_GradLat_wt
      !(out) 勾配型緯度微分を作用された 2 次元スペクトルデータ

      xyz_GradLat_wt = xya_GradLat_wa(wz_wt(wt))/xyz_Rad

    end function xyz_GradLat_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001407" class="method-detail">
        <a name="M001407"></a>

        <div class="method-heading">


          <a href="#M001407" class="method-signature">



          <span class="method-name">xyz_GradLon_wt</span><span class="method-args">( wt ) result(xyz_GradLon_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001407">xyz_GradLon_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 勾配型経度微分を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータに勾配型経度微分 1/rcosφ・∂/∂λ を作用させる.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001407-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001407-source">
<pre>
    function xyz_GradLon_wt(wt)
      !
      ! スペクトルデータに勾配型経度微分 1/rcosφ・∂/∂λ
      ! を作用させる.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension(0:im-1,1:jm,0:km)   :: xyz_GradLon_wt
      !(out) 勾配型経度微分を作用された 2 次元スペクトルデータ

      xyz_GradLon_wt = xya_GradLon_wa(wz_wt(wt))/xyz_Rad

    end function xyz_GradLon_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001445" class="method-detail">
        <a name="M001445"></a>

        <div class="method-heading">


          <a href="#M001445" class="method-signature">



          <span class="method-name">xyz_KGrad_wt</span><span class="method-args">( wt ) result(xyz_KGrad_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001445">xyz_KGrad_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 軸方向微分を作用された 2 次元スペクトルデータ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
k・▽ = cosφ/r ∂/∂φ + sinφ∂/∂r
</p>
<p>
入力スペクトルデータに対応する格子データに軸方向微分
</p>
<pre>
   k・▽ = cosφ/r ∂/∂φ + sinφ∂/∂r
</pre>
<p>
を作用させた格子データが返される. ここでベクトル k
は球の中心から北極向きの単位ベクトルである.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001445-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001445-source">
<pre>
    function xyz_KGrad_wt(wt)    ! k・▽ = cosφ/r ∂/∂φ + sinφ∂/∂r
      !
      ! 入力スペクトルデータに対応する格子データに軸方向微分 
      !
      !    k・▽ = cosφ/r ∂/∂φ + sinφ∂/∂r 
      !
      ! を作用させた格子データが返される. 
      ! ここでベクトル k は球の中心から北極向きの単位ベクトルである.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ

      real(8), dimension(0:im-1,1:jm,0:km)                     :: xyz_KGrad_wt
      !(out) 軸方向微分を作用された 2 次元スペクトルデータ

      xyz_KGrad_wt =  cos(xyz_Lat)*xyz_GradLat_wt(wt) + sin(xyz_Lat)*xyz_wt(wt_Drad_wt(wt))

    end function xyz_KGrad_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001392" class="method-detail">
        <a name="M001392"></a>

        <div class="method-heading">




          <span class="method-name">xyz_LAT</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001392">xyz_LAT</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:,:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001391" class="method-detail">
        <a name="M001391"></a>

        <div class="method-heading">




          <span class="method-name">xyz_LON</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001391">xyz_LON</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:,:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001393" class="method-detail">
        <a name="M001393"></a>

        <div class="method-heading">




          <span class="method-name">xyz_RAD</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001393">xyz_RAD</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(:,:,:), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標

</td></tr>
</table>
</td></tr>
</table>


        </div>
      </div>


      <div id="method-M001414" class="method-detail">
        <a name="M001414"></a>

        <div class="method-heading">


          <a href="#M001414" class="method-signature">



          <span class="method-name">xyz_RotLat_wt_wt</span><span class="method-args">( wt_Vlon, wt_Vrad ) result(xyz_RotLat_wt_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001414">xyz_RotLat_wt_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の回転の緯度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt_Vlon  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt_Vrad  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の動径成分

</td></tr>
</table>
</td></tr>
</table>
<p>
ベクトル場の経度成分, 動径成分である第 1, 2 引数 Vlon, Vrad から
回転の緯度成分
</p>
<pre>
   1/r ∂(r Vlon)/∂r - 1/rcosφ・∂Vrad/∂λ
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001414-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001414-source">
<pre>
    function xyz_RotLat_wt_wt(wt_Vlon,wt_Vrad) 
      !
      ! ベクトル場の経度成分, 動径成分である第 1, 2 引数 Vlon, Vrad から
      ! 回転の緯度成分 
      !
      !    1/r ∂(r Vlon)/∂r - 1/rcosφ・∂Vrad/∂λ
      !
      ! を計算する.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt_Vlon
      !(in) ベクトル場の経度成分

      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt_Vrad
      !(in) ベクトル場の動径成分

      real(8), dimension(0:im-1,1:jm,0:km)                     :: xyz_RotLat_wt_wt
      !(out) ベクトル場の回転の緯度成分

        xyz_RotLat_wt_wt =   xyz_wt(wt_RotRad_wt(wt_Vlon)) - xyz_GradLon_wt(wt_Vrad) 

    end function xyz_RotLat_wt_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001413" class="method-detail">
        <a name="M001413"></a>

        <div class="method-heading">


          <a href="#M001413" class="method-signature">



          <span class="method-name">xyz_RotLon_wt_wt</span><span class="method-args">( wt_Vrad, wt_Vlat ) result(xyz_RotLon_wt_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001413">xyz_RotLon_wt_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) ベクトル場の回転の経度成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt_Vrad  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の動径成分

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt_Vlat  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) ベクトル場の緯度成分

</td></tr>
</table>
</td></tr>
</table>
<p>
ベクトル場の動径成分, 緯度成分である第 1, 2 引数 Vrad, Vlat から
回転の経度成分
</p>
<pre>
   1/r ∂Vrad/∂φ-1/r ∂(r Vlat)/∂r を計算する.
</pre>
<p>
を計算する
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001413-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001413-source">
<pre>
    function xyz_RotLon_wt_wt(wt_Vrad,wt_Vlat) 
      !
      ! ベクトル場の動径成分, 緯度成分である第 1, 2 引数 Vrad, Vlat から
      ! 回転の経度成分 
      !
      !    1/r ∂Vrad/∂φ-1/r ∂(r Vlat)/∂r を計算する.
      !
      ! を計算する
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt_Vrad
      !(in) ベクトル場の動径成分

      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt_Vlat
      !(in) ベクトル場の緯度成分

      real(8), dimension(0:im-1,1:jm,0:km)                     :: xyz_RotLon_wt_wt
      !(out) ベクトル場の回転の経度成分

        xyz_RotLon_wt_wt =   xyz_GradLat_wt(wt_Vrad) - xyz_wt(wt_RotRad_wt(wt_Vlat))

    end function xyz_RotLon_wt_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001397" class="method-detail">
        <a name="M001397"></a>

        <div class="method-heading">


          <a href="#M001397" class="method-signature">



          <span class="method-name">xyz_wt</span><span class="method-args">( wt ) result(xyz_wt)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001397">xyz_wt</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wt  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:lm), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数チェビシェフスペクトルデータ

</td></tr>
</table>
</td></tr>
</table>
<p>
スペクトルデータから 3 次元格子点データへ(逆)変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001397-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001397-source">
<pre>
    function xyz_wt(wt)
      !
      ! スペクトルデータから 3 次元格子点データへ(逆)変換する.
      !
      real(8), dimension((nm+1)*(nm+1),0:lm), intent(in) :: wt
      !(in) 2 次元球面調和函数チェビシェフスペクトルデータ
      real(8), dimension(0:im-1,1:jm,0:km)               :: xyz_wt
      !(out) 3 次元経度緯度動径格子点データ

      xyz_wt = xya_wa(wz_wt(wt))

    end function xyz_wt
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001399" class="method-detail">
        <a name="M001399"></a>

        <div class="method-heading">


          <a href="#M001399" class="method-signature">



          <span class="method-name">xyz_wz</span><span class="method-args">( wz ) result(xyz_wz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001399">xyz_wz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>wz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension((nm+1)*(nm+1),0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元球面調和函数スペクトル・動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
水平スペクトル・動径格子点データから 3 次元格子点データへ(逆)変換する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001399-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001399-source">
<pre>
    function xyz_wz(wz)
      !
      ! 水平スペクトル・動径格子点データから 3 次元格子点データへ(逆)変換する.
      !
      real(8), dimension((nm+1)*(nm+1),0:km), intent(in) :: wz
      !(in) 2 次元球面調和函数スペクトル・動径格子点データ
      real(8), dimension(0:im-1,1:jm,0:km)               :: xyz_wz
      !(out) 3 次元経度緯度動径格子点データ

      xyz_wz = xya_wa(wz)

    end function xyz_wz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001431" class="method-detail">
        <a name="M001431"></a>

        <div class="method-heading">


          <a href="#M001431" class="method-signature">



          <span class="method-name">xz_AvrLat_xyz</span><span class="method-args">( xyz ) result(xz_AvrLat_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001431">xz_AvrLat_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度平均された 2 次元緯度動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度積分
</p>
<p>
3 次元格子点データの緯度方向域平均.
</p>
<p>
3 次元データ f(λ,φ,r) に対して ∫f(λ,φ,r)cosφ dφ/2 を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001431-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001431-source">
<pre>
    function xz_AvrLat_xyz(xyz)  ! 緯度積分
      !
      ! 3 次元格子点データの緯度方向域平均.
      !
      ! 3 次元データ f(λ,φ,r) に対して ∫f(λ,φ,r)cosφ dφ/2 を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:im-1,0:km)  :: xz_AvrLat_xyz
      !(out) 緯度平均された 2 次元緯度動径格子点データ

      xz_AvrLat_xyz = xz_IntLat_xyz(xyz)/sum(y_Lat_Weight)

    end function xz_AvrLat_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001417" class="method-detail">
        <a name="M001417"></a>

        <div class="method-heading">


          <a href="#M001417" class="method-signature">



          <span class="method-name">xz_IntLat_xyz</span><span class="method-args">( xyz ) result(xz_IntLat_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001417">xz_IntLat_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度積分された 2 次元緯度動径格子点データ. 緯度円格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
3 次元格子点データの緯度方向域積分.
</p>
<p>
3 次元データ f(λ,φ,r) に対して∫f(λ,φ,r) cosφ dφ を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001417-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001417-source">
<pre>
    function xz_IntLat_xyz(xyz)
      !
      ! 3 次元格子点データの緯度方向域積分.
      !
      ! 3 次元データ f(λ,φ,r) に対して∫f(λ,φ,r) cosφ dφ を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:im-1,0:km)  :: xz_IntLat_xyz        
      !(out) 緯度積分された 2 次元緯度動径格子点データ.
      ! 緯度円格子点データ

      integer :: j

      xz_IntLat_xyz = 0.0d0
      do j=1,jm
         xz_IntLat_xyz(:,:) = xz_IntLat_xyz(:,:) + xyz(:,j,:) * y_Lat_Weight(j)
      enddo
    end function xz_IntLat_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001434" class="method-detail">
        <a name="M001434"></a>

        <div class="method-heading">


          <a href="#M001434" class="method-signature">



          <span class="method-name">y_AvrLonRad_xyz</span><span class="method-args">( xyz ) result(y_AvrLonRad_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001434">y_AvrLonRad_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度動径(緯度円)平均された 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
経度動径(緯度円)積分
</p>
<p>
3 次元格子点データの経度動径(緯度円)平均.
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
    ∫f(λ,φ,r) r^2dλdr /(2π(r[o]^3-r[i]^3)/3)
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001434-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001434-source">
<pre>
    function y_AvrLonRad_xyz(xyz)  ! 経度動径(緯度円)積分
      !
      ! 3 次元格子点データの経度動径(緯度円)平均.
      !
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !     ∫f(λ,φ,r) r^2dλdr /(2π(r[o]^3-r[i]^3)/3) 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(1:jm)       :: y_AvrLonRad_xyz
      !(out) 経度動径(緯度円)平均された 1 次元緯度格子点データ

      y_AvrLonRad_xyz = y_IntLonRad_xyz(xyz) /(sum(x_Lon_Weight)*sum(z_Rad_Weight))

    end function y_AvrLonRad_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001499" class="method-detail">
        <a name="M001499"></a>

        <div class="method-heading">




          <span class="method-name">y_AvrLon_xy</span><span class="method-args">( xy_data ) result(y_AvrLon_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001499">y_AvrLon_xy</a>(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 平均された 1 次元緯度(Y)格子点

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの経度(X)方向平均(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算し, x_X_Weight
の総和で割ることで平均している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000921">wa_module#y_AvrLon_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001438" class="method-detail">
        <a name="M001438"></a>

        <div class="method-heading">


          <a href="#M001438" class="method-signature">



          <span class="method-name">y_AvrRad_yz</span><span class="method-args">( yz ) result(y_AvrRad_yz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001438">y_AvrRad_yz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 動径平均された 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径(子午面)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元(YZ)格子点データの動径方向域平均.
</p>
<p>
2 次元データ f(φ,r) に対して ∫f(φ,r) r^2dr /((r[o]^3-r[i]^3)/3)
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001438-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001438-source">
<pre>
    function y_AvrRad_yz(yz)
      !
      ! 2 次元(YZ)格子点データの動径方向域平均.
      !
      ! 2 次元データ f(φ,r) に対して ∫f(φ,r) r^2dr /((r[o]^3-r[i]^3)/3) 
      ! を計算する.
      !
      real(8), dimension(1:jm,0:km), intent(in) :: yz
      !(in) 2 次元緯度動径(子午面)格子点データ

      real(8), dimension(1:jm)  :: y_AvrRad_yz
      !(out) 動径平均された 1 次元緯度格子点データ

      y_AvrRad_yz = y_IntRad_yz(yz)/sum(z_Rad_Weight)

    end function y_AvrRad_yz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001420" class="method-detail">
        <a name="M001420"></a>

        <div class="method-heading">


          <a href="#M001420" class="method-signature">



          <span class="method-name">y_IntLonRad_xyz</span><span class="method-args">( xyz ) result(y_IntLonRad_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001420">y_IntLonRad_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度動径(緯度円)積分された 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
3 次元格子点データの経度動径(緯度円)積分.
</p>
<p>
3 次元データ f(λ,φ,r) に対して∫f(λ,φ,r) r^2dλdr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001420-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001420-source">
<pre>
    function y_IntLonRad_xyz(xyz)
      !
      ! 3 次元格子点データの経度動径(緯度円)積分.
      !
      ! 3 次元データ f(λ,φ,r) に対して∫f(λ,φ,r) r^2dλdr を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(1:jm)       :: y_IntLonRad_xyz
      !(out) 経度動径(緯度円)積分された 1 次元緯度格子点データ

      integer :: i, k

      y_IntLonRad_xyz = 0
      do k=0,km
         do i=0,im-1
            y_IntLonRad_xyz = y_IntLonRad_xyz + xyz(i,:,k) * x_Lon_Weight(i) * z_Rad_Weight(k)
         enddo
      enddo
    end function y_IntLonRad_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001494" class="method-detail">
        <a name="M001494"></a>

        <div class="method-heading">




          <span class="method-name">y_IntLon_xy</span><span class="method-args">( xy_data ) result(y_IntLon_xy)</span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001494">y_IntLon_xy</a>(1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 積分された 1 次元緯度(Y)格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xy_data(0:im-1,1:jm)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元経度緯度格子点データ(0:im-1,1:jm)

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元緯度経度格子点データの経度(X)方向積分(1 層用).
</p>
<p>
実際には格子点データ各点毎に x_X_Weight をかけた総和を計算している.
</p>
<p>
Original external subprogram is <a
href="wa_module.html#M000916">wa_module#y_IntLon_xy</a>
</p>


        </div>
      </div>


      <div id="method-M001424" class="method-detail">
        <a name="M001424"></a>

        <div class="method-heading">


          <a href="#M001424" class="method-signature">



          <span class="method-name">y_IntRad_yz</span><span class="method-args">( yz ) result(y_IntRad_yz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001424">y_IntRad_yz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 動径積分された 1 次元緯度格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径(子午面)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
動径積分
</p>
<p>
2 次元(YZ)格子点データの動径方向域積分.
</p>
<p>
2 次元データ f(φ,r) に対して∫f(φ,r) r^2dr を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001424-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001424-source">
<pre>
    function y_IntRad_yz(yz)  ! 動径積分
      !
      ! 2 次元(YZ)格子点データの動径方向域積分.
      !
      ! 2 次元データ f(φ,r) に対して∫f(φ,r) r^2dr を計算する.
      !
      real(8), dimension(1:jm,0:km), intent(in) :: yz
      !(in) 2 次元緯度動径(子午面)格子点データ

      real(8), dimension(1:jm)  :: y_IntRad_yz
      !(out) 動径積分された 1 次元緯度格子点データ

      integer :: k

      y_IntRad_yz = 0.0d0
      do k=0,km
         y_IntRad_yz(:) = y_IntRad_yz(:) + yz(:,k) * z_Rad_Weight(k) 
      enddo
    end function y_IntRad_yz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001475" class="method-detail">
        <a name="M001475"></a>

        <div class="method-heading">




          <span class="method-name">y_Lat</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001475">y_Lat</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 緯度経度

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="wa_module.html#M000870">wa_module#y_Lat</a>
</p>


        </div>
      </div>


      <div id="method-M001476" class="method-detail">
        <a name="M001476"></a>

        <div class="method-heading">




          <span class="method-name">y_Lat_Weight</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001476">y_Lat_Weight</a>(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 座標重み

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="wa_module.html#M000872">wa_module#y_Lat_Weight</a>
</p>


        </div>
      </div>


      <div id="method-M001430" class="method-detail">
        <a name="M001430"></a>

        <div class="method-heading">


          <a href="#M001430" class="method-signature">



          <span class="method-name">yz_AvrLon_xyz</span><span class="method-args">( xyz ) result(yz_AvrLon_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001430">yz_AvrLon_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度方向(帯状)平均された 2 次元子午面格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
経度(帯状)積分
</p>
<p>
3 次元格子点データの経度方向(帯状)平均.
</p>
<p>
3 次元データ f(λ,φ,r) に対して ∫f(λ,φ,r)dλ/2π を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001430-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001430-source">
<pre>
    function yz_AvrLon_xyz(xyz)  ! 経度(帯状)積分
      !
      ! 3 次元格子点データの経度方向(帯状)平均.
      !
      ! 3 次元データ f(λ,φ,r) に対して ∫f(λ,φ,r)dλ/2π を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(1:jm,0:km)  :: yz_AvrLon_xyz
      !(out) 経度方向(帯状)平均された 2 次元子午面格子点データ

      yz_AvrLon_xyz = yz_IntLon_xyz(xyz)/sum(x_Lon_Weight)

    end function yz_AvrLon_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001416" class="method-detail">
        <a name="M001416"></a>

        <div class="method-heading">


          <a href="#M001416" class="method-signature">



          <span class="method-name">yz_IntLon_xyz</span><span class="method-args">( xyz ) result(yz_IntLon_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001416">yz_IntLon_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度方向(帯状)積分された 2 次元子午面格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
経度(帯状)積分
</p>
<p>
3 次元格子点データの経度方向(帯状)積分.
</p>
<p>
3 次元データ f(λ,φ,r) に対して ∫f(λ,φ,r)dλ を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001416-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001416-source">
<pre>
    function yz_IntLon_xyz(xyz)  ! 経度(帯状)積分
      !
      ! 3 次元格子点データの経度方向(帯状)積分.
      !
      ! 3 次元データ f(λ,φ,r) に対して ∫f(λ,φ,r)dλ を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(1:jm,0:km)  :: yz_IntLon_xyz
      !(out) 経度方向(帯状)積分された 2 次元子午面格子点データ

      integer :: i

      yz_IntLon_xyz = 0.0d0
      do i=0,im-1
         yz_IntLon_xyz(:,:) = yz_IntLon_xyz(:,:) + xyz(i,:,:) * x_Lon_Weight(i)
      enddo
    end function yz_IntLon_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001437" class="method-detail">
        <a name="M001437"></a>

        <div class="method-heading">


          <a href="#M001437" class="method-signature">



          <span class="method-name">z_AvrLat_yz</span><span class="method-args">( yz ) result(z_AvrLat_yz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001437">z_AvrLat_yz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度平均された 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径(子午面)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元(YZ)格子点データの緯度方向域平均.
</p>
<p>
2 次元データ f(φ,r) に対して ∫f(φ,r) cosφ dφ/2 を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001437-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001437-source">
<pre>
    function z_AvrLat_yz(yz)
      !
      ! 2 次元(YZ)格子点データの緯度方向域平均.
      !
      ! 2 次元データ f(φ,r) に対して ∫f(φ,r) cosφ dφ/2 を計算する.
      !
      real(8), dimension(1:jm,0:km), intent(in) :: yz
      !(in) 2 次元緯度動径(子午面)格子点データ

      real(8), dimension(0:km)  :: z_AvrLat_yz
      !(out) 緯度平均された 1 次元動径格子点データ

      z_AvrLat_yz = z_IntLat_yz(yz)/sum(y_Lat_Weight)

    end function z_AvrLat_yz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001435" class="method-detail">
        <a name="M001435"></a>

        <div class="method-heading">


          <a href="#M001435" class="method-signature">



          <span class="method-name">z_AvrLonLat_xyz</span><span class="method-args">( xyz ) result(z_AvrLonLat_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001435">z_AvrLonLat_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度経度(水平, 球面)平均された 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度経度(水平)積分
</p>
<p>
3 次元格子点データの緯度経度(水平, 球面)積分
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
   ∫f(λ,φ,r) cosφ dλdφ /4π
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001435-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001435-source">
<pre>
    function z_AvrLonLat_xyz(xyz)  ! 緯度経度(水平)積分
      !
      ! 3 次元格子点データの緯度経度(水平, 球面)積分
      ! 
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !    ∫f(λ,φ,r) cosφ dλdφ /4π 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:km)     :: z_AvrLonLat_xyz
      !(out) 緯度経度(水平, 球面)平均された 1 次元動径格子点データ

      z_AvrLonLat_xyz = z_IntLonLat_xyz(xyz) /(sum(x_Lon_Weight)*sum(y_Lat_Weight))

    end function z_AvrLonLat_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001440" class="method-detail">
        <a name="M001440"></a>

        <div class="method-heading">


          <a href="#M001440" class="method-signature">



          <span class="method-name">z_AvrLon_xz</span><span class="method-args">( xz ) result(z_AvrLon_xz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001440">z_AvrLon_xz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度平均された 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
経度(帯状)積分
</p>
<p>
2 次元(XZ)格子点データの経度方向平均.
</p>
<p>
2 次元データ f(λ,r) に対して ∫f(λ,r)dλ/2π を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001440-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001440-source">
<pre>
    function z_AvrLon_xz(xz)  ! 経度(帯状)積分
      !
      ! 2 次元(XZ)格子点データの経度方向平均.
      !
      ! 2 次元データ f(λ,r) に対して ∫f(λ,r)dλ/2π を計算する.
      !
      real(8), dimension(0:im-1,0:km), intent(in) :: xz
      !(in) 2 次元緯度動径格子点データ

      real(8), dimension(0:km)  :: z_AvrLon_xz 
      !(out) 経度平均された 1 次元動径格子点データ

      z_AvrLon_xz = z_IntLon_xz(xz)/sum(x_Lon_Weight)

    end function z_AvrLon_xz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001423" class="method-detail">
        <a name="M001423"></a>

        <div class="method-heading">


          <a href="#M001423" class="method-signature">



          <span class="method-name">z_IntLat_yz</span><span class="method-args">( yz ) result(z_IntLat_yz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001423">z_IntLat_yz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度積分された 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>yz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径(子午面)格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度積分
</p>
<p>
2 次元(YZ)格子点データの緯度方向域積分.
</p>
<p>
2 次元データ f(φ,r) に対して∫f(φ,r) cosφ dφ を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001423-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001423-source">
<pre>
    function z_IntLat_yz(yz)  ! 緯度積分
      !
      ! 2 次元(YZ)格子点データの緯度方向域積分.
      !
      ! 2 次元データ f(φ,r) に対して∫f(φ,r) cosφ dφ を計算する.
      !
      real(8), dimension(jm,0:km), intent(in) :: yz
      !(in) 2 次元緯度動径(子午面)格子点データ

      real(8), dimension(0:km)  :: z_IntLat_yz
      !(out) 緯度積分された 1 次元動径格子点データ

      integer :: j

      z_IntLat_yz = 0.0d0
      do j=1,jm
         z_IntLat_yz(:) = z_IntLat_yz(:) + yz(j,:) * y_Lat_Weight(j)
      enddo
    end function z_IntLat_yz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001421" class="method-detail">
        <a name="M001421"></a>

        <div class="method-heading">


          <a href="#M001421" class="method-signature">



          <span class="method-name">z_IntLonLat_xyz</span><span class="method-args">( xyz ) result(z_IntLonLat_xyz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001421">z_IntLonLat_xyz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 緯度経度(水平, 球面)積分された 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xyz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,1:jm,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 3 次元経度緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
緯度経度(水平)積分
</p>
<p>
3 次元格子点データの緯度経度(水平, 球面)積分
</p>
<p>
3 次元データ f(λ,φ,r) に対して
</p>
<pre>
   ∫f(λ,φ,r) cosφ dλdφ
</pre>
<p>
を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001421-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001421-source">
<pre>
    function z_IntLonLat_xyz(xyz)  ! 緯度経度(水平)積分
      !
      ! 3 次元格子点データの緯度経度(水平, 球面)積分
      ! 
      ! 3 次元データ f(λ,φ,r) に対して
      !
      !    ∫f(λ,φ,r) cosφ dλdφ 
      !
      ! を計算する.
      !
      real(8), dimension(0:im-1,1:jm,0:km), intent(in) :: xyz
      !(in) 3 次元経度緯度動径格子点データ

      real(8), dimension(0:km)     :: z_IntLonLat_xyz
      !(out) 緯度経度(水平, 球面)積分された 1 次元動径格子点データ

      integer :: i, j

      z_IntLonLat_xyz = 0
      do j=1,jm
         do i=0,im-1
            z_IntLonLat_xyz = z_IntLonLat_xyz + xyz(i,j,:) * x_Lon_Weight(i) * y_Lat_Weight(j)
         enddo
      enddo
    end function z_IntLonLat_xyz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001426" class="method-detail">
        <a name="M001426"></a>

        <div class="method-heading">


          <a href="#M001426" class="method-signature">



          <span class="method-name">z_IntLon_xz</span><span class="method-args">( xz ) result(z_IntLon_xz)</span>



          </a>

        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em> Function </em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt><a href="wt_module.html#M001426">z_IntLon_xz</a>  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:km)</tt>

<table>
<tr><td valign="top"> :</td><td> (out) 経度積分された 1 次元動径格子点データ

</td></tr>
</table>
</td></tr>
<tr><td valign="top"><b><tt>xz  </tt></b>  <tt> </tt> :</td><td><tt>real(8), dimension(0:im-1,0:km), intent(in)</tt>

<table>
<tr><td valign="top"> :</td><td> (in) 2 次元緯度動径格子点データ

</td></tr>
</table>
</td></tr>
</table>
<p>
2 次元(XZ)格子点データの経度方向積分.
</p>
<p>
2 次元データ f(λ,r) に対して ∫f(λ,r)dλ を計算する.
</p>


          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M001426-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M001426-source">
<pre>
    function z_IntLon_xz(xz)
      !
      ! 2 次元(XZ)格子点データの経度方向積分.
      !
      ! 2 次元データ f(λ,r) に対して ∫f(λ,r)dλ を計算する.
      !
      real(8), dimension(0:im-1,0:km), intent(in) :: xz
      !(in) 2 次元緯度動径格子点データ

      real(8), dimension(0:km)  :: z_IntLon_xz
      !(out) 経度積分された 1 次元動径格子点データ

      integer :: i

      z_IntLon_xz = 0.0d0
      do i=0,im-1
         z_IntLon_xz(:) = z_IntLon_xz(:) + xz(i,:) * x_Lon_Weight(i)
      enddo

    end function z_IntLon_xz
</pre>
          </div>

        </div>
      </div>


      <div id="method-M001477" class="method-detail">
        <a name="M001477"></a>

        <div class="method-heading">




          <span class="method-name">z_RAD</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>g_X(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点座標 km 次のチェビシェフ多項式の零点から定まる格子点

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="at_module.html#M001335">at_module#g_X</a>
</p>


        </div>
      </div>


      <div id="method-M001478" class="method-detail">
        <a name="M001478"></a>

        <div class="method-heading">




          <span class="method-name">z_RAD_WEIGHT</span><span class="method-args"></span>



        </div>

        <div class="method-description">

          <table>
<tr><td valign="top"><b><em>Variable</em></b> :</td><td>
</td></tr>
<tr><td valign="top"><b><tt>g_X_Weight(:)  </tt></b>  <tt> </tt> :</td><td><tt>real(8), allocatable</tt>

<table>
<tr><td valign="top"> :</td><td> 格子点重み座標 各格子点における積分のための重みが格納してある

</td></tr>
</table>
</td></tr>
</table>
<p>
Original external subprogram is <a
href="at_module.html#M001336">at_module#g_X_Weight</a>
</p>


        </div>
      </div>



    </div>



  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
